<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Y&#39;s blog</title>
  
  
  <link href="https://sch01ar.github.io/atom.xml" rel="self"/>
  
  <link href="https://sch01ar.github.io/"/>
  <updated>2023-04-03T11:34:15.402Z</updated>
  <id>https://sch01ar.github.io/</id>
  
  <author>
    <name>Roo1e</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NKCTF2023</title>
    <link href="https://sch01ar.github.io/2023/04/03/2023NKCTF/"/>
    <id>https://sch01ar.github.io/2023/04/03/2023NKCTF/</id>
    <published>2023-04-03T02:05:45.000Z</published>
    <updated>2023-04-03T11:34:15.402Z</updated>
    
    <content type="html"><![CDATA[<h1>数字中国 Babysecret</h1><p>&lt;!–code￼0–&gt;</p><h1>NKCTF2023</h1><h2 id="babyRSA"><a class="header-anchor" href="#babyRSA">¶</a>babyRSA</h2><p>题目</p><p>&lt;!–code￼1–&gt;</p><h3 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h3><p>题目后半部分是 dp 泄露，通过 N、e、dP 可求出 P、Q</p><p>&lt;!–code￼2–&gt;</p><h4 id="法一"><a class="header-anchor" href="#法一">¶</a>法一</h4><p>之后要通过$P = m<sup>p;mod;n$与$Q=m</sup>q; mod ;n$来求解 m，下面进行一些数学推导</p><p>$$<br>c_1<sup>q=m</sup>{pq};mod;n\\<br>c_1<sup>{pq}=c_2</sup>{p<sup>2};mod;n\\\c_1</sup>{pq}=c_2<sup>{p</sup>2};mod;p\\<br>$$</p><p>根据费马小定理转换可得</p><p>$$<br>c_1<sup>n=c_2</sup>p;mod;p\\<br>gcd(c_1^n-c_2,n);=;p\\<br>$$</p><p>求出 p 和 q 后，使用 crt 即可求得 m</p><p>&lt;!–code￼3–&gt;</p><h4 id="法二"><a class="header-anchor" href="#法二">¶</a>法二</h4><p>通过推导将原式转换为</p><p>$$<br>PQ=(k_1p+m)(k_2q+m)\\<br>m(P+Q)=2m^2+(k_1p+k_2q)m\\<br>PQ-m(P+Q)+m^2=k_1k_2n\\<br>PQ-m(c_1+c_2)+m^2=0;mod;n<br>$$</p><p>&lt;!–code￼4–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;数字中国 Babysecret&lt;/h1&gt;
&lt;p&gt;&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
&lt;h1&gt;NKCTF2023&lt;/h1&gt;
&lt;h2 id=&quot;babyRSA&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#babyRSA&quot;&gt;¶&lt;/a&gt;babyRSA&lt;</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>DUTCTF2023</title>
    <link href="https://sch01ar.github.io/2023/03/28/DUTCTF2023/"/>
    <id>https://sch01ar.github.io/2023/03/28/DUTCTF2023/</id>
    <published>2023-03-28T02:05:45.000Z</published>
    <updated>2023-03-28T09:29:06.114Z</updated>
    
    <content type="html"><![CDATA[<h1>DUTCTF2023wp</h1><h2 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h2><p>仔细一想自己学 CTF 也一年了，纪念一下最后一次参加校赛 🥹，明年可就是出题人了 🤓。但是感觉一年以来荒废了很多时间，在很多方面对题目不熟悉，总跑偏，甚至是自己复现过的一些方法都没意识到（hint 太到位了 😭）。</p><h2 id="Crypto"><a class="header-anchor" href="#Crypto">¶</a>Crypto</h2><p>第一次 ak，好爽 😭</p><h3 id="老滚五"><a class="header-anchor" href="#老滚五">¶</a>*老滚五</h3><p>百度搜龙语，耐心对着找就出了<code>DUTCTF&#123;YOU_ARE_A_REAL_DRAGONBORN&#125;</code></p><h3 id="神奇的短信"><a class="header-anchor" href="#神奇的短信">¶</a>*神奇的短信</h3><p>诺基亚手机，9 键，第一位代表哪个键，第二个代表第几个字母，<code>DUTCTF&#123;SCREW&#125;</code></p><h3 id="随机数的力量"><a class="header-anchor" href="#随机数的力量">¶</a>随机数的力量</h3><p>可先了解一下 MT19937 伪随机数原理，然后看一下<a href="https://blog.csdn.net/qq_42557115/article/details/128228201?spm=1001.2014.3001.5506">破解方法</a>，对于梅森旋转算法之前<a href="https://sch01ar.github.io/2022/10/16/2021ByteCTF-easyxor/">博客</a>也详细推导过。这里针对题目分析一下，首先 ban 掉了 32 位的预测方法，通过了解到，<code>randcrack</code>库实际上是通过收取特定位数来实现预测，例如 32 位数，就需要 624 个，那么如果使用 64 位数，应该就需要 312 个。后续只要对收取的数字进行一下处理，转成 624 个 32 位数即可。<br>这里还有一个疑问就是，最大的 64 位数是$2<sup>{64}-1$，但是如果传$name=2</sup>{64}-1$就无法预测，而改成其余略小一点的 64 位数即可。</p><h4 id="exp"><a class="header-anchor" href="#exp">¶</a>exp</h4><p>&lt;!–code￼0–&gt;</p><h3 id="shamir"><a class="header-anchor" href="#shamir">¶</a>shamir</h3><p>直接找脚本跑，具体如何恢复 a0 系数就不细说了。之前 hitcon 有个也是 shamir 的题，也挺有意思的。<a href="https://sch01ar.github.io/2022/11/28/hitcon2022-BabySSS/">babysss</a></p><p>&lt;!–code￼1–&gt;</p><h3 id="ECC1"><a class="header-anchor" href="#ECC1">¶</a>ECC1</h3><p>发现是 ECDSA 类型，于是现学。。。下面写一下 ECDSA 的签名与验证过程。</p><h4 id="场景"><a class="header-anchor" href="#场景">¶</a>场景</h4><p>Alice 想要使用她的私钥$d_A$来签名，Bob 想用 Alice 的公钥 $H_A$要验证签名$H_A=d_AG$。<br>只有 Alice 才能提供正确的签名，而每个人都可以验证签名。</p><h4 id="签名"><a class="header-anchor" href="#签名">¶</a>签名</h4><p>1.选定一条椭圆曲线$E_p(a,b)$。</p><p>2.选取一个随机数$k,1&lt;k&lt;n-1$，$n$为椭圆曲线的阶。</p><p>3.选取椭圆曲线的基点$G(a,b)$,计算 $K=k * G(a,b)$，令$r=K[0]\mod n$，即 r 是 K 点的横坐标（若 r 为 0，重新选 k 进行计算）。</p><p>4.计算明文 M 的哈希，令$e=hash(M)$，计算$s=k^{-1}(z+rd_A)\mod n$。</p><p>5.给出签名$(r,s)$</p><h4 id="验证"><a class="header-anchor" href="#验证">¶</a>验证</h4><p>1.计算 $u_1=s^{-1}z\mod n$</p><p>2.计算 $u_2=s^{-1}r\mod n$</p><p>3.计算点$P=u_1G+u_2H_A$</p><p>当$r=x_P\mod n$时，签名验证成功。</p><h4 id="解题过程"><a class="header-anchor" href="#解题过程">¶</a>解题过程</h4><p>通过对题目的初步阅读，发现关键是求出私钥<code>d=privkey</code>，而想要求出$d$就要求出$k$，虽然$k$ 是以随机数的形式出现，但发现本题中每次签名过程的 k 并不是完全随机，而是线性伪随机$k = (a * k + b)\mod n$。这里我很想把$k$求出来，然后再去求私钥$d$。所以有没有一种可能，不用求$k$，如果把$k$消掉，方程里只剩一个未知数$d$，即可。细心一点进行数学推导，就会发现答案。<br>$$k_1s_1=e+r_1d\mod n$$<br>$$k_2s_2=e+r_2d\mod n$$<br>$$k_2=ak_1+b\mod n$$<br>$$k_2=ak_1+b+xn$$<br>$$s_1s_2k_2=s_1s_2ak_1+s_1s_2b+s_1s_2xn$$<br>$$s_1(e+r_2d)=s_2a(e+r_1d)+s_1s_2b \mod n$$<br>$$d=(s_1r_2-s_2ar_1)^{-1}(s_2ae-s_1e+s_1s_2b)\mod n$$</p><p>这里两次的使用的$e$一样，是因为传的明文一样，$n$对应的是题目里给的$order$。这里还想说一下自己因为不细致走过的弯路，题目里通过$p$定义的曲线，所以误以为$curve.order$是$p$，这样就会导致前两个式子和第三个算式的模数不同。有趣的是，找到了一篇论文和文章进行了实现。<br><a href="https://cseweb.ucsd.edu/~mihir/papers/dss-lcg.pdf">论文</a><br>但其实$curve.order=order$所以上述所有都是在模$order的条件下$，所以进行一下推导就出了。</p><h4 id="exp-v2"><a class="header-anchor" href="#exp-v2">¶</a>exp</h4><p>&lt;!–code￼2–&gt;</p><h3 id="ECC2"><a class="header-anchor" href="#ECC2">¶</a>ECC2</h3><p>hint:二元 copper<br>看到 hint 瞬间知道怎么做了，前段时间刚学了一下多元 copper，感慨一下还是运用不熟练，没有一眼发现。</p><h4 id="解题思路"><a class="header-anchor" href="#解题思路">¶</a>解题思路</h4><p>同样是 ECDSA，相比于上题来说，k 是随机的，但是每次签名的时候会泄露 k 的高位。此题另外一个关键是，$r$是由私钥$d$生成的，所以不管传什么明文，所得到的$r$是一样的，利用这一点，我们可以构造一个二元方程。<br>$$s_1k_1=z_1+dr \mod n$$<br>$$s_2k_2=z_2+dr \mod n$$<br>$$k=kh+kl$$<br>$$s_1(k_1h+k_1l)-z_1=s_2(k_2h+k_2l)-z_2 \mod n$$<br>$$f(k_1l,k_2l)=s_1(k_1h+k_1l)-z_1-s_2(k_2h+k_2l)+z_2$$<br>随后使用多元 copper 进行求解。具体可看上篇博客。</p><p>&lt;!–code￼3–&gt;</p><h3 id="ez-RSA"><a class="header-anchor" href="#ez-RSA">¶</a>ez_RSA</h3><p>hint 1:<a href="https://www.ijcsi.org/papers/IJCSI-9-2-1-311-314.pdf">论文</a></p><p>hint 2:</p><p>&lt;!–code￼4–&gt;</p><h4 id="解题思路-v2"><a class="header-anchor" href="#解题思路-v2">¶</a>解题思路</h4><p>通过论文，前半部分白给，按照论文造格，即可规约出$_P$。<br>接下来的问题就是如何求$_E$<br>$$c=rh+m \mod p$$<br>$$h=f^{-1}g \mod p$$<br>将一式带入二式<br>$$c=r(f^{-1}g)+m \mod p$$<br>$$cf=rg+mf \mod p$$<br>因为 r 是 1024 位，g 是 768 位，f 是 1024 位，m 是 128 位，p 是 2048 位，所以<br>$$rg+mf \mod p=rg+mf$$<br>$$cf \mod p=rg+mf$$<br>两边同时对$g$取模，即可消去未知数$r$，得到<br>$$m=(f*c \mod p)*f^{-1} \mod g$$</p><h4 id="exp-v3"><a class="header-anchor" href="#exp-v3">¶</a>exp</h4><p>&lt;!–code￼5–&gt;</p><h2 id="misc"><a class="header-anchor" href="#misc">¶</a>misc</h2><h3 id="签到"><a class="header-anchor" href="#签到">¶</a>*签到</h3><p>b 站 21 级 pwn 例会评论区</p><h3 id="我在哪"><a class="header-anchor" href="#我在哪">¶</a>我在哪</h3><p>放大图片看到十八中，搜索临江十八中，发现是重庆十八中，地图上搜一下附近地铁站，挨着桥的就是，曾家岩。</p><h3 id="不要更新"><a class="header-anchor" href="#不要更新">¶</a>不要更新</h3><p>流量分析题，wireshark 里过滤一下 http，找到 github 网页<br><img src="/img/web.png" alt=""><br>根据 hint 查看历史提交记录，发现假 flag，对于密码手来说一眼凯撒，移位 13。<br><img src="/img/kaisa.png" alt=""></p><h2 id="web"><a class="header-anchor" href="#web">¶</a>web</h2><h3 id="Trenja"><a class="header-anchor" href="#Trenja">¶</a>*Trenja</h3><p>F12 打开开发者工具，搜索 flag 字段即可。</p><h2 id="pwn"><a class="header-anchor" href="#pwn">¶</a>pwn</h2><h3 id="中间人"><a class="header-anchor" href="#中间人">¶</a>*中间人</h3><p>太好玩了，原理是汽车滚动码。bob 来开车门，截断，开门失败。bob 再开车门，截断，发送第一次截断信号，bob 开门成功。bob 离开，我们发送第二次截断的信号，打开车门！</p><h2 id="reverse"><a class="header-anchor" href="#reverse">¶</a>reverse</h2><h3 id="贪吃蛇"><a class="header-anchor" href="#贪吃蛇">¶</a>*贪吃蛇</h3><p>拖入 IDA，alt+t 搜索 DUT 即可</p><h3 id="GAME"><a class="header-anchor" href="#GAME">¶</a>*GAME</h3><p>下棋赢了就出了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;DUTCTF2023wp&lt;/h1&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#写在前面&quot;&gt;¶&lt;/a&gt;写在前面&lt;/h2&gt;
&lt;p&gt;仔细一想自己学 CTF 也一年了，纪念一下最后一次参加校赛 🥹，明年可就是出题人了 🤓。但是</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>Coppersmith相关攻击</title>
    <link href="https://sch01ar.github.io/2023/03/07/Coppersmith%E6%94%BB%E5%87%BB/"/>
    <id>https://sch01ar.github.io/2023/03/07/Coppersmith%E6%94%BB%E5%87%BB/</id>
    <published>2023-03-07T02:05:45.000Z</published>
    <updated>2023-03-23T07:22:43.941Z</updated>
    
    <content type="html"><![CDATA[<h1>原理</h1><p>Coppersmith 定理是在一个 e 阶模 n 的多项式$f(x)$中，若有根小于$n^{\frac{1}{e}}$，则可以用 O(log n)的算法求出根。</p><p>直接求解$f(x)$的根可能比较困难，在此利用<code>LLL</code>算法求得多项式$g(x)$，求得的多项式与$f(x)$具有相同的根$x_0$，$g(x)$具有更小的系数，且定义域为整数域。</p><p>本质思想就是把有限域上的方程转化到整数域。</p><h1>理论基础</h1><p>$$f(x,y) = \sum_{i=0}<sup>{d}\sum_{j=0}</sup>{e} a_{i,j}x<sup>iy</sup>j$$</p><h2 id="Howgrave-Graham"><a class="header-anchor" href="#Howgrave-Graham">¶</a>Howgrave-Graham</h2><p><img src="/img/Howgrave.png" alt=""><br>需要构造一个系数更小的多项式，$||g(x)||$代表范数，即最大的系数。构造方法如下<br><img src="/img/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt=""></p><h2 id="LLL-算法"><a class="header-anchor" href="#LLL-算法">¶</a>LLL 算法</h2><p>格基约化算法，通过对构造出的格，从而约化产生符合约束的多项式。<br><img src="/img/LLL.png" alt=""></p><h2 id="p-高位攻击"><a class="header-anchor" href="#p-高位攻击">¶</a>p 高位攻击</h2><p>&lt;!–code￼0–&gt;</p><h2 id="dp-高位攻击"><a class="header-anchor" href="#dp-高位攻击">¶</a>dp 高位攻击</h2><p>给定$e,n,c,dp_0,k,;dp_0=dp&gt;&gt;k$</p><p>$$<br>edp\equiv ed\equiv 1;mod;(p-1)\<br>edp=k(p-1)+1\<br>edp+k-1=kp\<br>edp+k-1 \equiv 0; mod; p\<br>\because dp&lt; p-1\<br>\because edp=k(p-1)+1\<br>\therefore e&gt;k\<br>\therefore e(dp_0 &lt;&lt; k+x)+k-1 \equiv 0;mod;p<br>$$</p><p>&lt;!–code￼1–&gt;</p><h3 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h3><p>&lt;!–code￼2–&gt;</p><h2 id="多元-coppersmith"><a class="header-anchor" href="#多元-coppersmith">¶</a>多元 coppersmith</h2><p><a href="https://lordriot.live/2021/01/06/Way-to-CopperSmith/">原理学习</a><br><a href="https://www.researchgate.net/publication221010552_New_attacks_on_RSA_with_small_secret_CRT-exponents">论文学习 1</a>、<br><a href="https://eprint.iacr.org/2010/146.pdf">论文学习 2</a><br><a href="https://phot0n.com/2022/04/30/MRCTF2022/">脚本来源</a></p><p>&lt;!–code￼3–&gt;</p><p>具体参数说明，例如</p><p>&lt;!–code￼4–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;原理&lt;/h1&gt;
&lt;p&gt;Coppersmith 定理是在一个 e 阶模 n 的多项式$f(x)$中，若有根小于$n^{\frac{1}{e}}$，则可以用 O(log n)的算法求出根。&lt;/p&gt;
&lt;p&gt;直接求解$f(x)$的根可能比较困难，在此利用&lt;code&gt;LLL&lt;/co</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>DLP中常用算法</title>
    <link href="https://sch01ar.github.io/2023/02/24/DLP%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <id>https://sch01ar.github.io/2023/02/24/DLP%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</id>
    <published>2023-02-24T10:05:45.000Z</published>
    <updated>2023-03-04T06:03:05.157Z</updated>
    
    <content type="html"><![CDATA[<h1>Pohlig-Hellman 算法（光滑阶）</h1><p>给定 a,b,p，p 是素数，求 x，$a^x \equiv b (mod;p)$<br>在模 p 下，设该群的生成元为 g，则有</p><p>$$<br>a \equiv g^{a1} (mod;p) \newline<br>b \equiv g^{b1} (mod;p)<br>$$</p><p>联立条件有</p><p>$$<br>g^{a1x} \equiv g^{b1} (mod;p)<br>$$</p><p>由欧拉定理得$\phi§;=;p-1$，则有$a1x;=b1;(mod;(p-1))$</p><p>1.将 p-1 分解，即 $p-1=p_1<sup>{k_1}p_2</sup>{k_2}\cdots p_m^{k_m}$</p><p>2.将 x 表示成$p_i$ 进制,<br>列出方程<br>$$x;=p_i^0a_0 + p_i<sup>1a_1+…+p_i</sup>{k_i-1}a*{k_i-1}$$</p><p>3.令 r=1，求$(a<sup>x)</sup>{\frac{p-1}{p_i^r}}; \equiv b<sup>{\frac{p-1}{p_i</sup>r}}(mod; p)$</p><p>4.将 2 中的公式代入到 3，展开得到<br>$$a^{a0*\frac{p-1}{p_i}}* a^{(p-1)a1} * a<sup>{(p-1)p_ia_2}…a</sup>{(p-1)p_i^{k_i-2}a_{k_i-1}} \equiv b^{\frac{p-1}{p_i}}(mod;p)$$</p><p>5.从第二项开始，后面每项都是 1，欧拉定理:$a^{(p-1)} \equiv 1(mod;p)$，化简得到的式子为<br>$$\newline a^{a0*\frac{p-1}{p_i}} \equiv b^{\frac{p-1}{p_i}}(mod ;p)\newline$$<br>因为该方程只有 a0 未知，所以可在[0,pi-1]范围内爆破出 a0</p><p>6.再令 r = 2,3,4…ki，重复步骤 3，即可求出所有的$a_2,a_3…a_{k_i-1}$，从而得到 m 个关于 x 的方程，最后使用 CRT 进行求解即可。</p><p>总结:将 p-1 的 m 个质因子，分别求出其方程内的所有系数 a，从而构造了 m 个关于 x 的方程，最终利用 CRT 求解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Pohlig-Hellman 算法（光滑阶）&lt;/h1&gt;
&lt;p&gt;给定 a,b,p，p 是素数，求 x，$a^x \equiv b (mod;p)$&lt;br&gt;
在模 p 下，设该群的生成元为 g，则有&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;
a \equiv g^{a1} (mod;p) </summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>近期</title>
    <link href="https://sch01ar.github.io/2023/02/20/%E8%BF%91%E6%9C%9F/"/>
    <id>https://sch01ar.github.io/2023/02/20/%E8%BF%91%E6%9C%9F/</id>
    <published>2023-02-20T06:05:45.000Z</published>
    <updated>2023-03-04T06:00:15.740Z</updated>
    
    <content type="html"><![CDATA[<h1>ECC</h1><p>常用方程（维尔斯特拉斯标准形式）</p><p>$y<sup>2;=x</sup>3+ax+b$，判别式$\Delta=-16(4a<sup>3+27b</sup>2);mod;p=0$</p><h2 id="sage-环境"><a class="header-anchor" href="#sage-环境">¶</a>sage 环境</h2><p>进行简单运算</p><p>&lt;!–code￼0–&gt;</p><h2 id="ECDLP"><a class="header-anchor" href="#ECDLP">¶</a>ECDLP</h2><p>给定椭圆曲线 E，已知 P、Q 以及$Q=kP$，求 k。</p><p>&lt;!–code￼1–&gt;</p><h3 id="crypto-sign-in-1-VNCTF2023"><a class="header-anchor" href="#crypto-sign-in-1-VNCTF2023">¶</a>crypto-sign-in-1(VNCTF2023)</h3><p>一道 ECDLP 题目，当时想到使用<code>Pohlig-Hellman</code>算法，但是一直没能找到合适的 A、B 来确定 G 的阶 n，赛后看大佬 wp，果然是用 pwntools 远程多试几组 y1、y2，找到光滑的阶，从而解密成功。</p><p>&lt;!–code￼2–&gt;</p><h4 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h4><p>&lt;!–code￼3–&gt;</p><h2 id="singular-attack"><a class="header-anchor" href="#singular-attack">¶</a>singular attack</h2><p>利用曲线上的奇异点进行攻击，奇点就是该点导数不存在，或者导数为 0 但不是极值点。<br>若椭圆曲线的判别式$\Delta=-16(4a<sup>3+27b</sup>2);mod;p=0$，说明该曲线有奇点。</p><h3 id="RWCTF2023-体验赛"><a class="header-anchor" href="#RWCTF2023-体验赛">¶</a>RWCTF2023 体验赛</h3><p>&lt;!–code￼4–&gt;</p><p>根据题目，可得到曲线关于 x 的导数，$3x<sup>2+4x+1$，所以可得到方程为$y</sup>2=x<sup>3+2x</sup>2+x+C$</p><p>题目已知点(4,10)在曲线上，代入得到 100 = 64 + 32 + 4 + C，即 C = 0，所以方程确定$y<sup>2=x</sup>3+2x^2+x$</p><p>方程左右求导得到$2y \frac{dy}{dx}=3x^2+4x+1$，所以当 y=0 时导数不存在，再把 y=0 代入方程，求得 x=-1，所以找到该曲线的奇点为(-1,0)。</p><p>下一步我们把曲线平移，使得曲线以(0,0)为奇点，得到<code>y^2 = x^3 + 193387944202565886198256260591909756040*x^2</code>，改写为<code>y^2 = (x + 193387944202565886198256260591909756040) * x^2</code></p><p>因为<code>193387944202565886198256260591909756040 = pow(89654903351345918131227153390056628523,2,p)</code><br>我们就可把 P、Q 点映射到乘法群上，从而进行简单的对数计算。</p><p>映射法则如下:<br>$$(x,y)\rightarrow\frac{y+tx}{y-tx}$$</p><h4 id="EXP-v2"><a class="header-anchor" href="#EXP-v2">¶</a>EXP</h4><p>&lt;!–code￼5–&gt;</p><h1>RSA</h1><h2 id="DLP"><a class="header-anchor" href="#DLP">¶</a>DLP</h2><h3 id="magic-hitcon2021"><a class="header-anchor" href="#magic-hitcon2021">¶</a>magic(hitcon2021)</h3><p>&lt;!–code￼6–&gt;</p><h4 id="EXP-v3"><a class="header-anchor" href="#EXP-v3">¶</a>EXP</h4><h2 id="rabin"><a class="header-anchor" href="#rabin">¶</a>rabin</h2><p>适用于 RSA 中 e=2 的情况</p><h3 id="pqpq-seccon2022"><a class="header-anchor" href="#pqpq-seccon2022">¶</a>pqpq(seccon2022)</h3><p>&lt;!–code￼7–&gt;</p><h4 id="大致思路"><a class="header-anchor" href="#大致思路">¶</a>大致思路</h4><p>根据题目，可先通过计算 c1、c2 表达式，合并找出公因子，即可求出 p、q，从而 r 也可求得。<br>发现 e=65537 * 2，因此是无逆元存在的，索性就将 e 拆分为 65537 与 2，e2=2 时便可通过 Rabin 算法解密。</p><h4 id="求-p、q、r"><a class="header-anchor" href="#求-p、q、r">¶</a>求 p、q、r</h4><p>$c2 = (p - q)^e \mod n \$<br>左右同乘 r<br>$c2 * r = rp^e + rq^e + X*pqr = rp^e + rq^e \mod n\$<br>$c2 = p^e + q^e \mod n\$<br>同理得到$c1 = p^e - q^e \mod n \$<br>从而求得 p、q<br>$p=gcd(c1+c2,n)\$</p><p>$q=gcd(c1-c2,n)\$</p><h4 id="求解-m-2"><a class="header-anchor" href="#求解-m-2">¶</a>求解 m^2</h4><p>$\phi(n)=(p-1)<em>(q-1)</em>(r-1)\$<br>通过 e1(e/2)和$\phi(n)$求出 d，得到$cm<sup>d=m</sup>{2<em>e1</em>d}=m^2 \mod n$</p><h4 id="Rabin-解密"><a class="header-anchor" href="#Rabin-解密">¶</a>Rabin 解密</h4><p>接下来就是传统 Rabin 解密，找了两种脚本，exp 中的<code>sqrtPrime(n,p)</code>和<code>Tonelli_Shanks(n,p)</code>任选其一即可，都是基于二次剩余定理所实现的解密算法</p><p>&lt;!–code￼8–&gt;</p><h2 id="parity"><a class="header-anchor" href="#parity">¶</a>parity</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;ECC&lt;/h1&gt;
&lt;p&gt;常用方程（维尔斯特拉斯标准形式）&lt;/p&gt;
&lt;p&gt;$y&lt;sup&gt;2;=x&lt;/sup&gt;3+ax+b$，判别式$\Delta=-16(4a&lt;sup&gt;3+27b&lt;/sup&gt;2);mod;p=0$&lt;/p&gt;
&lt;h2 id=&quot;sage-环境&quot;&gt;&lt;a class=</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>RSA补充</title>
    <link href="https://sch01ar.github.io/2022/12/07/RSA%E8%A1%A5%E5%85%85/"/>
    <id>https://sch01ar.github.io/2022/12/07/RSA%E8%A1%A5%E5%85%85/</id>
    <published>2022-12-07T13:05:45.000Z</published>
    <updated>2023-02-09T09:15:46.189Z</updated>
    
    <content type="html"><![CDATA[<h1>回顾</h1><p>RSA 中加、解密：</p><p>加密$c = m^e\quad mod\quad n$</p><p>解密$m = c^d\quad mod\quad n$</p><p>接下来证明一下解密过程，先引入欧拉定理。</p><h2 id="欧拉定理"><a class="header-anchor" href="#欧拉定理">¶</a>欧拉定理</h2><p>对于互为质数的 m、n 两个数，有$m^{\phi(n)} = 1\quad mod\quad n$，其中$\phi(n)$表示小于 n 的质数的个数。</p><h2 id="解密原理"><a class="header-anchor" href="#解密原理">¶</a>解密原理</h2><p>通过$c = m^e\quad mod\quad n$与欧拉定理$m^{\phi(n)} = 1\quad mod\quad n$，我们便可进行推导。</p><p>对欧拉定理进行变形，得到$m^{k\phi(n)+1} = m\quad mod\quad n$</p><p>因为我们已经知道$c = m^e\quad mod\quad n$，所以寻找一个 d，使得$ed = k\phi(n)+1$,则可以得到$m^{ed}=m\quad mod \quad n$</p><p>则得到了$c^d =m\quad mod\quad n$</p><h1>共模攻击</h1><p>所谓共模，就是 n 相同，会对应多组 c，e。</p><p>例：给定 n、c1、c2、e1、e2</p><p>m = c<sub>1</sub><sup>e1</sup> mod n</p><p>m = c<sub>2</sub><sup>e2</sup> mod n</p><h2 id="扩展欧几里得算法"><a class="header-anchor" href="#扩展欧几里得算法">¶</a>扩展欧几里得算法</h2><p>给定两个整数 a、b，必定存在 x、y，使得 gcd(a,b)=ax+by</p><p>运用该算法推导过程</p><p>m = m % n</p><p>m = m<sup>s1e1+s2e2</sup> % n</p><p>m = (m<sup>e1s1</sup> * m<sup>e2s2</sup>)% n</p><p>m = (m<sup>e1s1</sup> % n) * (m<sup>e2s2</sup> % n) % n</p><p>m = (c1<sup>s1</sup> % n) * (c2<sup>s2</sup> % n) % n</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p><h1>低加密指数广播攻击</h1><p>特点是 e 小，有多组 n，对应了多组 c</p><p>m<sup>e</sup> = c1 mod n1</p><p>m<sup>e</sup> = c2 mod n2</p><p>m<sup>e</sup> = c3 mod n3</p><h2 id="中国剩余定理-CRT"><a class="header-anchor" href="#中国剩余定理-CRT">¶</a>中国剩余定理(CRT)</h2><p>定理内容如下</p><p>针对上述方程组，若 n1、n2、n3 互质，对于任意的 c1、c2、c3，方程组都有解 m。</p><p>使用条件是 m^e &lt; n1、n2、n3。通解推导如下：</p><p>设$N=n_1 \times n_2 \times n_3, N_1=N/n_1, N_2=N/n_2, N_3=N/n_3$</p><p>设$t_i=N_i^{-1}$,这里表示$t_i$是$N_i$在模$n_i$的逆元。</p><p>有了以上几个数，我们可以给出通解形式：</p><p>$$m=c_1t_1N_1+c_2t_2N_2+c_3t_3N_3+kN=kN+\sum_{i=1}^3c_it_iN_i$$</p><p>在模 N 后，只剩唯一解$m=\sum_{i=1}^3c_it_iN_i$</p><h2 id="EXP-v2"><a class="header-anchor" href="#EXP-v2">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p><h1>dp、dq 相关</h1><h2 id="给定-dp、dq-类型"><a class="header-anchor" href="#给定-dp、dq-类型">¶</a>给定 dp、dq 类型</h2><p>dp ≡ d mod (p-1)</p><p>dq ≡ d mod (q-1)</p><p>m ≡ c<sup>d</sup> mod n</p><p>m = c<sup>d</sup> + k * n</p><p>m = c<sup>d</sup> +k _ p _ q</p><p>对上式两端同时对 p、q 分别取余，得：（中国剩余定理）</p><p>m1 ≡ c<sup>d</sup> mod p</p><p>m2 ≡ c<sup>d</sup> mod q</p><p>同理，可得到<br>c<sup>d</sup> = m1 +k * p</p><p>代入到 m2 ≡ c<sup>d</sup> mod q 中：</p><p>m2 ≡ (m1 + k * p)mod q ，两端减去 m1 得</p><p>m2 - m1 ≡ k * p mod q ，两端乘 p 的逆元得</p><p>(m2 - m1)p<sup>-1</sup> ≡ k mod q</p><p>将 k 代入到 c<sup>d</sup> = m1 +k * p 中得：</p><p>c<sup>d</sup> = m1 + ((m2 - m1)p<sup>-1</sup> mod q) * p</p><p>m=c<sup>d</sup> mod n</p><p>得到</p><p>m ≡ (((m2 - m1) _ p<sup>-1</sup> mod q) _ p + m1) mod n</p><p>接下来就是求解 m1，m2</p><p>m1 ≡ c<sup>dp+k(p-1)</sup> mod p</p><p>m2 ≡ c<sup>dq+k(q-1)</sup> mod q</p><p>根据费马小定理</p><p>若 p 是素数，则 a<sup>(p-1)</sup> ≡ 1 mod p</p><p>因此 m1 ≡ c<sup>dp</sup> mod p，m2 ≡ c<sup>dq</sup> mod q</p><p>最终可求得 m</p><h3 id="EXP-v3"><a class="header-anchor" href="#EXP-v3">¶</a>EXP</h3><p>&lt;!–code￼2–&gt;</p><h2 id="只给定-dp"><a class="header-anchor" href="#只给定-dp">¶</a>只给定 dp</h2><p>dp ≡ d mod (p-1)</p><p>ed ≡ 1 mod (p-1) * (q-1)</p><p>ed = 1 + k2(p-1)(q-1)</p><p>对 1 式两端同乘 e，得</p><p>e * dp ≡ ed mod (p-1)</p><p>e * dp = k1(p-1) + ed</p><p>代入 ed 得</p><p>e * dp = k1(p-1) + 1 + k2(p-1)(q-1)</p><p>由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余 p-1，即可消掉 n</p><p>e * dp ≡ 1 mod (p-1)</p><p>e * dp =k(p-1) + 1</p><p>得到这个式子后，其实真正意义上的未知数只有我们要求的 p，但是还存在一个 k。</p><p>针对 k，我们判断一下他的范围，看看能否采用爆破的方式。</p><p>k = (e * dp - 1)/(p-1)</p><p>因为 dp &lt; p-1</p><p>所以 k &lt; e</p><p>通过遍历 k 然后找到(e * dp - 1)可以整除 k 的情况即可。</p><p>(跑了一下发现限制条件还不够)</p><p>因此再加一个 n 能否整除 p 即可。</p><h3 id="EXP-v4"><a class="header-anchor" href="#EXP-v4">¶</a>EXP</h3><p>&lt;!–code￼3–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;回顾&lt;/h1&gt;
&lt;p&gt;RSA 中加、解密：&lt;/p&gt;
&lt;p&gt;加密$c = m^e\quad mod\quad n$&lt;/p&gt;
&lt;p&gt;解密$m = c^d\quad mod\quad n$&lt;/p&gt;
&lt;p&gt;接下来证明一下解密过程，先引入欧拉定理。&lt;/p&gt;
&lt;h2 id=&quot;欧拉定理</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>2022DASCTF_NOV-lllcccggg-wp</title>
    <link href="https://sch01ar.github.io/2022/11/30/2022DASCTF_NOV-lllcccgggwp/"/>
    <id>https://sch01ar.github.io/2022/11/30/2022DASCTF_NOV-lllcccgggwp/</id>
    <published>2022-11-30T02:05:45.000Z</published>
    <updated>2022-12-01T09:42:22.869Z</updated>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p>如题目名字一样，有好多个lcg，<s>当时看晕了</s><br>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>1.<code>key</code>是一个背包问题，已知公钥<code>m</code>，和的话目前不知道。</p><p>2.以1中的和为<code>seed</code>，通过LCG产生了一组序列<code>output</code>。</p><p>至此，已经可以根据<code>output</code>来求出LCG中的a、b、n，从而求出<code>seed</code>，从而通过背包可求得key。</p><p>3.以<code>key</code>为seed，称作<code>state</code>，再进行LCG，<code>state = (a * state + b) % c</code>，并且a，b，c已知。</p><p>但是想要直接正向求解出最后的state，十分困难，for循环了10^10000次，这里涉及到了<strong>矩阵快速幂</strong>的使用。</p><p>通过构造矩阵<br>$$<br>\mathbf{A} =<br>\begin{bmatrix}<br>state &amp; 1<br>\end{bmatrix}<br>$$<br>$$<br>\mathbf{C} =<br>\begin{bmatrix}<br>a &amp; 0\<br>b &amp; 1\<br>\end{bmatrix}<br>$$<br>通过计算$A<em>C^{10</em>10000}$即可得到矩阵B，B = [ state, 1]</p><p>4.求出state后进行异或解密即可。</p><h1>EXP</h1><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目描述&lt;/h1&gt;
&lt;p&gt;如题目名字一样，有好多个lcg，&lt;s&gt;当时看晕了&lt;/s&gt;&lt;br&gt;
&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;1.&lt;code&gt;key&lt;/code&gt;是一个背包问题，已知公钥&lt;code&gt;m&lt;/code&gt;，和的话目前不</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="wp" scheme="https://sch01ar.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>背包加密算法</title>
    <link href="https://sch01ar.github.io/2022/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/"/>
    <id>https://sch01ar.github.io/2022/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/</id>
    <published>2022-11-28T16:00:00.000Z</published>
    <updated>2022-12-01T09:50:05.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>在一次CTF比赛中遇到了，写了10个for嵌套硬爆出来了，复现的时候发现是背包加密。</p><p><img src="/img/bag.png" alt=""></p><h2 id="Merkle–Hellman-公钥加密算法"><a class="header-anchor" href="#Merkle–Hellman-公钥加密算法">¶</a>Merkle–Hellman 公钥加密算法</h2><p>整体加密流程<br>&lt;!–code￼0–&gt;<br>可以发现，加密十分容易，但解密十分困难，这也是非对称加密的特点。</p><h3 id="加密"><a class="header-anchor" href="#加密">¶</a>加密</h3><h4 id="生成私钥"><a class="header-anchor" href="#生成私钥">¶</a>生成私钥</h4><p>超递增序列，也就是a中每一位元素需要大于其之前所有元素的和。<br>&lt;!–code￼1–&gt;</p><h4 id="生成公钥"><a class="header-anchor" href="#生成公钥">¶</a>生成公钥</h4><p>模数m要求：<code>m &gt; sum(a)</code><br>乘数w要求：<code>gcd(w,m) == 1</code><br>&lt;!–code￼2–&gt;<br>b和m作为公钥。<br>加密：<code>S = numpy.dot(x,b)</code></p><h3 id="解密"><a class="header-anchor" href="#解密">¶</a>解密</h3><p>拿到公钥$M=(m_1,m_2,\ldots,m_n)$，构造如下矩阵<br>$$<br>\begin{bmatrix}<br>2 &amp; 0 &amp; \ldots &amp; 0 &amp; m_1 \<br>0 &amp; 2 &amp; \ldots &amp; 0 &amp; m_2 \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \<br>0 &amp; 0 &amp; \ldots &amp; 2 &amp; m_n \<br>1 &amp; 1 &amp; \ldots &amp; 1 &amp; S \<br>\end{bmatrix}<br>$$<br>这个矩阵的所有行向量的线性组合构成了一个格，接下来将通过明文的特点和格上的特殊解法来进行解密。</p><h4 id="LLL"><a class="header-anchor" href="#LLL">¶</a>LLL</h4><p>对于明文$X=(x_1,x_2,\ldots,x_n)$这一组数来说，构造一个向量<br>$$<br>a=\sum_{i=1}^nx_iv_i-v_{n+1}=(2x_1-1,2x_2-1,\ldots,2x_n-1,0)<br>$$<br>显然，a向量在格L上。因为X中的所有x只能取值0或1，因此a向量的长度很小，约为$\sqrt{n}$，对于很大的格基来说，a向量无疑是格L上的最小向量，因此我们利用LLL算法即可求出a向量。</p><h4 id="例题"><a class="header-anchor" href="#例题">¶</a>例题</h4><p>&lt;!–code￼3–&gt;<br>这里注意一下，第一行向量中是有+1与-1，需要进行取反，即-1代表1，1代表0。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;在一次CTF比赛中遇到了，写了10个for嵌套硬爆出来了，复现的时候发现是背包加密。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/bag.png&quot; al</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="非对称加密" scheme="https://sch01ar.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Hitcon 2022-㊙️BabySSS</title>
    <link href="https://sch01ar.github.io/2022/11/28/hitcon2022-BabySSS/"/>
    <id>https://sch01ar.github.io/2022/11/28/hitcon2022-BabySSS/</id>
    <published>2022-11-27T16:00:00.000Z</published>
    <updated>2022-12-01T09:37:56.735Z</updated>
    
    <content type="html"><![CDATA[<p>I implemented a toy Shamir’s Secret Sharing for fun. Can you help me check is there any issues with this?</p><h1>Shamir’s Secret Sharing密钥分享算法</h1><p>$$f(x)=a_0 + a_1x + a_2x^2 + …… + a_{k-1} x^{k-1} mod p<br>$$</p><h1>题目源码</h1><p>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>题目给了8组x，y的值，可通过CRT模x求出a_0 ，通过模x^2 可求出a_1 ，同理可求出所有系数，恢复出polyeval函数，从而得到正确的secret。</p><h1>EXP</h1><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;I implemented a toy Shamir’s Secret Sharing for fun. Can you help me check is there any issues with this?&lt;/p&gt;
&lt;h1&gt;Shamir’s Secret Sharing</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="wp" scheme="https://sch01ar.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>Gauss格基约简算法</title>
    <link href="https://sch01ar.github.io/2022/11/24/Gauss%E6%A0%BC%E5%9F%BA%E7%BA%A6%E7%AE%80%E7%AE%97%E6%B3%95/"/>
    <id>https://sch01ar.github.io/2022/11/24/Gauss%E6%A0%BC%E5%9F%BA%E7%BA%A6%E7%AE%80%E7%AE%97%E6%B3%95/</id>
    <published>2022-11-23T16:00:00.000Z</published>
    <updated>2022-12-07T09:39:00.075Z</updated>
    
    <content type="html"><![CDATA[<p>由Gauss提出的二维格基约化算法</p><h1>算法伪代码</h1><p>即对给定的两个基向量进行不断的相互约化，最终求得格上的最小向量</p><p>Loop</p><p>(a) If ||v2|| &lt; ||v1||, swap v1, v2</p><p>(b) Compute m = ⌊ v1∙v2 / v1∙v1 ⌉</p><p>© If m = 0, return v1, v2</p><p>(d) v2 = v2 - m*v1</p><p>Continue Loop</p><h1>代码实现</h1><p>&lt;!–code￼0–&gt;</p><h1>例题</h1><p>&lt;!–code￼1–&gt;</p><h2 id="思路"><a class="header-anchor" href="#思路">¶</a>思路</h2><p>给定公钥q、h，以及明文e</p><p>要求私钥f、g</p><p>他们之间有如下关系：</p><p>fh ≡ g mod q</p><p>即 kq + g =fh</p><p>g = fh -kq<br>根据这一特点即可构造格，也就是格密码中很经典的，遇到一个向量乘矩阵，即可进行构造</p><p>由于存在一组a、b，使得a（1，h）+ b（0，q）=（f，g）$a(1,h) + b(0,q) = (f,g)$</p><p>a = f，b = k</p><p>选取一组基底为（1，h）和（0，q），也就是上述高斯约简算法当中的v1与v2，求出v1与v2格上最小的向量，即为（f，g）</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼2–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由Gauss提出的二维格基约化算法&lt;/p&gt;
&lt;h1&gt;算法伪代码&lt;/h1&gt;
&lt;p&gt;即对给定的两个基向量进行不断的相互约化，最终求得格上的最小向量&lt;/p&gt;
&lt;p&gt;Loop&lt;/p&gt;
&lt;p&gt;(a) If ||v2|| &amp;lt; ||v1||, swap v1, v2&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="lattice" scheme="https://sch01ar.github.io/tags/lattice/"/>
    
  </entry>
  
  <entry>
    <title>二叉树建立与遍历</title>
    <link href="https://sch01ar.github.io/2022/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/"/>
    <id>https://sch01ar.github.io/2022/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/</id>
    <published>2022-11-09T16:00:00.000Z</published>
    <updated>2022-12-01T05:15:01.487Z</updated>
    
    <content type="html"><![CDATA[<p>网上很多算法通过直接将二叉树结点连接，从而构成二叉树，这里我构建了一个二叉树类，通过用户控制输入来建立二叉树。</p><p>有层序遍历，递归、非递归的前序遍历、中序遍历、后序遍历算法。</p><p>&lt;!–code￼0–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网上很多算法通过直接将二叉树结点连接，从而构成二叉树，这里我构建了一个二叉树类，通过用户控制输入来建立二叉树。&lt;/p&gt;
&lt;p&gt;有层序遍历，递归、非递归的前序遍历、中序遍历、后序遍历算法。&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://sch01ar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="https://sch01ar.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>2022祥云杯wp-crypto</title>
    <link href="https://sch01ar.github.io/2022/10/30/2022-10-30-2022%E7%A5%A5%E4%BA%91%E6%9D%AFwp-crypto/"/>
    <id>https://sch01ar.github.io/2022/10/30/2022-10-30-2022%E7%A5%A5%E4%BA%91%E6%9D%AFwp-crypto/</id>
    <published>2022-10-29T16:00:00.000Z</published>
    <updated>2022-12-07T09:43:16.370Z</updated>
    
    <content type="html"><![CDATA[<h1>little little fermat</h1><h2 id="题目源码"><a class="header-anchor" href="#题目源码">¶</a>题目源码</h2><p>&lt;!–code￼0–&gt;</p><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>根据题目名字来看，此题和费马小定理的使用有关，题目中有一个<code> obfuscate</code>函数，进行了对q的生成，<code>q=p+A</code>，这里可以看一下A的范围，是在2<sup>[18,319]</sup>之间，因此p、q接近，尝试一下yafu分解。</p><p><img src="/img/20221030.jpg" alt=""><br>题目对m先进行了处理，再进行RSA加密，因此我们需要知道x。<code>assert 114514 ** x % p == 1</code>运用费马小定理，若114514与p互素，则x=p-1，即可求解m。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p><h1>fill</h1><h2 id="题目源码-v2"><a class="header-anchor" href="#题目源码-v2">¶</a>题目源码</h2><p>&lt;!–code￼2–&gt;</p><h2 id="题目分析-v2"><a class="header-anchor" href="#题目分析-v2">¶</a>题目分析</h2><p>随机产生32位的数，sha256()加密后作为flag，并将其2进制的每一位存到了<code>f_list</code>数组中。</p><p>又 创建了一个<code>r_list</code>32位数组，里面存着随机数，先暂时不管。</p><p>双 对<code>r_list</code>数组中的随机数做了加密，产生了<code>M</code>数组。</p><p>对<code>f_list</code>和<code>M</code>数组进行了<code>numpy.dot</code>运算，即向量乘法，得到和为S。</p><p>叒 创建了一个<code>s</code>数组，这个很明显，用LCG线性同余算法进行了加密。</p><p>最后将<code>M</code>数组与<code>s</code>数组相加。</p><p>这就是这道题整体的流程，每一步并不难，只是步骤多，略显复杂。</p><h2 id="EXP-v2"><a class="header-anchor" href="#EXP-v2">¶</a>EXP</h2><h3 id="0x01"><a class="header-anchor" href="#0x01">¶</a>0x01</h3><p>可以先进行一下LCG的求解，把s数组求解出来，从而求出M数组。</p><p>&lt;!–code￼3–&gt;</p><h3 id="0x02"><a class="header-anchor" href="#0x02">¶</a>0x02</h3><p>按理来说，感觉应该根据求出来的<code>M</code>数组进行逆运算，求出<code>r_list</code>数组，但是求出来<code>r_list</code>有什么用呢，所以直接尝试求<code>f_list</code>。因为<code>f_list</code>中不是0就是1，与<code>M</code>做向量乘法，即为<code>M</code>数组中若干元素的和。根据题目给定和S，先大概看一下需要<code>M</code>中多少个元素累加。发现在M前21位和 &lt; S，前22位和 &gt; S，所以猜想应该是M当中，除10个左右元素之外的和。</p><p>这里就遍历了一下，复杂度实在太高了，也没想着能出，结果还真算出来了o.O</p><p>&lt;!–code￼4–&gt;</p><p>也就说明，<code>f_list</code>中下标为这些的，对应值是0，其余为1，即可得到msg的2进制数，转为十进制后进行<code>sha256()</code>加密即可。</p><p>&lt;!–code￼5–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;little little fermat&lt;/h1&gt;
&lt;h2 id=&quot;题目源码&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目源码&quot;&gt;¶&lt;/a&gt;题目源码&lt;/h2&gt;
&lt;p&gt;&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a c</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="wp" scheme="https://sch01ar.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>2022NewStarCTF-flip_flop</title>
    <link href="https://sch01ar.github.io/2022/10/27/2022NewStarCTF-flip_flop/"/>
    <id>https://sch01ar.github.io/2022/10/27/2022NewStarCTF-flip_flop/</id>
    <published>2022-10-26T16:00:00.000Z</published>
    <updated>2022-12-07T09:41:52.644Z</updated>
    
    <content type="html"><![CDATA[<h1>flip-flop</h1><p>AES-CBC加密模式</p><h2 id="题目"><a class="header-anchor" href="#题目">¶</a>题目</h2><p>源码如下：<br>&lt;!–code￼0–&gt;</p><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>此题是通过注册得到的用户账户的密文，然后输入管理员账户对应的密文，才能得到flag。</p><p>对用户账户和管理员账户的加密解密均采用AES-CBC模式，但是本题仅有一组明文，iv仅作为偏移量，也就是本题中的user_key。</p><p>这里先来说一下我最一开始的思路，由于user_key每次是随机产生的，但是一次程序的运行当中是不变的。由于密文由两部分组成，前半部分为user_key.hex()，后半部分为code.hex()，所以只要构造出admin对应的code即可，那么就需要AES加密当中的key，所以就需要构造一个key来产生出admin对应的code。查询了很多资料发现都难以实现。于是……</p><p>那为什么不换一下思路？不能构造code，能不能构造iv？</p><p>先来看一下加密方式：</p><p>C = encrypt(M ^ iv)</p><p>M = decrypt©^iv</p><p>对应一下本题当中的NewStarCTFer和admin：<br><code>b'NewStarCTFer____' = decrypt(code) ^ iv1</code></p><p><code>b'AdminAdmin______' = decrypt(code) ^ iv2</code></p><p>因此可求出admin对应的iv2，随后拼接上普通用户的后半段code即可。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;flip-flop&lt;/h1&gt;
&lt;p&gt;AES-CBC加密模式&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目&quot;&gt;¶&lt;/a&gt;题目&lt;/h2&gt;
&lt;p&gt;源码如下：&lt;br&gt;
&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
&lt;h2 id</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="wp" scheme="https://sch01ar.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>BUU刷题日记20221026</title>
    <link href="https://sch01ar.github.io/2022/10/26/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221026/"/>
    <id>https://sch01ar.github.io/2022/10/26/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221026/</id>
    <published>2022-10-25T16:00:00.000Z</published>
    <updated>2022-12-07T09:39:19.641Z</updated>
    
    <content type="html"><![CDATA[<h1>RSA5</h1><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>给定e=65537</p><p>给了很多组n、c</p><p>由于e过大，所以不考虑使用CRT，由于m是同一个，因此遍历一下，求出两个n的最大公约数，即为p，后续就简单了。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;RSA5&lt;/h1&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目分析&quot;&gt;¶&lt;/a&gt;题目分析&lt;/h2&gt;
&lt;p&gt;给定e=65537&lt;/p&gt;
&lt;p&gt;给了很多组n、c&lt;/p&gt;
&lt;p&gt;由于e过大，所以不考虑使用CRT，由于m是同一</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="diary" scheme="https://sch01ar.github.io/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>2022 DASCTF 10月挑战赛wp</title>
    <link href="https://sch01ar.github.io/2022/10/23/2022DASCTF10%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwp/"/>
    <id>https://sch01ar.github.io/2022/10/23/2022DASCTF10%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwp/</id>
    <published>2022-10-22T16:00:00.000Z</published>
    <updated>2022-12-07T09:42:51.960Z</updated>
    
    <content type="html"><![CDATA[<h1>RSA</h1><h2 id="题目如下"><a class="header-anchor" href="#题目如下">¶</a>题目如下</h2><p>&lt;!–code￼0–&gt;</p><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>该题的加密顺序是：</p><p>1、加密flag，分为两部分m1、m2</p><p>2、加密m1</p><p>3、加密m2</p><p>同理我们解密的顺序应该也是</p><p>1、解出m1、m2</p><p>2、解出flag</p><h3 id="求m2"><a class="header-anchor" href="#求m2">¶</a>求m2</h3><p>先观察一下encrypt4函数</p><p>虽然说e_2=3，按理来说使用低加密指数攻击，但并不可行。</p><p>又因为m = m % k</p><p>可通过这点和<code>c_3 = pow(m, e_2, n_3)</code>做遍历求出m</p><p>最后发现m即为m2，m2 &lt; k</p><h3 id="求m1"><a class="header-anchor" href="#求m1">¶</a>求m1</h3><p>发现m1加密方式采用RSA，但是n_1未知</p><p>n_1又通过一次RSA加密，已知n_1对应的密文</p><p>利用低加密指数攻击解出n1</p><p>发现n1可分解为3个素数乘积</p><p>故phi可求，即求出m1</p><h3 id="求flag"><a class="header-anchor" href="#求flag">¶</a>求flag</h3><p>观察encryt1</p><p>m1是flag右移200位之后转为字节</p><p>m2是flag的20位之后转成字节</p><p>所以来说m2是没什么问题，主要找到flag的前20位，再把m2拼到后面即可。</p><p>由于m1是flag右移200位，因此flag的低位缺失，但高位还在，由于不知道flag总长度，抱着试一试的心态，猜测一下它的高位前20位没有缺失</p><p>我们将m1和m2转为字节发现</p><p>m1:b’0x666c61677b3230366538353964’</p><p>m2:b’383539643865383534633466363030636231323735376262663966357d’</p><p>发现m1和m2有重叠部分，即38353开始</p><p>可以证实m1前20位确实没有缺失</p><p>因此取m1前20位，加m2，即可解出flag</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;RSA&lt;/h1&gt;
&lt;h2 id=&quot;题目如下&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目如下&quot;&gt;¶&lt;/a&gt;题目如下&lt;/h2&gt;
&lt;p&gt;&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a class=&quot;header-anch</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="wp" scheme="https://sch01ar.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>BUU刷题日记20221022</title>
    <link href="https://sch01ar.github.io/2022/10/22/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221022/"/>
    <id>https://sch01ar.github.io/2022/10/22/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221022/</id>
    <published>2022-10-21T16:00:00.000Z</published>
    <updated>2022-12-07T09:40:10.592Z</updated>
    
    <content type="html"><![CDATA[<h1>RSA4</h1><p>题目只给了三组n、c，采用中国剩余定理，具体推导如下</p><h2 id="推导过程"><a class="header-anchor" href="#推导过程">¶</a>推导过程</h2><p>m<sup>e</sup> ≡ c1 mod n1<br>m<sup>e</sup> ≡ c2 mod n2<br>m<sup>e</sup> ≡ c3 mod n3</p><h3 id="中国剩余定理（CRT）"><a class="header-anchor" href="#中国剩余定理（CRT）">¶</a>中国剩余定理（CRT）</h3><p>中国剩余定理的内容是：</p><p>针对上述方程组，若n1、n2、n3互质，对于任意的c1、c2、c3，方程组都有解，使用条件是m^e &lt; n1、n2、n3。通解形式如下：</p><p>令N = n1 * n2 * n3，N1 = N/n1，N2、N3同理</p><p>令t1 = N1<sup>(-1)</sup>，即其对应的模n1运算的逆元，t2，t3同理，可用<code>t1=gmpy2.invert(N1,n1)</code>表示。</p><p>有了Ni和ti的定义，我们就可以给出通解形式：</p><p>x = c1 * N1 * t1 ……</p><p>有了通解公式我们就可以求出m^e，对e进行一下遍历即可，m开方成功即可。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;RSA4&lt;/h1&gt;
&lt;p&gt;题目只给了三组n、c，采用中国剩余定理，具体推导如下&lt;/p&gt;
&lt;h2 id=&quot;推导过程&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#推导过程&quot;&gt;¶&lt;/a&gt;推导过程&lt;/h2&gt;
&lt;p&gt;m&lt;sup&gt;e&lt;/sup&gt; ≡ c1 mod</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="diary" scheme="https://sch01ar.github.io/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>BUU刷题日记20221021</title>
    <link href="https://sch01ar.github.io/2022/10/21/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221021/"/>
    <id>https://sch01ar.github.io/2022/10/21/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221021/</id>
    <published>2022-10-20T16:00:00.000Z</published>
    <updated>2022-12-08T05:42:21.849Z</updated>
    
    <content type="html"><![CDATA[<h1>RSA2</h1><p>题目给定n、e、dp、c</p><p>非预期解：直接分解n</p><p>下面考虑n不能分解的情况</p><h2 id="推导过程"><a class="header-anchor" href="#推导过程">¶</a>推导过程</h2><p>dp ≡ d mod (p-1)</p><p>ed ≡ 1 mod (p-1) * (q-1)</p><p>ed = 1 + k2(p-1)(q-1)</p><p>对1式两端同乘e，得</p><p>e * dp ≡ ed mod (p-1)</p><p>e * dp = k1(p-1) + ed</p><p>代入ed得</p><p>e * dp = k1(p-1) + 1 + k2(p-1)(q-1)</p><p>由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余p-1，即可消掉n</p><p>e * dp ≡ 1 mod (p-1)</p><p>e * dp =k(p-1) + 1</p><p>得到这个式子后，其实真正意义上的未知数只有我们要求的p，但是还存在一个k。</p><p>针对k，我们判断一下他的范围，看看能否采用爆破的方式。</p><p>k = (e * dp - 1)/(p-1)</p><p>因为dp &lt; p-1</p><p>所以k &lt; e</p><p>通过遍历k然后找到(e * dp - 1)可以整除k的情况即可。</p><p>(跑了一下发现限制条件还不够)</p><p>因此再加一个n能否整除p即可。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p><h1>RSA3</h1><p>给定n、e1、c1、e2、c2。</p><p>m ≡ c1^e1 mod n</p><p>m ≡ c2^e2 mod n</p><p>这里采用共模攻击，详细原理如下：</p><p>扩展欧几里得算法：给定两个整数a、b，必定存在x、y，使得gcd(a,b)=ax+by</p><p>对应到本题当中，由于e1、e2互为素数，因此gcd(e1,e2)=1，从而存在s1、s2使得:</p><p>s1 * e1 + s2 * e2 = 1</p><h2 id="推导过程-v2"><a class="header-anchor" href="#推导过程-v2">¶</a>推导过程</h2><p>m = m % n</p><p>m = m^(s1 * e1 + s2 * e2)^ % n</p><p>m = m^(e1 * s1)^ * m^(e2 * s2)^ % n</p><p>m = (m^(e1 * s1)^ % n) * (m^(e2 * s2)^ % n) % n</p><p>m = (c1<sup>s1</sup> % n) * (c2<sup>s2</sup> % n) % n</p><h2 id="EXP-v2"><a class="header-anchor" href="#EXP-v2">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;RSA2&lt;/h1&gt;
&lt;p&gt;题目给定n、e、dp、c&lt;/p&gt;
&lt;p&gt;非预期解：直接分解n&lt;/p&gt;
&lt;p&gt;下面考虑n不能分解的情况&lt;/p&gt;
&lt;h2 id=&quot;推导过程&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#推导过程&quot;&gt;¶&lt;/a&gt;推导过程&lt;/h2&gt;
&lt;</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="diary" scheme="https://sch01ar.github.io/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>BUU刷题日记20221020</title>
    <link href="https://sch01ar.github.io/2022/10/20/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221020/"/>
    <id>https://sch01ar.github.io/2022/10/20/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221020/</id>
    <published>2022-10-19T16:00:00.000Z</published>
    <updated>2022-12-06T07:25:59.850Z</updated>
    
    <content type="html"><![CDATA[<h1>RSA1</h1><p>给定dp、dq类型</p><p>dp ≡ d mod (p-1)</p><p>dq ≡ d mod (q-1)</p><p>m ≡ c<sup>d</sup> mod n</p><p>m = c<sup>d</sup> + k * n</p><p>m = c<sup>d</sup> +k * p * q</p><p>对上式两端同时对p、q分别取余，得：（中国剩余定理）</p><p>m1 ≡ c<sup>d</sup> mod p</p><p>m2 ≡ c<sup>d</sup> mod q</p><p>同理，可得到<br>c<sup>d</sup> = m1 +k * p</p><p>代入到 m2 ≡ c<sup>d</sup> mod q 中：</p><p>m2 ≡ (m1 + k * p)mod q ，两端减去m1得</p><p>m2 - m1 ≡ k * p mod q ，两端乘p的逆元得</p><p>(m2 - m1)p<sup>-1</sup> ≡ k mod q</p><p>将k代入到 c<sup>d</sup> = m1 +k * p 中得：</p><p>c<sup>d</sup> = m1 + ((m2 - m1)p<sup>-1</sup> mod q) * p</p><p>m=c<sup>d</sup> mod n</p><p>得到</p><p>m ≡ (((m2 - m1) * p<sup>-1</sup> mod q) * p + m1) mod n</p><p>接下来就是求解m1，m2</p><p>m1 ≡ c<sup>dp+k(p-1)</sup> mod p</p><p>m2 ≡ c<sup>dq+k(q-1)</sup> mod q</p><p>根据费马小定理</p><p>若p是素数，则a<sup>(p-1)</sup> ≡ 1 mod p</p><p>因此 m1 ≡ c<sup>dp</sup> mod p，m2 ≡ c<sup>dq</sup> mod q</p><p>最终可求得m</p><h2 id="exp"><a class="header-anchor" href="#exp">¶</a>exp</h2><p>&lt;!–code￼0–&gt;</p><h1>RSAROLL</h1><p>&lt;!–code￼1–&gt;<br>给了一个data.txt文件，打开盲猜一下第一行是n，e，后面是c<br>&lt;!–code￼2–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;RSA1&lt;/h1&gt;
&lt;p&gt;给定dp、dq类型&lt;/p&gt;
&lt;p&gt;dp ≡ d mod (p-1)&lt;/p&gt;
&lt;p&gt;dq ≡ d mod (q-1)&lt;/p&gt;
&lt;p&gt;m ≡ c&lt;sup&gt;d&lt;/sup&gt; mod n&lt;/p&gt;
&lt;p&gt;m = c&lt;sup&gt;d&lt;/sup&gt; + k * n&lt;/</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="diary" scheme="https://sch01ar.github.io/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>2021ByteCTF-easyxor</title>
    <link href="https://sch01ar.github.io/2022/10/16/2021ByteCTF-easyxor/"/>
    <id>https://sch01ar.github.io/2022/10/16/2021ByteCTF-easyxor/</id>
    <published>2022-10-15T16:00:00.000Z</published>
    <updated>2022-12-07T09:34:59.756Z</updated>
    
    <content type="html"><![CDATA[<h1>题目源码如下</h1><p>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>将flag分为两段，前半段采用OFB加密，后半段采用CBC加密</p><h2 id="OFB解密"><a class="header-anchor" href="#OFB解密">¶</a>OFB解密</h2><p>将前半段flag又进行切分，将其8位分为一组，存到group数组中。<br>&lt;!–code￼1–&gt;<br>针对一个随机生成的64位的last，与keys进行convert加密，再与group中的数进行异或。<br>keys是四个-32～32的数，可爆破。<br>对于OFB解密十分简单，因为我们已知第一组明文，恰好是8位的’ByteCTF{'，由于分组密码的性质，所以后面的也就迎刃而解，通过group[ 0]^cipher[ 0] 即可得到cur_c，从而求得下一次的cur_c，以此类推。</p><h3 id="expOFB"><a class="header-anchor" href="#expOFB">¶</a>expOFB</h3><p>&lt;!–code￼2–&gt;</p><h2 id="CBC解密"><a class="header-anchor" href="#CBC解密">¶</a>CBC解密</h2><p>针对后半部分，我们需要逆向解出convert函数，因此就是对shift函数中的加密运算进行解密。<br>之前上网搜的wp都一笔带过，没解释unshift逆函数怎么写的。“难道有什么定理？？”<br>这里简单写一下我的理解。</p><h3 id="分析shift"><a class="header-anchor" href="#分析shift">¶</a>分析shift</h3><p>&lt;!–code￼3–&gt;</p><h4 id="推理过程"><a class="header-anchor" href="#推理过程">¶</a>推理过程</h4><p>这里我们举例k&gt;0时的情况。（k&lt;0同理）</p><p>m和c都是64位,k是-32～32的10进制数。</p><p>1、m &lt;&lt; k相当于在m后补k位0，得到的新数我们称为a，a=m &lt;&lt; k。</p><p>2、令b = a &amp; c，由于a是64+k位，c是64位，所以b是64位，并且b的后k位都是0。</p><p>3、令x = m ^ b，x则是shift加密之后的值，x也是64位，并且x的后k位是与m的后k位相同的，与0异或得本身。</p><p>我们走完了一遍shift加密，得到的结论是，密文的位数同样是64，并且密文的后k位与明文相同。</p><h3 id="分析unshift"><a class="header-anchor" href="#分析unshift">¶</a>分析unshift</h3><p>&lt;!–code￼4–&gt;</p><h4 id="推理过程-v2"><a class="header-anchor" href="#推理过程-v2">¶</a>推理过程</h4><p>同样我们举例k&gt;0的情况。</p><p>之前我们得到的密文x，相当于tmp。</p><p>1、a’=tmp &lt;&lt; k，tmp后k位为0，tmp后2k～k位等于m的后k位。</p><p>2、b’=a’ &amp; c，b’后k位为0，后2k～k位为m&amp;c。</p><p>3、y=x ^ b’，y的后k位，等于x的后k位，也就是m的后k位。</p><p>4、y的后2k～k位，在shift加密当中，a &amp; c的后2k～k位等于m的后k位&amp;c，记作m1 &amp; c。</p><p>shift中的x，也就是m ^ b，m ^(m1 &amp; c)，在unshift最后的一步操作中，y= m ^(m1 &amp; c) ^ b’。</p><p>这时我们只考虑y的后2k～k位，y=m ^(m1 &amp; c)^(m1 &amp; c) = m</p><p>所以这时y的2k～k位也等于m了。</p><h4 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h4><p>因此，我们发现每经过unshift一次，就有k位被还原，何时才能被完全还原？即循环bits//k次。</p><p>此推理正确，可以在unshift函数运行时输出每次的tmp观察即可。</p><p>ps：自我感觉这种位运算应该是属于一种性质或者定理，网上大佬们都是说“简单写个逆”。。。</p><h3 id="expCBC"><a class="header-anchor" href="#expCBC">¶</a>expCBC</h3><p>&lt;!–code￼5–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目源码如下&lt;/h1&gt;
&lt;p&gt;&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;将flag分为两段，前半段采用OFB加密，后半段采用CBC加密&lt;/p&gt;
&lt;h2 id=&quot;OFB解密&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="wp" scheme="https://sch01ar.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>2022BUUCTF新生赛-RSA</title>
    <link href="https://sch01ar.github.io/2022/10/16/2022BUUCTF%E6%96%B0%E7%94%9F%E8%B5%9B-RSA/"/>
    <id>https://sch01ar.github.io/2022/10/16/2022BUUCTF%E6%96%B0%E7%94%9F%E8%B5%9B-RSA/</id>
    <published>2022-10-15T16:00:00.000Z</published>
    <updated>2022-12-08T07:35:16.441Z</updated>
    
    <content type="html"><![CDATA[<h1>题目源码</h1><p>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>发现n和phin都不常规，没入手点，发现hint，hint=pow(d,e,n)，有趣，用d做明文，尝试推理一下：<br>d = pow(hint,d,n)<br>d = pow((d ** e % n),d,n)<br>d = (d ** e % n) ** d % n<br>d = d ** (e*d) % n<br>d = pow(d ** e,d,n)<br>把d ** e再次看做密文，可得<br>d ** e = pow(d,e,n)<br>因为hint = pow(d,e,n)<br>可得hint = d ** e<br>d ** e * e ** e-&gt;(ed) ** e-&gt;(ed) ** e == 1 mod phin<br>因此根据e和hint即可求得phin<br>从而得到phin和n的最大公约数p<br>脚本如下<br>&lt;!–code￼1–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目源码&lt;/h1&gt;
&lt;p&gt;&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;发现n和phin都不常规，没入手点，发现hint，hint=pow(d,e,n)，有趣，用d做明文，尝试推理一下：&lt;br&gt;
d = pow(hint,d,n)&lt;br&gt;
</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="wp" scheme="https://sch01ar.github.io/tags/wp/"/>
    
  </entry>
  
</feed>
