<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Y&#39;s blog</title>
  
  
  <link href="https://sch01ar.github.io/atom.xml" rel="self"/>
  
  <link href="https://sch01ar.github.io/"/>
  <updated>2022-12-08T04:50:15.483Z</updated>
  <id>https://sch01ar.github.io/</id>
  
  <author>
    <name>Roo1e</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RSA补充</title>
    <link href="https://sch01ar.github.io/2022/12/07/RSA%E8%A1%A5%E5%85%85/"/>
    <id>https://sch01ar.github.io/2022/12/07/RSA%E8%A1%A5%E5%85%85/</id>
    <published>2022-12-07T13:05:45.000Z</published>
    <updated>2022-12-08T04:50:15.483Z</updated>
    
    <content type="html"><![CDATA[<h1>回顾</h1><p>RSA中加、解密：</p><p>$$c = m<sup>e</sup> mod n$$</p><p>$$m = c<sup>d</sup> mod n$$</p><p>接下来证明一下解密过程，先引入欧拉定理。</p><h2 id="欧拉定理"><a class="header-anchor" href="#欧拉定理">¶</a>欧拉定理</h2><p>$$<br>m<sup>{\phi(n)}</sup> = 1 mod n<br>$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;回顾&lt;/h1&gt;
&lt;p&gt;RSA中加、解密：&lt;/p&gt;
&lt;p&gt;$$c = m&lt;sup&gt;e&lt;/sup&gt; mod n$$&lt;/p&gt;
&lt;p&gt;$$m = c&lt;sup&gt;d&lt;/sup&gt; mod n$$&lt;/p&gt;
&lt;p&gt;接下来证明一下解密过程，先引入欧拉定理。&lt;/p&gt;
&lt;h2 id=&quot;欧拉定理&quot;</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>2022DASCTF_NOV-lllcccggg-wp</title>
    <link href="https://sch01ar.github.io/2022/11/30/2022DASCTF_NOV-lllcccgggwp/"/>
    <id>https://sch01ar.github.io/2022/11/30/2022DASCTF_NOV-lllcccgggwp/</id>
    <published>2022-11-30T02:05:45.000Z</published>
    <updated>2022-12-01T09:42:22.869Z</updated>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p>如题目名字一样，有好多个lcg，<s>当时看晕了</s><br>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>1.<code>key</code>是一个背包问题，已知公钥<code>m</code>，和的话目前不知道。</p><p>2.以1中的和为<code>seed</code>，通过LCG产生了一组序列<code>output</code>。</p><p>至此，已经可以根据<code>output</code>来求出LCG中的a、b、n，从而求出<code>seed</code>，从而通过背包可求得key。</p><p>3.以<code>key</code>为seed，称作<code>state</code>，再进行LCG，<code>state = (a * state + b) % c</code>，并且a，b，c已知。</p><p>但是想要直接正向求解出最后的state，十分困难，for循环了10^10000次，这里涉及到了<strong>矩阵快速幂</strong>的使用。</p><p>通过构造矩阵<br>$$<br>\mathbf{A} =<br>\begin{bmatrix}<br>state &amp; 1<br>\end{bmatrix}<br>$$<br>$$<br>\mathbf{C} =<br>\begin{bmatrix}<br>a &amp; 0\<br>b &amp; 1\<br>\end{bmatrix}<br>$$<br>通过计算$A<em>C^{10</em>10000}$即可得到矩阵B，B = [ state, 1]</p><p>4.求出state后进行异或解密即可。</p><h1>EXP</h1><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目描述&lt;/h1&gt;
&lt;p&gt;如题目名字一样，有好多个lcg，&lt;s&gt;当时看晕了&lt;/s&gt;&lt;br&gt;
&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;1.&lt;code&gt;key&lt;/code&gt;是一个背包问题，已知公钥&lt;code&gt;m&lt;/code&gt;，和的话目前不</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="wp" scheme="https://sch01ar.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>背包加密算法</title>
    <link href="https://sch01ar.github.io/2022/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/"/>
    <id>https://sch01ar.github.io/2022/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/</id>
    <published>2022-11-28T16:00:00.000Z</published>
    <updated>2022-12-01T09:50:05.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>在一次CTF比赛中遇到了，写了10个for嵌套硬爆出来了，复现的时候发现是背包加密。</p><p><img src="/img/bag.png" alt=""></p><h2 id="Merkle–Hellman-公钥加密算法"><a class="header-anchor" href="#Merkle–Hellman-公钥加密算法">¶</a>Merkle–Hellman 公钥加密算法</h2><p>整体加密流程<br>&lt;!–code￼0–&gt;<br>可以发现，加密十分容易，但解密十分困难，这也是非对称加密的特点。</p><h3 id="加密"><a class="header-anchor" href="#加密">¶</a>加密</h3><h4 id="生成私钥"><a class="header-anchor" href="#生成私钥">¶</a>生成私钥</h4><p>超递增序列，也就是a中每一位元素需要大于其之前所有元素的和。<br>&lt;!–code￼1–&gt;</p><h4 id="生成公钥"><a class="header-anchor" href="#生成公钥">¶</a>生成公钥</h4><p>模数m要求：<code>m &gt; sum(a)</code><br>乘数w要求：<code>gcd(w,m) == 1</code><br>&lt;!–code￼2–&gt;<br>b和m作为公钥。<br>加密：<code>S = numpy.dot(x,b)</code></p><h3 id="解密"><a class="header-anchor" href="#解密">¶</a>解密</h3><p>拿到公钥$M=(m_1,m_2,\ldots,m_n)$，构造如下矩阵<br>$$<br>\begin{bmatrix}<br>2 &amp; 0 &amp; \ldots &amp; 0 &amp; m_1 \<br>0 &amp; 2 &amp; \ldots &amp; 0 &amp; m_2 \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \<br>0 &amp; 0 &amp; \ldots &amp; 2 &amp; m_n \<br>1 &amp; 1 &amp; \ldots &amp; 1 &amp; S \<br>\end{bmatrix}<br>$$<br>这个矩阵的所有行向量的线性组合构成了一个格，接下来将通过明文的特点和格上的特殊解法来进行解密。</p><h4 id="LLL"><a class="header-anchor" href="#LLL">¶</a>LLL</h4><p>对于明文$X=(x_1,x_2,\ldots,x_n)$这一组数来说，构造一个向量<br>$$<br>a=\sum_{i=1}^nx_iv_i-v_{n+1}=(2x_1-1,2x_2-1,\ldots,2x_n-1,0)<br>$$<br>显然，a向量在格L上。因为X中的所有x只能取值0或1，因此a向量的长度很小，约为$\sqrt{n}$，对于很大的格基来说，a向量无疑是格L上的最小向量，因此我们利用LLL算法即可求出a向量。</p><h4 id="例题"><a class="header-anchor" href="#例题">¶</a>例题</h4><p>&lt;!–code￼3–&gt;<br>这里注意一下，第一行向量中是有+1与-1，需要进行取反，即-1代表1，1代表0。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;在一次CTF比赛中遇到了，写了10个for嵌套硬爆出来了，复现的时候发现是背包加密。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/bag.png&quot; al</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="非对称加密" scheme="https://sch01ar.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Hitcon 2022-㊙️BabySSS</title>
    <link href="https://sch01ar.github.io/2022/11/28/hitcon2022-BabySSS/"/>
    <id>https://sch01ar.github.io/2022/11/28/hitcon2022-BabySSS/</id>
    <published>2022-11-27T16:00:00.000Z</published>
    <updated>2022-12-01T09:37:56.735Z</updated>
    
    <content type="html"><![CDATA[<p>I implemented a toy Shamir’s Secret Sharing for fun. Can you help me check is there any issues with this?</p><h1>Shamir’s Secret Sharing密钥分享算法</h1><p>$$f(x)=a_0 + a_1x + a_2x^2 + …… + a_{k-1} x^{k-1} mod p<br>$$</p><h1>题目源码</h1><p>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>题目给了8组x，y的值，可通过CRT模x求出a_0 ，通过模x^2 可求出a_1 ，同理可求出所有系数，恢复出polyeval函数，从而得到正确的secret。</p><h1>EXP</h1><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;I implemented a toy Shamir’s Secret Sharing for fun. Can you help me check is there any issues with this?&lt;/p&gt;
&lt;h1&gt;Shamir’s Secret Sharing</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="wp" scheme="https://sch01ar.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>Gauss格基约简算法</title>
    <link href="https://sch01ar.github.io/2022/11/24/Gauss%E6%A0%BC%E5%9F%BA%E7%BA%A6%E7%AE%80%E7%AE%97%E6%B3%95/"/>
    <id>https://sch01ar.github.io/2022/11/24/Gauss%E6%A0%BC%E5%9F%BA%E7%BA%A6%E7%AE%80%E7%AE%97%E6%B3%95/</id>
    <published>2022-11-23T16:00:00.000Z</published>
    <updated>2022-12-07T09:39:00.075Z</updated>
    
    <content type="html"><![CDATA[<p>由Gauss提出的二维格基约化算法</p><h1>算法伪代码</h1><p>即对给定的两个基向量进行不断的相互约化，最终求得格上的最小向量</p><p>Loop</p><p>(a) If ||v2|| &lt; ||v1||, swap v1, v2</p><p>(b) Compute m = ⌊ v1∙v2 / v1∙v1 ⌉</p><p>© If m = 0, return v1, v2</p><p>(d) v2 = v2 - m*v1</p><p>Continue Loop</p><h1>代码实现</h1><p>&lt;!–code￼0–&gt;</p><h1>例题</h1><p>&lt;!–code￼1–&gt;</p><h2 id="思路"><a class="header-anchor" href="#思路">¶</a>思路</h2><p>给定公钥q、h，以及明文e</p><p>要求私钥f、g</p><p>他们之间有如下关系：</p><p>fh ≡ g mod q</p><p>即 kq + g =fh</p><p>g = fh -kq<br>根据这一特点即可构造格，也就是格密码中很经典的，遇到一个向量乘矩阵，即可进行构造</p><p>由于存在一组a、b，使得a（1，h）+ b（0，q）=（f，g）$a(1,h) + b(0,q) = (f,g)$</p><p>a = f，b = k</p><p>选取一组基底为（1，h）和（0，q），也就是上述高斯约简算法当中的v1与v2，求出v1与v2格上最小的向量，即为（f，g）</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼2–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由Gauss提出的二维格基约化算法&lt;/p&gt;
&lt;h1&gt;算法伪代码&lt;/h1&gt;
&lt;p&gt;即对给定的两个基向量进行不断的相互约化，最终求得格上的最小向量&lt;/p&gt;
&lt;p&gt;Loop&lt;/p&gt;
&lt;p&gt;(a) If ||v2|| &amp;lt; ||v1||, swap v1, v2&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="lattice" scheme="https://sch01ar.github.io/tags/lattice/"/>
    
  </entry>
  
  <entry>
    <title>二叉树建立与遍历</title>
    <link href="https://sch01ar.github.io/2022/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/"/>
    <id>https://sch01ar.github.io/2022/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/</id>
    <published>2022-11-09T16:00:00.000Z</published>
    <updated>2022-12-01T05:15:01.487Z</updated>
    
    <content type="html"><![CDATA[<p>网上很多算法通过直接将二叉树结点连接，从而构成二叉树，这里我构建了一个二叉树类，通过用户控制输入来建立二叉树。</p><p>有层序遍历，递归、非递归的前序遍历、中序遍历、后序遍历算法。</p><p>&lt;!–code￼0–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网上很多算法通过直接将二叉树结点连接，从而构成二叉树，这里我构建了一个二叉树类，通过用户控制输入来建立二叉树。&lt;/p&gt;
&lt;p&gt;有层序遍历，递归、非递归的前序遍历、中序遍历、后序遍历算法。&lt;/p&gt;
&lt;p&gt;&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://sch01ar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树" scheme="https://sch01ar.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>2022祥云杯wp-crypto</title>
    <link href="https://sch01ar.github.io/2022/10/30/2022-10-30-2022%E7%A5%A5%E4%BA%91%E6%9D%AFwp-crypto/"/>
    <id>https://sch01ar.github.io/2022/10/30/2022-10-30-2022%E7%A5%A5%E4%BA%91%E6%9D%AFwp-crypto/</id>
    <published>2022-10-29T16:00:00.000Z</published>
    <updated>2022-12-07T09:43:16.370Z</updated>
    
    <content type="html"><![CDATA[<h1>little little fermat</h1><h2 id="题目源码"><a class="header-anchor" href="#题目源码">¶</a>题目源码</h2><p>&lt;!–code￼0–&gt;</p><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>根据题目名字来看，此题和费马小定理的使用有关，题目中有一个<code> obfuscate</code>函数，进行了对q的生成，<code>q=p+A</code>，这里可以看一下A的范围，是在2<sup>[18,319]</sup>之间，因此p、q接近，尝试一下yafu分解。</p><p><img src="/img/20221030.jpg" alt=""><br>题目对m先进行了处理，再进行RSA加密，因此我们需要知道x。<code>assert 114514 ** x % p == 1</code>运用费马小定理，若114514与p互素，则x=p-1，即可求解m。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p><h1>fill</h1><h2 id="题目源码-v2"><a class="header-anchor" href="#题目源码-v2">¶</a>题目源码</h2><p>&lt;!–code￼2–&gt;</p><h2 id="题目分析-v2"><a class="header-anchor" href="#题目分析-v2">¶</a>题目分析</h2><p>随机产生32位的数，sha256()加密后作为flag，并将其2进制的每一位存到了<code>f_list</code>数组中。</p><p>又 创建了一个<code>r_list</code>32位数组，里面存着随机数，先暂时不管。</p><p>双 对<code>r_list</code>数组中的随机数做了加密，产生了<code>M</code>数组。</p><p>对<code>f_list</code>和<code>M</code>数组进行了<code>numpy.dot</code>运算，即向量乘法，得到和为S。</p><p>叒 创建了一个<code>s</code>数组，这个很明显，用LCG线性同余算法进行了加密。</p><p>最后将<code>M</code>数组与<code>s</code>数组相加。</p><p>这就是这道题整体的流程，每一步并不难，只是步骤多，略显复杂。</p><h2 id="EXP-v2"><a class="header-anchor" href="#EXP-v2">¶</a>EXP</h2><h3 id="0x01"><a class="header-anchor" href="#0x01">¶</a>0x01</h3><p>可以先进行一下LCG的求解，把s数组求解出来，从而求出M数组。</p><p>&lt;!–code￼3–&gt;</p><h3 id="0x02"><a class="header-anchor" href="#0x02">¶</a>0x02</h3><p>按理来说，感觉应该根据求出来的<code>M</code>数组进行逆运算，求出<code>r_list</code>数组，但是求出来<code>r_list</code>有什么用呢，所以直接尝试求<code>f_list</code>。因为<code>f_list</code>中不是0就是1，与<code>M</code>做向量乘法，即为<code>M</code>数组中若干元素的和。根据题目给定和S，先大概看一下需要<code>M</code>中多少个元素累加。发现在M前21位和 &lt; S，前22位和 &gt; S，所以猜想应该是M当中，除10个左右元素之外的和。</p><p>这里就遍历了一下，复杂度实在太高了，也没想着能出，结果还真算出来了o.O</p><p>&lt;!–code￼4–&gt;</p><p>也就说明，<code>f_list</code>中下标为这些的，对应值是0，其余为1，即可得到msg的2进制数，转为十进制后进行<code>sha256()</code>加密即可。</p><p>&lt;!–code￼5–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;little little fermat&lt;/h1&gt;
&lt;h2 id=&quot;题目源码&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目源码&quot;&gt;¶&lt;/a&gt;题目源码&lt;/h2&gt;
&lt;p&gt;&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a c</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="wp" scheme="https://sch01ar.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>2022NewStarCTF-flip_flop</title>
    <link href="https://sch01ar.github.io/2022/10/27/2022NewStarCTF-flip_flop/"/>
    <id>https://sch01ar.github.io/2022/10/27/2022NewStarCTF-flip_flop/</id>
    <published>2022-10-26T16:00:00.000Z</published>
    <updated>2022-12-07T09:41:52.644Z</updated>
    
    <content type="html"><![CDATA[<h1>flip-flop</h1><p>AES-CBC加密模式</p><h2 id="题目"><a class="header-anchor" href="#题目">¶</a>题目</h2><p>源码如下：<br>&lt;!–code￼0–&gt;</p><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>此题是通过注册得到的用户账户的密文，然后输入管理员账户对应的密文，才能得到flag。</p><p>对用户账户和管理员账户的加密解密均采用AES-CBC模式，但是本题仅有一组明文，iv仅作为偏移量，也就是本题中的user_key。</p><p>这里先来说一下我最一开始的思路，由于user_key每次是随机产生的，但是一次程序的运行当中是不变的。由于密文由两部分组成，前半部分为user_key.hex()，后半部分为code.hex()，所以只要构造出admin对应的code即可，那么就需要AES加密当中的key，所以就需要构造一个key来产生出admin对应的code。查询了很多资料发现都难以实现。于是……</p><p>那为什么不换一下思路？不能构造code，能不能构造iv？</p><p>先来看一下加密方式：</p><p>C = encrypt(M ^ iv)</p><p>M = decrypt©^iv</p><p>对应一下本题当中的NewStarCTFer和admin：<br><code>b'NewStarCTFer____' = decrypt(code) ^ iv1</code></p><p><code>b'AdminAdmin______' = decrypt(code) ^ iv2</code></p><p>因此可求出admin对应的iv2，随后拼接上普通用户的后半段code即可。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;flip-flop&lt;/h1&gt;
&lt;p&gt;AES-CBC加密模式&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目&quot;&gt;¶&lt;/a&gt;题目&lt;/h2&gt;
&lt;p&gt;源码如下：&lt;br&gt;
&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
&lt;h2 id</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="wp" scheme="https://sch01ar.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>BUU刷题日记20221026</title>
    <link href="https://sch01ar.github.io/2022/10/26/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221026/"/>
    <id>https://sch01ar.github.io/2022/10/26/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221026/</id>
    <published>2022-10-25T16:00:00.000Z</published>
    <updated>2022-12-07T09:39:19.641Z</updated>
    
    <content type="html"><![CDATA[<h1>RSA5</h1><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>给定e=65537</p><p>给了很多组n、c</p><p>由于e过大，所以不考虑使用CRT，由于m是同一个，因此遍历一下，求出两个n的最大公约数，即为p，后续就简单了。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;RSA5&lt;/h1&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目分析&quot;&gt;¶&lt;/a&gt;题目分析&lt;/h2&gt;
&lt;p&gt;给定e=65537&lt;/p&gt;
&lt;p&gt;给了很多组n、c&lt;/p&gt;
&lt;p&gt;由于e过大，所以不考虑使用CRT，由于m是同一</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="diary" scheme="https://sch01ar.github.io/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>2022 DASCTF 10月挑战赛wp</title>
    <link href="https://sch01ar.github.io/2022/10/23/2022DASCTF10%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwp/"/>
    <id>https://sch01ar.github.io/2022/10/23/2022DASCTF10%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwp/</id>
    <published>2022-10-22T16:00:00.000Z</published>
    <updated>2022-12-07T09:42:51.960Z</updated>
    
    <content type="html"><![CDATA[<h1>RSA</h1><h2 id="题目如下"><a class="header-anchor" href="#题目如下">¶</a>题目如下</h2><p>&lt;!–code￼0–&gt;</p><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>该题的加密顺序是：</p><p>1、加密flag，分为两部分m1、m2</p><p>2、加密m1</p><p>3、加密m2</p><p>同理我们解密的顺序应该也是</p><p>1、解出m1、m2</p><p>2、解出flag</p><h3 id="求m2"><a class="header-anchor" href="#求m2">¶</a>求m2</h3><p>先观察一下encrypt4函数</p><p>虽然说e_2=3，按理来说使用低加密指数攻击，但并不可行。</p><p>又因为m = m % k</p><p>可通过这点和<code>c_3 = pow(m, e_2, n_3)</code>做遍历求出m</p><p>最后发现m即为m2，m2 &lt; k</p><h3 id="求m1"><a class="header-anchor" href="#求m1">¶</a>求m1</h3><p>发现m1加密方式采用RSA，但是n_1未知</p><p>n_1又通过一次RSA加密，已知n_1对应的密文</p><p>利用低加密指数攻击解出n1</p><p>发现n1可分解为3个素数乘积</p><p>故phi可求，即求出m1</p><h3 id="求flag"><a class="header-anchor" href="#求flag">¶</a>求flag</h3><p>观察encryt1</p><p>m1是flag右移200位之后转为字节</p><p>m2是flag的20位之后转成字节</p><p>所以来说m2是没什么问题，主要找到flag的前20位，再把m2拼到后面即可。</p><p>由于m1是flag右移200位，因此flag的低位缺失，但高位还在，由于不知道flag总长度，抱着试一试的心态，猜测一下它的高位前20位没有缺失</p><p>我们将m1和m2转为字节发现</p><p>m1:b’0x666c61677b3230366538353964’</p><p>m2:b’383539643865383534633466363030636231323735376262663966357d’</p><p>发现m1和m2有重叠部分，即38353开始</p><p>可以证实m1前20位确实没有缺失</p><p>因此取m1前20位，加m2，即可解出flag</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;RSA&lt;/h1&gt;
&lt;h2 id=&quot;题目如下&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#题目如下&quot;&gt;¶&lt;/a&gt;题目如下&lt;/h2&gt;
&lt;p&gt;&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
&lt;h2 id=&quot;题目分析&quot;&gt;&lt;a class=&quot;header-anch</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="wp" scheme="https://sch01ar.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>BUU刷题日记20221022</title>
    <link href="https://sch01ar.github.io/2022/10/22/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221022/"/>
    <id>https://sch01ar.github.io/2022/10/22/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221022/</id>
    <published>2022-10-21T16:00:00.000Z</published>
    <updated>2022-12-07T09:40:10.592Z</updated>
    
    <content type="html"><![CDATA[<h1>RSA4</h1><p>题目只给了三组n、c，采用中国剩余定理，具体推导如下</p><h2 id="推导过程"><a class="header-anchor" href="#推导过程">¶</a>推导过程</h2><p>m<sup>e</sup> ≡ c1 mod n1<br>m<sup>e</sup> ≡ c2 mod n2<br>m<sup>e</sup> ≡ c3 mod n3</p><h3 id="中国剩余定理（CRT）"><a class="header-anchor" href="#中国剩余定理（CRT）">¶</a>中国剩余定理（CRT）</h3><p>中国剩余定理的内容是：</p><p>针对上述方程组，若n1、n2、n3互质，对于任意的c1、c2、c3，方程组都有解，使用条件是m^e &lt; n1、n2、n3。通解形式如下：</p><p>令N = n1 * n2 * n3，N1 = N/n1，N2、N3同理</p><p>令t1 = N1<sup>(-1)</sup>，即其对应的模n1运算的逆元，t2，t3同理，可用<code>t1=gmpy2.invert(N1,n1)</code>表示。</p><p>有了Ni和ti的定义，我们就可以给出通解形式：</p><p>x = c1 * N1 * t1 ……</p><p>有了通解公式我们就可以求出m^e，对e进行一下遍历即可，m开方成功即可。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;RSA4&lt;/h1&gt;
&lt;p&gt;题目只给了三组n、c，采用中国剩余定理，具体推导如下&lt;/p&gt;
&lt;h2 id=&quot;推导过程&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#推导过程&quot;&gt;¶&lt;/a&gt;推导过程&lt;/h2&gt;
&lt;p&gt;m&lt;sup&gt;e&lt;/sup&gt; ≡ c1 mod</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="diary" scheme="https://sch01ar.github.io/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>BUU刷题日记20221021</title>
    <link href="https://sch01ar.github.io/2022/10/21/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221021/"/>
    <id>https://sch01ar.github.io/2022/10/21/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221021/</id>
    <published>2022-10-20T16:00:00.000Z</published>
    <updated>2022-12-07T09:40:56.311Z</updated>
    
    <content type="html"><![CDATA[<h1>RSA2</h1><p>题目给定n、e、dp、c</p><p>非预期解：直接分解n</p><p>下面考虑n不能分解的情况</p><h2 id="推导过程"><a class="header-anchor" href="#推导过程">¶</a>推导过程</h2><p>dp ≡ d mod (p-1)</p><p>ed ≡ 1 mod (p-1) * (q-1)</p><p>ed = 1 + k2(p-1)(q-1)</p><p>对1式两端同乘e，得</p><p>e * dp ≡ ed mod (p-1)</p><p>e * dp = k1(p-1) + ed</p><p>代入ed得</p><p>e * dp = k1(p-1) + 1 + k2(p-1)(q-1)</p><p>由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余p-1，即可消掉n</p><p>e * dp ≡ 1 mod (p-1)</p><p>e * dp =k(p-1) + 1</p><p>得到这个式子后，其实真正意义上的未知数只有我们要求的p，但是还存在一个k。</p><p>针对k，我们判断一下他的范围，看看能否采用爆破的方式。</p><p>k = (e * dp - 1)/(p-1)</p><p>因为dp &lt; p-1</p><p>所以k &lt; e</p><p>通过遍历k然后找到(e * dp - 1)可以整除k的情况即可。</p><p>(跑了一下发现限制条件还不够)</p><p>因此再加一个n能否整除p即可。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p><h1>RSA3</h1><p>给定n、e1、c1、e2、c2。</p><p>m ≡ c1^e1 mod n</p><p>m ≡ c2^e2 mod n</p><p>这里采用共模攻击，详细原理如下：</p><p>扩展欧几里得算法：给定两个整数a、b，必定存在x、y，使得gcd(a,b)=ax+by</p><p>对应到本题当中，由于e1、e2互为素数，因此gcd(e1,e2)=1，从而存在s1、s2使得:</p><p>s1 * e1 + s2 * e2 = 1</p><h2 id="推导过程-v2"><a class="header-anchor" href="#推导过程-v2">¶</a>推导过程</h2><p>m = m % n<br>m = m^(s1 * e1 + s2 * e2)^ % n<br>m = m^(e1 * s1)^ * m^(e2 * s2)^ % n<br>m = (m^(e1 * s1)^ % n) * (m^(e2 * s2)^ % n) % n<br>m = (c1<sup>s1</sup> % n) * (c2<sup>s2</sup> % n) % n</p><h2 id="EXP-v2"><a class="header-anchor" href="#EXP-v2">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;RSA2&lt;/h1&gt;
&lt;p&gt;题目给定n、e、dp、c&lt;/p&gt;
&lt;p&gt;非预期解：直接分解n&lt;/p&gt;
&lt;p&gt;下面考虑n不能分解的情况&lt;/p&gt;
&lt;h2 id=&quot;推导过程&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#推导过程&quot;&gt;¶&lt;/a&gt;推导过程&lt;/h2&gt;
&lt;</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="diary" scheme="https://sch01ar.github.io/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>BUU刷题日记20221020</title>
    <link href="https://sch01ar.github.io/2022/10/20/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221020/"/>
    <id>https://sch01ar.github.io/2022/10/20/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221020/</id>
    <published>2022-10-19T16:00:00.000Z</published>
    <updated>2022-12-06T07:25:59.850Z</updated>
    
    <content type="html"><![CDATA[<h1>RSA1</h1><p>给定dp、dq类型</p><p>dp ≡ d mod (p-1)</p><p>dq ≡ d mod (q-1)</p><p>m ≡ c<sup>d</sup> mod n</p><p>m = c<sup>d</sup> + k * n</p><p>m = c<sup>d</sup> +k * p * q</p><p>对上式两端同时对p、q分别取余，得：（中国剩余定理）</p><p>m1 ≡ c<sup>d</sup> mod p</p><p>m2 ≡ c<sup>d</sup> mod q</p><p>同理，可得到<br>c<sup>d</sup> = m1 +k * p</p><p>代入到 m2 ≡ c<sup>d</sup> mod q 中：</p><p>m2 ≡ (m1 + k * p)mod q ，两端减去m1得</p><p>m2 - m1 ≡ k * p mod q ，两端乘p的逆元得</p><p>(m2 - m1)p<sup>-1</sup> ≡ k mod q</p><p>将k代入到 c<sup>d</sup> = m1 +k * p 中得：</p><p>c<sup>d</sup> = m1 + ((m2 - m1)p<sup>-1</sup> mod q) * p</p><p>m=c<sup>d</sup> mod n</p><p>得到</p><p>m ≡ (((m2 - m1) * p<sup>-1</sup> mod q) * p + m1) mod n</p><p>接下来就是求解m1，m2</p><p>m1 ≡ c<sup>dp+k(p-1)</sup> mod p</p><p>m2 ≡ c<sup>dq+k(q-1)</sup> mod q</p><p>根据费马小定理</p><p>若p是素数，则a<sup>(p-1)</sup> ≡ 1 mod p</p><p>因此 m1 ≡ c<sup>dp</sup> mod p，m2 ≡ c<sup>dq</sup> mod q</p><p>最终可求得m</p><h2 id="exp"><a class="header-anchor" href="#exp">¶</a>exp</h2><p>&lt;!–code￼0–&gt;</p><h1>RSAROLL</h1><p>&lt;!–code￼1–&gt;<br>给了一个data.txt文件，打开盲猜一下第一行是n，e，后面是c<br>&lt;!–code￼2–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;RSA1&lt;/h1&gt;
&lt;p&gt;给定dp、dq类型&lt;/p&gt;
&lt;p&gt;dp ≡ d mod (p-1)&lt;/p&gt;
&lt;p&gt;dq ≡ d mod (q-1)&lt;/p&gt;
&lt;p&gt;m ≡ c&lt;sup&gt;d&lt;/sup&gt; mod n&lt;/p&gt;
&lt;p&gt;m = c&lt;sup&gt;d&lt;/sup&gt; + k * n&lt;/</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="diary" scheme="https://sch01ar.github.io/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>2021ByteCTF-easyxor</title>
    <link href="https://sch01ar.github.io/2022/10/16/2021ByteCTF-easyxor/"/>
    <id>https://sch01ar.github.io/2022/10/16/2021ByteCTF-easyxor/</id>
    <published>2022-10-15T16:00:00.000Z</published>
    <updated>2022-12-07T09:34:59.756Z</updated>
    
    <content type="html"><![CDATA[<h1>题目源码如下</h1><p>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>将flag分为两段，前半段采用OFB加密，后半段采用CBC加密</p><h2 id="OFB解密"><a class="header-anchor" href="#OFB解密">¶</a>OFB解密</h2><p>将前半段flag又进行切分，将其8位分为一组，存到group数组中。<br>&lt;!–code￼1–&gt;<br>针对一个随机生成的64位的last，与keys进行convert加密，再与group中的数进行异或。<br>keys是四个-32～32的数，可爆破。<br>对于OFB解密十分简单，因为我们已知第一组明文，恰好是8位的’ByteCTF{'，由于分组密码的性质，所以后面的也就迎刃而解，通过group[ 0]^cipher[ 0] 即可得到cur_c，从而求得下一次的cur_c，以此类推。</p><h3 id="expOFB"><a class="header-anchor" href="#expOFB">¶</a>expOFB</h3><p>&lt;!–code￼2–&gt;</p><h2 id="CBC解密"><a class="header-anchor" href="#CBC解密">¶</a>CBC解密</h2><p>针对后半部分，我们需要逆向解出convert函数，因此就是对shift函数中的加密运算进行解密。<br>之前上网搜的wp都一笔带过，没解释unshift逆函数怎么写的。“难道有什么定理？？”<br>这里简单写一下我的理解。</p><h3 id="分析shift"><a class="header-anchor" href="#分析shift">¶</a>分析shift</h3><p>&lt;!–code￼3–&gt;</p><h4 id="推理过程"><a class="header-anchor" href="#推理过程">¶</a>推理过程</h4><p>这里我们举例k&gt;0时的情况。（k&lt;0同理）</p><p>m和c都是64位,k是-32～32的10进制数。</p><p>1、m &lt;&lt; k相当于在m后补k位0，得到的新数我们称为a，a=m &lt;&lt; k。</p><p>2、令b = a &amp; c，由于a是64+k位，c是64位，所以b是64位，并且b的后k位都是0。</p><p>3、令x = m ^ b，x则是shift加密之后的值，x也是64位，并且x的后k位是与m的后k位相同的，与0异或得本身。</p><p>我们走完了一遍shift加密，得到的结论是，密文的位数同样是64，并且密文的后k位与明文相同。</p><h3 id="分析unshift"><a class="header-anchor" href="#分析unshift">¶</a>分析unshift</h3><p>&lt;!–code￼4–&gt;</p><h4 id="推理过程-v2"><a class="header-anchor" href="#推理过程-v2">¶</a>推理过程</h4><p>同样我们举例k&gt;0的情况。</p><p>之前我们得到的密文x，相当于tmp。</p><p>1、a’=tmp &lt;&lt; k，tmp后k位为0，tmp后2k～k位等于m的后k位。</p><p>2、b’=a’ &amp; c，b’后k位为0，后2k～k位为m&amp;c。</p><p>3、y=x ^ b’，y的后k位，等于x的后k位，也就是m的后k位。</p><p>4、y的后2k～k位，在shift加密当中，a &amp; c的后2k～k位等于m的后k位&amp;c，记作m1 &amp; c。</p><p>shift中的x，也就是m ^ b，m ^(m1 &amp; c)，在unshift最后的一步操作中，y= m ^(m1 &amp; c) ^ b’。</p><p>这时我们只考虑y的后2k～k位，y=m ^(m1 &amp; c)^(m1 &amp; c) = m</p><p>所以这时y的2k～k位也等于m了。</p><h4 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h4><p>因此，我们发现每经过unshift一次，就有k位被还原，何时才能被完全还原？即循环bits//k次。</p><p>此推理正确，可以在unshift函数运行时输出每次的tmp观察即可。</p><p>ps：自我感觉这种位运算应该是属于一种性质或者定理，网上大佬们都是说“简单写个逆”。。。</p><h3 id="expCBC"><a class="header-anchor" href="#expCBC">¶</a>expCBC</h3><p>&lt;!–code￼5–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目源码如下&lt;/h1&gt;
&lt;p&gt;&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;将flag分为两段，前半段采用OFB加密，后半段采用CBC加密&lt;/p&gt;
&lt;h2 id=&quot;OFB解密&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="wp" scheme="https://sch01ar.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>2022BUUCTF新生赛-RSA</title>
    <link href="https://sch01ar.github.io/2022/10/16/2022BUUCTF%E6%96%B0%E7%94%9F%E8%B5%9B-RSA/"/>
    <id>https://sch01ar.github.io/2022/10/16/2022BUUCTF%E6%96%B0%E7%94%9F%E8%B5%9B-RSA/</id>
    <published>2022-10-15T16:00:00.000Z</published>
    <updated>2022-12-01T09:37:13.129Z</updated>
    
    <content type="html"><![CDATA[<h1>题目源码</h1><p>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>发现n和phin都不常规，没入手点，发现hint，hint=pow(d,e,n)，有趣，用d做明文，尝试推理一下：<br>d = pow(hint,d,n)<br>d = pow((d ** e % n),d,n)<br>d = (d ** e % n) ** d % n<br>d = d ** (e*d) % n<br>d = pow(d ** e,d,n)<br>把d ** e再次看做密文，可得<br>d ** e = pow(d,e,n)<br>因为hint = pow(d,e,n)<br>可得hint = d ** e<br>d ** e * e ** e-&gt;(ed) ** e-&gt;(ed) ** e == 1 mod phin<br>因此根据e和hint即可求得phin<br>从而得到phin和n的最大公约数p<br>脚本如下<br>&lt;!–code￼1–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目源码&lt;/h1&gt;
&lt;p&gt;&amp;lt;!–code￼0–&amp;gt;&lt;/p&gt;
&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;发现n和phin都不常规，没入手点，发现hint，hint=pow(d,e,n)，有趣，用d做明文，尝试推理一下：&lt;br&gt;
d = pow(hint,d,n)&lt;br&gt;
</summary>
      
    
    
    
    <category term="CTF" scheme="https://sch01ar.github.io/categories/CTF/"/>
    
    
    <category term="wp" scheme="https://sch01ar.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>梦开始的地方</title>
    <link href="https://sch01ar.github.io/2022/10/15/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
    <id>https://sch01ar.github.io/2022/10/15/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/</id>
    <published>2022-10-15T07:59:58.000Z</published>
    <updated>2022-12-01T05:15:04.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mac下利用Hexo和github-pages搭建个人博客"><a class="header-anchor" href="#Mac下利用Hexo和github-pages搭建个人博客">¶</a>Mac下利用Hexo和github pages搭建个人博客</h2><h3 id="环境配置"><a class="header-anchor" href="#环境配置">¶</a>环境配置</h3><h4 id="1-Node-js安装"><a class="header-anchor" href="#1-Node-js安装">¶</a>1.Node.js安装</h4><p>下载地址：<a href="https://nodejs.org/en/">Node.js</a></p><h4 id="2-淘宝镜像安装"><a class="header-anchor" href="#2-淘宝镜像安装">¶</a>2.淘宝镜像安装</h4><p>&lt;!–code￼0–&gt;</p><h4 id="3-安装Hexo"><a class="header-anchor" href="#3-安装Hexo">¶</a>3.安装Hexo</h4><p>&lt;!–code￼1–&gt;</p><h3 id="初始化Hexo-Blog"><a class="header-anchor" href="#初始化Hexo-Blog">¶</a>初始化Hexo Blog</h3><h4 id="1-初始化Hexo"><a class="header-anchor" href="#1-初始化Hexo">¶</a>1.初始化Hexo</h4><p>新建一个文件夹并进入，例如blog<br>&lt;!–code￼2–&gt;</p><h4 id="2-本地启动Hexo"><a class="header-anchor" href="#2-本地启动Hexo">¶</a>2.本地启动Hexo</h4><p>&lt;!–code￼3–&gt;<br>浏览器打开网站，即可看到本地博客</p><h3 id="创建博客文章"><a class="header-anchor" href="#创建博客文章">¶</a>创建博客文章</h3><h4 id="1-创建文章"><a class="header-anchor" href="#1-创建文章">¶</a>1.创建文章</h4><p>&lt;!–code￼4–&gt;<br>在blog文件夹中的_post里即可看到新建的md文件</p><h4 id="2-清理缓存项目"><a class="header-anchor" href="#2-清理缓存项目">¶</a>2.清理缓存项目</h4><p>在新建博客或修改博客时，需要进行该操作<br>&lt;!–code￼5–&gt;</p><h4 id="3-重新生成博客"><a class="header-anchor" href="#3-重新生成博客">¶</a>3.重新生成博客</h4><p>&lt;!–code￼6–&gt;</p><h4 id="4-启动博客"><a class="header-anchor" href="#4-启动博客">¶</a>4.启动博客</h4><p>&lt;!–code￼7–&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mac下利用Hexo和github-pages搭建个人博客&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Mac下利用Hexo和github-pages搭建个人博客&quot;&gt;¶&lt;/a&gt;Mac下利用Hexo和github pages搭建个人博客&lt;/h2</summary>
      
    
    
    
    <category term="建站" scheme="https://sch01ar.github.io/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
    <category term="博客搭建" scheme="https://sch01ar.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://sch01ar.github.io/2022/10/15/hello-world/"/>
    <id>https://sch01ar.github.io/2022/10/15/hello-world/</id>
    <published>2022-10-15T07:57:23.442Z</published>
    <updated>2022-12-01T05:15:29.274Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3><p>&lt;!–code￼0–&gt;</p><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3><p>&lt;!–code￼1–&gt;</p><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3><p>&lt;!–code￼2–&gt;</p><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><p>&lt;!–code￼3–&gt;</p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
