{"meta":{"title":"Y's blog","subtitle":"","description":"","author":"Roo1e","url":"https://sch01ar.github.io","root":"/"},"pages":[{"title":"书单","date":"2022-10-16T02:30:27.247Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"books/index.html","permalink":"https://sch01ar.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-12-10T07:36:44.999Z","updated":"2022-12-02T03:15:20.960Z","comments":false,"path":"about/index.html","permalink":"https://sch01ar.github.io/about/index.html","excerpt":"","text":"🐭🐭"},{"title":"分类","date":"2022-10-16T02:33:21.117Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"categories/index.html","permalink":"https://sch01ar.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-10-17T01:02:57.129Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"links/index.html","permalink":"https://sch01ar.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-10-16T03:25:28.438Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"repository/index.html","permalink":"https://sch01ar.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-10-16T02:41:49.050Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"tags/index.html","permalink":"https://sch01ar.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Coppersmith相关攻击","slug":"Coppersmith攻击","date":"2023-03-07T02:05:45.000Z","updated":"2023-03-13T02:14:55.065Z","comments":true,"path":"2023/03/07/Coppersmith攻击/","link":"","permalink":"https://sch01ar.github.io/2023/03/07/Coppersmith%E6%94%BB%E5%87%BB/","excerpt":"","text":"原理 Coppersmith 定理是在一个 e 阶模 n 的多项式\\(f(x)\\)中，若有根小于\\(n^{\\frac{1}{e}}\\)，则可以用 O(log n)的算法求出根。 直接求解\\(f(x)\\)的根可能比较困难，在此利用LLL算法求得多项式\\(g(x)\\)，求得的多项式与\\(f(x)\\)具有相同的根\\(x_0\\)，\\(g(x)\\)具有更小的系数，且定义域为整数域。 本质思想就是把有限域上的方程转化到整数域。 理论基础 \\[f(x,y) = \\sum_{i=0}^{d}\\sum_{j=0}^{e} a_{i,j}x^iy^j\\] Howgrave-Graham 需要构造一个系数更小的多项式，\\(||g(x)||\\)代表范数，即最大的系数。构造方法如下 LLL 算法 格基约化算法，通过对构造出的格，从而约化产生符合约束的多项式。 p 高位攻击 1234567891011121314151617import gmpy2from Crypto.Util.number import *from flag import flagm=bytes_to_long(flag)n = 25348605574630284342864323710011622959543974652863854537355760576386763162531478272446867731299572532294812374775121121761898206639041068156270466457595336452690367719842145233764550634280981441631262047763246059814963741143303914063537003244814908763379320576260885158458898112416692583017869283284022878603506583499699525249773663841642694427307104140944360804367072787670581252816486834658346431010523135392357008103555699542414687172408709153334263858639251735462278292703380745537045458408951791720967957274781161667526873251066303708008043058246747534357368350540174588670636827470901518225473676343782182718627e = 65537high_p = p&gt;&gt;462c=pow(m,e,n)print(high_p)print(c)#c = 2838585968727601235811102000208810377763570403442263788723014651093563843294336508586280687833863346617299165812054489406097873361940320732653656106836742334351707641172590772691775696065643337783752853707871271348294775407491819788305857447836923575366699374649494685209530440846553788854498950165868767060103944397665695513568787251626526985821169261973233666633938348865538364532419767347878581021598781082997830762785442482278387265054844200419966175619215512361010529309496176507520460375493466772893213031156341155066854128910227539653777680017545678773463877481232404008355330164324877400343396249494527269803#high_p = 14719840533805965441436310401180369285271789871612468412671201109363519708733266615333097147637913934699335461421648585440665652199846830713164628016025539243988107497052 dp 高位攻击 给定\\(e,n,c,dp_0,k,\\;dp_0=dp&gt;&gt;k\\) \\[ edp\\equiv ed\\equiv 1\\;mod\\;(p-1)\\\\ edp=k(p-1)+1\\\\ edp+k-1=kp\\\\ edp+k-1 \\equiv 0\\; mod\\; p\\\\ \\because dp&lt; p-1\\\\ \\because edp=k(p-1)+1\\\\ \\therefore e&gt;k\\\\ \\therefore e(dp_0 &lt;&lt; k+x)+k-1 \\equiv 0\\;mod\\;p \\] 123456789101112131415161718192021222324from Crypto.Util.number import *import gmpy2p = getStrongPrime(512)q = getStrongPrime(512)n = p * qphi = (p - 1) * (q - 1)e = 7621d = gmpy2.invert(e, phi)flag = b&quot;flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;c = pow(bytes_to_long(flag), e, n)dp = d % (p - 1)print(dp &gt;&gt; 200)print(c, e, n)&#x27;&#x27;&#x27;c = 46735962204857190520476434898881001530665718155698898882603422023484998388668858692912250418134186095459060506275961050676051693220280588047233628259880712415593039977585805890920089318643002597837000049626154900908543384761210358835843974072960080857150727010985827690190496793207012355214605393036388807616e = 7621n = 140376049134934822153964243403031201922239588054133319056483413311963385321279682186354948441840374124640187894619689719746347334298621083485494086361152915457458004998419817456902929318697902819798254427945343361548635794308362823239150919240307072688623000747781103375481834571274423004856276841225675241863&#x27;&#x27;&#x27; EXP 12345678910111213141516171819202122232425262728from sage.all import *n = 140376049134934822153964243403031201922239588054133319056483413311963385321279682186354948441840374124640187894619689719746347334298621083485494086361152915457458004998419817456902929318697902819798254427945343361548635794308362823239150919240307072688623000747781103375481834571274423004856276841225675241863e = 7621c = 46735962204857190520476434898881001530665718155698898882603422023484998388668858692912250418134186095459060506275961050676051693220280588047233628259880712415593039977585805890920089318643002597837000049626154900908543384761210358835843974072960080857150727010985827690190496793207012355214605393036388807616s = 1153696846823715458342658568392537778171840014923745253759529432977932183322553944430236879985def coppersmith(bits, k): F.&lt;x&gt; = PolynomialRing(Zmod(n)) invE = inverse_mod(e, n) f = (s &lt;&lt; bits) + x + (k - 1) * invE x0 = f.small_roots(X=2 ** bits, beta=0.44, epsilon=1/32) return x0for k in range(1, e): bits = 200 x0 = coppersmith(bits,k) if len(x0) != 0: x = Integer(x0[0]) dp = x + (s &lt;&lt; bits) p = (e*dp - 1) // k+1 if p != -1: q = n // p assert n == p * q phi = (p-1)*(q-1) d = inverse_mod(e,phi) m=pow(c,d,n) 多元 coppersmith 原理学习 论文学习 1、 论文学习 2 脚本来源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import itertoolsdef small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() #取得模数 f /= f.coefficients().pop(0) #最高次项系数化为0，coefficients是多项式的降次幂排列系数 f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i #收集基多项式 for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) print(G) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return [] 具体参数说明，例如 12PR.&lt;r,s,t&gt; = PolynomialRing(Zmod(prime))f = r*(s^2+2*s)-t","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"DLP中常用算法","slug":"DLP中常用算法","date":"2023-02-24T10:05:45.000Z","updated":"2023-03-04T06:03:05.157Z","comments":true,"path":"2023/02/24/DLP中常用算法/","link":"","permalink":"https://sch01ar.github.io/2023/02/24/DLP%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","excerpt":"","text":"Pohlig-Hellman 算法（光滑阶） 给定 a,b,p，p 是素数，求 x，\\(a^x \\equiv b (mod\\;p)\\) 在模 p 下，设该群的生成元为 g，则有 \\[ a \\equiv g^{a1} (mod\\;p) \\newline b \\equiv g^{b1} (mod\\;p) \\] 联立条件有 \\[ g^{a1x} \\equiv g^{b1} (mod\\;p) \\] 由欧拉定理得\\(\\phi(p)\\;=\\;p-1\\)，则有\\(a1x\\;=b1\\;(mod\\;(p-1))\\) 1.将 p-1 分解，即 \\(p-1=p_1^{k_1}p_2^{k_2}\\cdots p_m^{k_m}\\) 2.将 x 表示成\\(p_i\\) 进制, 列出方程 \\[x\\;=p_i^0a_0 + p_i^1a_1+...+p_i^{k_i-1}a*{k_i-1}\\] 3.令 r=1，求\\((a^x)^{\\frac{p-1}{p_i^r}}\\; \\equiv b^{\\frac{p-1}{p_i^r}}(mod\\; p)\\) 4.将 2 中的公式代入到 3，展开得到 \\[a^{a0*\\frac{p-1}{p_i}}* a^{(p-1)a1} * a^{(p-1)p_ia_2}...a^{(p-1)p_i^{k_i-2}a_{k_i-1}} \\equiv b^{\\frac{p-1}{p_i}}(mod\\;p)\\] 5.从第二项开始，后面每项都是 1，欧拉定理:\\(a^{(p-1)} \\equiv 1(mod\\;p)\\)，化简得到的式子为 \\[\\newline a^{a0*\\frac{p-1}{p_i}} \\equiv b^{\\frac{p-1}{p_i}}(mod \\;p)\\newline\\] 因为该方程只有 a0 未知，所以可在[0,pi-1]范围内爆破出 a0 6.再令 r = 2,3,4...ki，重复步骤 3，即可求出所有的\\(a_2,a_3....a_{k_i-1}\\)，从而得到 m 个关于 x 的方程，最后使用 CRT 进行求解即可。 总结:将 p-1 的 m 个质因子，分别求出其方程内的所有系数 a，从而构造了 m 个关于 x 的方程，最终利用 CRT 求解。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"近期","slug":"近期","date":"2023-02-20T06:05:45.000Z","updated":"2023-03-04T06:00:15.740Z","comments":true,"path":"2023/02/20/近期/","link":"","permalink":"https://sch01ar.github.io/2023/02/20/%E8%BF%91%E6%9C%9F/","excerpt":"","text":"ECC 常用方程（维尔斯特拉斯标准形式） \\(y^2\\;=x^3+ax+b\\)，判别式\\(\\Delta=-16(4a^3+27b^2)\\;mod\\;p=0\\) sage 环境 进行简单运算 1234567a = 497b = 1768p = 9739E = EllipticCurve(GF(p), [a, b])Q = E(1539, 4742)R = E(4403,5202)P = E(2339, 2213) ECDLP 给定椭圆曲线 E，已知 P、Q 以及\\(Q=kP\\)，求 k。 1234E = EllipticCurve(GF(p), [a, b])Q = E(x1,y1)P = E(x2,y2)k=P.discrete_log(Q) crypto-sign-in-1(VNCTF2023) 一道 ECDLP 题目，当时想到使用Pohlig-Hellman算法，但是一直没能找到合适的 A、B 来确定 G 的阶 n，赛后看大佬 wp，果然是用 pwntools 远程多试几组 y1、y2，找到光滑的阶，从而解密成功。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123from sympy.ntheory.residue_ntheory import nthroot_modfrom Crypto.Util.number import *from Crypto.Cipher import AESfrom random import randrange,choicefrom hashlib import *from secret import flagimport socketserverimport osimport signalimport stringtable = string.ascii_letters+string.digitsnbit = 128def pad(m,lenth): return m + bytes([i for i in range(lenth-int(len(m)%lenth))])class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b&#x27;&#x27; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) &lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b&#x27;\\n&#x27; self.request.sendall(msg) except: pass def recv(self, prompt=b&#x27;&#x27;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (&#x27;&#x27;.join([choice(table)for _ in range(20)])).encode() sha = sha256(proof).hexdigest().encode() self.send(b&quot;[+] sha256(XXXX+&quot; + proof[4:] + b&quot;) == &quot; + sha ) XXXX = self.recv(prompt = b&#x27;[+] Plz Tell Me XXXX :&#x27;) if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def handle(self): proof = self.proof_of_work() if not proof: self.request.close() while 1: qa = randrange(0,2**31) * 2 qb = getPrime(nbit - 32) if isPrime(qa * qb + 1): q = qa * qb + 1 break for _ in range(len(b&#x27;vnctf2023&#x27;) - 8): self.send(b&quot;Send 2 `y&#x27; elements to me: &quot;) ans = self.recv() try: y1, y2 = [int(_) % q for _ in ans.split(b&#x27;,&#x27;)] except: self.send(b&quot;Your parameters are not valid! Bye!!&quot;) break AA = (y1**2 - y2**2 - 2022**3 + 2023**3) * inverse(-1, q) % q BB = (y1**2 - 2022**3 - AA * 2022) % q def add(P,Q): if P[0] != Q[0] and P[1] != Q[1]: t = ((Q[1]-P[1]) * inverse(Q[0]-P[0],q)) %q else: t = ((3*P[0]*P[0]+AA)*inverse(2*P[1],q))%q x3 = t*t - P[0] - Q[0] y3 = t*(P[0] - x3) - P[1] return (x3%q, y3%q) def mul(t, A, B=0): if not t: return B return mul(t//2, add(A,A), B if not t&amp;1 else add(B,A) if B else A) while 1: Gx = randrange(0,q - 1) try: Gy = int(nthroot_mod((Gx**3 + AA * Gx + BB) % q,2,q)) assert (pow(Gy,2,q) == (Gx**3 + AA * Gx + BB) % q) break except: continue G = (Gx,Gy) m = randrange(0,q-1) C = mul(m,G) aes = AES.new(m.to_bytes(16, &#x27;big&#x27;), AES.MODE_CBC, bytes(16)) enc_flag = aes.encrypt(pad(flag,16)) self.send(b&#x27;The parameters and encrypted flag are:&#x27;) self.send(b&#x27;q = &#x27; + str(q).encode()) self.send(b&#x27;G = (&#x27;+ str(Gx).encode() + b&#x27;,&#x27; + str(Gy).encode() + b&#x27;)&#x27;) self.send(b&#x27;m * G = (&#x27;+ str(C[0]).encode() + b&#x27;,&#x27; + str(C[1]).encode() + b&#x27;)&#x27;) self.send(b&#x27;encrypt flag = &#x27; + enc_flag.hex().encode()) self.request.close()class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): passif __name__ == &quot;__main__&quot;: HOST, PORT = &#x27;0.0.0.0&#x27;, 10001 print(&quot;HOST:POST &quot; + HOST+&quot;:&quot; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#sagefrom pwn import *from itertools import productimport stringfrom hashlib import sha256from random import getrandbitsfrom ast import literal_evalfrom Crypto.Util.number import *from Crypto.Cipher import AEStable = string.ascii_letters+string.digitsdef set_connect_proof(): io=remote(&#x27;node4.buuoj.cn&#x27;,&#x27;25385&#x27;) io.recvuntil(b&quot;sha256(XXXX+&quot;) alphabet = string.ascii_letters + string.digits lattar_part=io.recv(16).decode(&#x27;utf8&#x27;) io.recvuntil(b&#x27;== &#x27;) h=io.recvline().strip().decode(&#x27;utf8&#x27;) # print(h) io.recvuntil(b&#x27;[+] Plz Tell Me XXXX :&#x27;) bruteforce=[ &#x27;&#x27;.join(prefix)+lattar_part for prefix in product(alphabet,repeat=4)] for proof in bruteforce: if sha256(proof.encode()).hexdigest()==h: io.sendline(proof.encode()[:4]) print(&quot;proof done&quot;) return iowhile True: io = set_connect_proof() io.recvuntil(b&quot;Send 2 `y&#x27; elements to me: &quot;) y1,y2 = getrandbits(128),getrandbits(128) io.sendline(f&#x27;&#123;str(y1)&#125;,&#123;str(y2)&#125;&#x27;.encode()) q = int(io.recvline_contains(b&#x27;q = &#x27;).decode().strip()[4:]) G = literal_eval(io.recvline_contains(b&quot;G = &quot;).decode().strip()[4:]) mG = literal_eval(io.recvline_contains(b&quot;m * G = &quot;).decode().strip()[8:]) encflag = io.recvline_contains(b&#x27;encrypt flag = &#x27;).decode().strip()[len(b&#x27;encrypt flag = &#x27;):] AA = (y1**2 - y2**2 - 2022**3 + 2023**3) * inverse(-1, q) % q BB = (y1**2 - 2022**3 - AA * 2022) % q E = EllipticCurve(GF(q), [AA, BB]) g_order = E(G).order() order_ls = factor(g_order) print(f&quot;[+] G order &#123;order_ls&#125;&quot;) sub_group_order = 1 for p,e in order_ls: if p.nbits() &lt;= 42: sub_group_order*= (p^e) expon = g_order//sub_group_order print(f&quot;[+] &#123;sub_group_order.nbits() = &#125;&quot;) if sub_group_order.nbits() &lt; 120: io.close() continue mm = discrete_log(expon*E(mG),expon*E(G),ord = sub_group_order,operation = &quot;+&quot;) print(f&quot;[+] subgroup dlp (m mod &#123;sub_group_order&#125;) = &quot;, mm) io.close() breakaes = AES.new(int(mm).to_bytes(16, &#x27;big&#x27;), AES.MODE_CBC, bytes(16))flag = aes.decrypt(bytes.fromhex(encflag))print(flag) singular attack 利用曲线上的奇异点进行攻击，奇点就是该点导数不存在，或者导数为 0 但不是极值点。 若椭圆曲线的判别式\\(\\Delta=-16(4a^3+27b^2)\\;mod\\;p=0\\)，说明该曲线有奇点。 RWCTF2023 体验赛 12if u == w: m = (3*u*w + 4*u + 1) * i(v+x) 根据题目，可得到曲线关于 x 的导数，\\(3x^2+4x+1\\)，所以可得到方程为\\(y^2=x^3+2x^2+x+C\\) 题目已知点(4,10)在曲线上，代入得到 100 = 64 + 32 + 4 + C，即 C = 0，所以方程确定\\(y^2=x^3+2x^2+x\\) 方程左右求导得到\\(2y \\frac{dy}{dx}=3x^2+4x+1\\)，所以当 y=0 时导数不存在，再把 y=0 代入方程，求得 x=-1，所以找到该曲线的奇点为(-1,0)。 下一步我们把曲线平移，使得曲线以(0,0)为奇点，得到y^2 = x^3 + 193387944202565886198256260591909756040*x^2，改写为y^2 = (x + 193387944202565886198256260591909756040) * x^2 因为193387944202565886198256260591909756040 = pow(89654903351345918131227153390056628523,2,p) 我们就可把 P、Q 点映射到乘法群上，从而进行简单的对数计算。 映射法则如下: \\[(x,y)\\rightarrow\\frac{y+tx}{y-tx}\\] EXP 1234567891011121314151617p=193387944202565886198256260591909756041P.&lt;x&gt; = GF(p)[]f = x^3 + 2*x^2 + xP = (4, 10)Q = (65639504587209705872811542111125696405, 125330437930804525313353306745824609665)print(f)f_ = f.subs(x=x-1)print(f_)print (f_.factor())P_ = (P[0] +1, P[1])Q_ = (Q[0] +1, Q[1])t = GF(p)(193387944202565886198256260591909756040).square_root()u = (P_[1] + t*P_[0])/(P_[1] - t*P_[0]) % pv = (Q_[1] + t*Q_[0])/(Q_[1] - t*Q_[0]) % pprint (v.log(u)) RSA DLP magic(hitcon2021) 1234567891011121314151617181920212223242526import osfrom Crypto.Util.number import *from hashlib import *magic=b&#x27;e0204eeaf14d72ab90e1f7ac69559dd182&#x27;LEN = 17magic = os.urandom(LEN)print(&quot;Magic:&quot;, magic.hex())print(&#x27;Coud you use it to do encryption as hash?&#x27;)magic_num = bytes_to_long(magic)try: N = int(input(&#x27;N:&gt;&#x27;)) e = int(input(&#x27;E:&gt;&#x27;)) data = long_to_bytes(int(input(&#x27;data:&gt;&#x27;), 16)) if N &gt;&gt; (248) == magic_num: data2 = sha384(data).digest() num1 = bytes_to_long(data) num2 = bytes_to_long(data2) if pow(num1, e, N) == num2: print(os.getenv(&#x27;FLAG&#x27;)) else: print(&#x27;try harder!!!&#x27;) else: print(&#x27;try harder!&#x27;)except Exception as e: print(&#x27;invalid&#x27;) EXP rabin 适用于 RSA 中 e=2 的情况 pqpq(seccon2022) 12345678910111213141516171819202122232425262728293031323334353637from Crypto.Util.number import *from Crypto.Random import *from flag import flagp = getPrime(512)q = getPrime(512)r = getPrime(512)n = p * q * re = 2 * 65537assert n.bit_length() // 8 - len(flag) &gt; 0padding = get_random_bytes(n.bit_length() // 8 - len(flag))m = bytes_to_long(padding + flag)assert m &lt; nc1p = pow(p, e, n)c1q = pow(q, e, n)cm = pow(m, e, n)c1 = (c1p - c1q) % nc2 = pow(p - q, e, n)print(f&quot;e = &#123;e&#125;&quot;)print(f&quot;n = &#123;n&#125;&quot;)# p^e - q^e mod nprint(f&quot;c1 = &#123;c1&#125;&quot;)# (p-q)^e mod nprint(f&quot;c2 = &#123;c2&#125;&quot;)# m^e mod nprint(f&quot;cm = &#123;cm&#125;&quot;)# e = 131074# n = 587926815910957928506680558951380405698765957736660571041732511939308424899531125274073420353104933723578377320050609109973567093301465914201779673281463229043539776071848986139657349676692718889679333084650490543298408820393827884588301690661795023628407437321580294262453190086595632660415087049509707898690300735866307908684649384093580089579066927072306239235691848372795522705863097316041992762430583002647242874432616919707048872023450089003861892443175057# c1 = 92883677608593259107779614675340187389627152895287502713709168556367680044547229499881430201334665342299031232736527233576918819872441595012586353493994687554993850861284698771856524058389658082754805340430113793873484033099148690745409478343585721548477862484321261504696340989152768048722100452380071775092776100545951118812510485258151625980480449364841902275382168289834835592610827304151460005023283820809211181376463308232832041617730995269229706500778999# c2 = 46236476834113109832988500718245623668321130659753618396968458085371710919173095425312826538494027621684566936459628333712619089451210986870323342712049966508077935506288610960911880157875515961210931283604254773154117519276154872411593688579702575956948337592659599321668773003355325067112181265438366718228446448254354388848428310614023369655106639341893255469632846938342940907002778575355566044700049191772800859575284398246115317686284789740336401764665472# cm = 357982930129036534232652210898740711702843117900101310390536835935714799577440705618646343456679847613022604725158389766496649223820165598357113877892553200702943562674928769780834623569501835458020870291541041964954580145140283927441757571859062193670500697241155641475887438532923910772758985332976303801843564388289302751743334888885607686066607804176327367188812325636165858751339661015759861175537925741744142766298156196248822715533235458083173713289585866 大致思路 根据题目，可先通过计算 c1、c2 表达式，合并找出公因子，即可求出 p、q，从而 r 也可求得。 发现 e=65537 * 2，因此是无逆元存在的，索性就将 e 拆分为 65537 与 2，e2=2 时便可通过 Rabin 算法解密。 求 p、q、r \\(c2 = (p - q)^e \\mod n \\\\\\) 左右同乘 r \\(c2 * r = rp^e + rq^e + X*pqr = rp^e + rq^e \\mod n\\\\\\) \\(c2 = p^e + q^e \\mod n\\\\\\) 同理得到\\(c1 = p^e - q^e \\mod n \\\\\\) 从而求得 p、q \\(p=gcd(c1+c2,n)\\\\\\) \\(q=gcd(c1-c2,n)\\\\\\) 求解 m^2 \\(\\phi(n)=(p-1)*(q-1)*(r-1)\\\\\\) 通过 e1(e/2)和\\(\\phi(n)\\)求出 d，得到\\(cm^d=m^{2*e1*d}=m^2 \\mod n\\) Rabin 解密 接下来就是传统 Rabin 解密，找了两种脚本，exp 中的sqrtPrime(n,p)和Tonelli_Shanks(n,p)任选其一即可，都是基于二次剩余定理所实现的解密算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import gmpy2from Crypto.Util.number import *import randomfrom itertools import productdef sqrtPrime(n, p): q = p - 1 m = 0 while q &amp; 1 == 0: q &gt;&gt;= 1 m += 1 z = 1 while pow(z, (p - 1) &gt;&gt; 1, p) == 1: z = random.randint(1, p - 1) c = pow(z, q, p) t = pow(n, q, p) r = pow(n, (q + 1) &gt;&gt; 1, p) if t == 0: return 0 m -= 2 while t != 1: while pow(t, 2**m, p) == 1: c = c * c % p m -= 1 r = r * c % p c = c * c % p t = t * c % p m -= 1 return rdef Legendre(n,p): # 这里用勒让德符号来表示判断二次（非）剩余的过程 return pow(n,(p - 1) // 2,p)def Tonelli_Shanks(n,p): assert Legendre(n,p) == 1 if p % 4 == 3: print(&quot;1&quot;) return pow(n,(p + 1) // 4,p) q = p - 1 s = 0 while q % 2 == 0: q = q // 2 s += 1 for z in range(2,p): if Legendre(z,p) == p - 1: c = pow(z,q,p) break r = pow(n,(q + 1) // 2,p) t = pow(n,q,p) m = s if t % p == 1: return r else: i = 0 while t % p != 1: # 外层循环的判断条件 temp = pow(t,2**(i+1),p) # 这里写作i+1是为了确保之后内层循环用到i值是与这里的i+1的值是相等的 i += 1 if temp % p == 1: # 内层循环的判断条件 b = pow(c,2**(m - i - 1),p) r = r * b % p c = b * b % p t = t * c % p m = i i = 0 # 注意每次内层循环结束后i值要更新为0 return re = 131074e = 65537*2n = 587926815910957928506680558951380405698765957736660571041732511939308424899531125274073420353104933723578377320050609109973567093301465914201779673281463229043539776071848986139657349676692718889679333084650490543298408820393827884588301690661795023628407437321580294262453190086595632660415087049509707898690300735866307908684649384093580089579066927072306239235691848372795522705863097316041992762430583002647242874432616919707048872023450089003861892443175057c1 = 92883677608593259107779614675340187389627152895287502713709168556367680044547229499881430201334665342299031232736527233576918819872441595012586353493994687554993850861284698771856524058389658082754805340430113793873484033099148690745409478343585721548477862484321261504696340989152768048722100452380071775092776100545951118812510485258151625980480449364841902275382168289834835592610827304151460005023283820809211181376463308232832041617730995269229706500778999c2 = 46236476834113109832988500718245623668321130659753618396968458085371710919173095425312826538494027621684566936459628333712619089451210986870323342712049966508077935506288610960911880157875515961210931283604254773154117519276154872411593688579702575956948337592659599321668773003355325067112181265438366718228446448254354388848428310614023369655106639341893255469632846938342940907002778575355566044700049191772800859575284398246115317686284789740336401764665472cm = 357982930129036534232652210898740711702843117900101310390536835935714799577440705618646343456679847613022604725158389766496649223820165598357113877892553200702943562674928769780834623569501835458020870291541041964954580145140283927441757571859062193670500697241155641475887438532923910772758985332976303801843564388289302751743334888885607686066607804176327367188812325636165858751339661015759861175537925741744142766298156196248822715533235458083173713289585866p = GCD(c1+c2,n)q = GCD(c1-c2,n)r = n//(p*q)phi=(p-1)*(q-1)*(r-1)d0=gmpy2.invert(65537,phi)m2=pow(cm,d0,n)cp=m2%pcq=m2%qcr=m2%rmp=sqrtPrime(cp,p)mq=sqrtPrime(cq,q)mr=sqrtPrime(cr,r)mp=Tonelli_Shanks(cp,p)mq=Tonelli_Shanks(cq,q)mr=Tonelli_Shanks(cr,r)for mp1,mq1,mr1 in product([mp,p-mp],[mq,q-mq],[mr,r-mr]): x=[mp1,mq1,mr1] y=[p,q,r] print(long_to_bytes(crt(y,x)[0]))#SECCON&#123;being_able_to_s0lve_this_1s_great!&#125; parity","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"RSA补充","slug":"RSA补充","date":"2022-12-07T13:05:45.000Z","updated":"2023-02-09T09:15:46.189Z","comments":true,"path":"2022/12/07/RSA补充/","link":"","permalink":"https://sch01ar.github.io/2022/12/07/RSA%E8%A1%A5%E5%85%85/","excerpt":"","text":"回顾 RSA 中加、解密： 加密\\(c = m^e\\quad mod\\quad n\\) 解密\\(m = c^d\\quad mod\\quad n\\) 接下来证明一下解密过程，先引入欧拉定理。 欧拉定理 对于互为质数的 m、n 两个数，有\\(m^{\\phi(n)} = 1\\quad mod\\quad n\\)，其中\\(\\phi(n)\\)表示小于 n 的质数的个数。 解密原理 通过\\(c = m^e\\quad mod\\quad n\\)与欧拉定理\\(m^{\\phi(n)} = 1\\quad mod\\quad n\\)，我们便可进行推导。 对欧拉定理进行变形，得到\\(m^{k\\phi(n)+1} = m\\quad mod\\quad n\\) 因为我们已经知道\\(c = m^e\\quad mod\\quad n\\)，所以寻找一个 d，使得\\(ed = k\\phi(n)+1\\),则可以得到\\(m^{ed}=m\\quad mod \\quad n\\) 则得到了\\(c^d =m\\quad mod\\quad n\\) 共模攻击 所谓共模，就是 n 相同，会对应多组 c，e。 例：给定 n、c1、c2、e1、e2 m = c1e1 mod n m = c2e2 mod n 扩展欧几里得算法 给定两个整数 a、b，必定存在 x、y，使得 gcd(a,b)=ax+by 运用该算法推导过程 m = m % n m = ms1e1+s2e2 % n m = (me1s1 * me2s2)% n m = (me1s1 % n) * (me2s2 % n) % n m = (c1s1 % n) * (c2s2 % n) % n EXP 123456789101112import gmpy2from Crypto.Util.number import long_to_bytesc1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801e1=11187289c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397e2=9647291r,s1,s2=gmpy2.gcdext(e1,e2)m=(pow(c1,s1,n) * pow(c2,s2,n)) %nprint(long_to_bytes(m))#flag&#123;49d91077a1abcb14f1a9d546c80be9ef&#125; 低加密指数广播攻击 特点是 e 小，有多组 n，对应了多组 c me = c1 mod n1 me = c2 mod n2 me = c3 mod n3 中国剩余定理(CRT) 定理内容如下 针对上述方程组，若 n1、n2、n3 互质，对于任意的 c1、c2、c3，方程组都有解 m。 使用条件是 m^e &lt; n1、n2、n3。通解推导如下： 设\\(N=n_1 \\times n_2 \\times n_3, N_1=N/n_1, N_2=N/n_2, N_3=N/n_3\\) 设\\(t_i=N_i^{-1}\\),这里表示\\(t_i\\)是\\(N_i\\)在模\\(n_i\\)的逆元。 有了以上几个数，我们可以给出通解形式： \\[m=c_1t_1N_1+c_2t_2N_2+c_3t_3N_3+kN=kN+\\sum_{i=1}^3c_it_iN_i\\] 在模 N 后，只剩唯一解\\(m=\\sum_{i=1}^3c_it_iN_i\\) EXP 123456789101112131415161718192021222324252627import gmpy2from sympy.ntheory.modular import crtfrom Crypto.Util.number import long_to_bytese = 3n1 = &#x27;331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004&#x27;c1 = &#x27;310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243&#x27;n2 = &#x27;302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114&#x27;c2 = &#x27;112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344&#x27;n3 = &#x27;332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323&#x27;c3 = &#x27;10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242&#x27;c1=int(c1,5)n1=int(n1,5)c2=int(c2,5)n2=int(n2,5)c3=int(c3,5)n3=int(n3,5)e=3n=[n1,n2,n3]c=[c1,c2,c3]resultant,mod= crt(n, c)# 有现成的库函数可以调用print(gmpy2.iroot(resultant, e))m=259362307225540148883586283191025214233097658309244310540770399135748418469298031742173624766441014006294782333print(long_to_bytes(m))#noxCTF&#123;D4mn_y0u_h4s74d_wh47_4_b100dy_b4s74rd!&#125; dp、dq 相关 给定 dp、dq 类型 dp ≡ d mod (p-1) dq ≡ d mod (q-1) m ≡ cd mod n m = cd + k * n m = cd +k _ p _ q 对上式两端同时对 p、q 分别取余，得：（中国剩余定理） m1 ≡ cd mod p m2 ≡ cd mod q 同理，可得到 cd = m1 +k * p 代入到 m2 ≡ cd mod q 中： m2 ≡ (m1 + k * p)mod q ，两端减去 m1 得 m2 - m1 ≡ k * p mod q ，两端乘 p 的逆元得 (m2 - m1)p-1 ≡ k mod q 将 k 代入到 cd = m1 +k * p 中得： cd = m1 + ((m2 - m1)p-1 mod q) * p m=cd mod n 得到 m ≡ (((m2 - m1) _ p-1 mod q) _ p + m1) mod n 接下来就是求解 m1，m2 m1 ≡ cdp+k(p-1) mod p m2 ≡ cdq+k(q-1) mod q 根据费马小定理 若 p 是素数，则 a(p-1) ≡ 1 mod p 因此 m1 ≡ cdp mod p，m2 ≡ cdq mod q 最终可求得 m EXP 1234567891011121314import gmpy2from Crypto.Util.number import long_to_bytesp = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852m1=pow(c,dp,p)m2=pow(c,dq,q)n=p*qp0=gmpy2.invert(p,q)m=(((m2-m1)*p0 % q)* p +m1)%nprint(long_to_bytes(m))#noxCTF&#123;W31c0m3_70_Ch1n470wn&#125; 只给定 dp dp ≡ d mod (p-1) ed ≡ 1 mod (p-1) * (q-1) ed = 1 + k2(p-1)(q-1) 对 1 式两端同乘 e，得 e * dp ≡ ed mod (p-1) e * dp = k1(p-1) + ed 代入 ed 得 e * dp = k1(p-1) + 1 + k2(p-1)(q-1) 由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余 p-1，即可消掉 n e * dp ≡ 1 mod (p-1) e * dp =k(p-1) + 1 得到这个式子后，其实真正意义上的未知数只有我们要求的 p，但是还存在一个 k。 针对 k，我们判断一下他的范围，看看能否采用爆破的方式。 k = (e * dp - 1)/(p-1) 因为 dp &lt; p-1 所以 k &lt; e 通过遍历 k 然后找到(e * dp - 1)可以整除 k 的情况即可。 (跑了一下发现限制条件还不够) 因此再加一个 n 能否整除 p 即可。 EXP 1234567891011121314151617181920import gmpy2from Crypto.Util.number import long_to_bytese = 65537n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751# p = 13468634736343473907717969603434376212206335187555458742257940406618189481177835992217885676243155145465521141546915941147336786447889325606555333350540003# q = 18432009829596386103558375461387837845170621179295293289126504231317130550979989727125205467379713835047300158256398009229511746203459540859429194971855371for k in range(1,e): if (e*dp-1)%k == 0: p=(e*dp-1)//k + 1 if n%p == 0: print(p) breakq=n//pphi= (p-1)*(q-1)d= gmpy2.invert(e,phi)m=pow(c,d,n)print(long_to_bytes(m))#flag&#123;wow_leaking_dp_breaks_rsa?_98924743502&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"2022DASCTF_NOV-lllcccggg-wp","slug":"2022DASCTF_NOV-lllcccgggwp","date":"2022-11-30T02:05:45.000Z","updated":"2022-12-01T09:42:22.869Z","comments":true,"path":"2022/11/30/2022DASCTF_NOV-lllcccgggwp/","link":"","permalink":"https://sch01ar.github.io/2022/11/30/2022DASCTF_NOV-lllcccgggwp/","excerpt":"","text":"题目描述 如题目名字一样，有好多个lcg，当时看晕了 123456789101112131415161718192021222324252627282930313233343536373839404142434445from Crypto.Util.number import *key=b&#x27;*************&#x27;key=bytes_to_long(key)key=bin(key)[2:]n=getPrime(256)a=[getPrime(256)]for i in range(1,len(key)): a.append(a[i-1]*2)b=getPrime(256)m=[]for i in range(len(key)): m.append((a[i]*b)%n)s=0for i in range(len(key)): s+=m[i]*int(key[i])seed=sa = getPrime(300)b = getPrime(300)n = getPrime(300)output = []for i in range(10): seed = (a*seed+b)%n output.append(seed)print(&quot;output = &quot;,output)print(&#x27;m=&#x27;,m)state=int(key,2)a=getPrime(256)b=getPrime(256)c=getPrime(256)for _ in range(10**10000): state = (a * state + b) % cflag=b&#x27;****************************************&#x27;state_md5=hashlib.md5(str(state).encode()).hexdigest()xorflag=xor(flag,state_md5).hex()print(&#x27;a=&#x27;,a)print(&#x27;b=&#x27;,b)print(&#x27;c=&#x27;,c)print(&#x27;xorflag=&#x27;,xorflag) 题目分析 1.key是一个背包问题，已知公钥m，和的话目前不知道。 2.以1中的和为seed，通过LCG产生了一组序列output。 至此，已经可以根据output来求出LCG中的a、b、n，从而求出seed，从而通过背包可求得key。 3.以key为seed，称作state，再进行LCG，state = (a * state + b) % c，并且a，b，c已知。 但是想要直接正向求解出最后的state，十分困难，for循环了10^10000次，这里涉及到了矩阵快速幂的使用。 通过构造矩阵 \\[ \\mathbf{A} = \\begin{bmatrix} state &amp; 1 \\end{bmatrix} \\] \\[ \\mathbf{C} = \\begin{bmatrix} a &amp; 0\\\\ b &amp; 1\\\\ \\end{bmatrix} \\] 通过计算\\(A*C^{10*10000}\\)即可得到矩阵B，B = [ state, 1] 4.求出state后进行异或解密即可。 EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from functools import reducefrom math import gcdimport hashlibfrom Crypto.Util.number import *import gmpy2def crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return modulusoutput = [75581294523880849612962675076574164955427439308298754836702542570856707873339581806556114, 85105032146983524265511965363979041936757881362506442483720291395014453678757599185295866, 1135521205967352800446368309480529634045225881261100886117662161359310082444102071893527191, 668602662320826002160475166323016971968419541611162501120982012317608523771962990634779874, 649673553234341629614052928960182629959348742983379959653724041939165898600067312959677865, 785853955591839090537858092210736716046894245185520583713505441606094906159642640920286905, 937799570303158165818350743257433287791556030352377438071495081189542968310256239806349207, 734514754865608924980327625447363286114899547828404532253101460271494241963897226149955073, 1106313725444442262780946046218124519471559148520571880678416934586056489046936771811070897, 8768152099561586039808874499029856564696410477579827751292882367683300035228537162519939]m= [72110328606337761986452574632319920368225905906258123752738204764660440229296, 54011682421724526639264309053337133761455956763651742732220904522794415369243, 17814390052498055944887777895371560547916058478438980691186304039062365649137, 35628780104996111889775555790743121095832116956877961382372608078124731298274, 71257560209992223779551111581486242191664233913755922764745216156249462596548, 52306145629033450225461382951669777408332612778647340756234927305972460103747, 14403316467115903117281925692036847841669370508430176739214349605418455118145, 28806632934231806234563851384073695683338741016860353478428699210836910236290, 57613265868463612469127702768147391366677482033720706956857398421673820472580, 25017556945976227604614565324992075758359109018576909140459291836821175855811, 50035113891952455209229130649984151516718218037153818280918583673642351711622, 9861252992953913084817421088665596058440581025443131788581662340758238333895, 19722505985907826169634842177331192116881162050886263577163324681516476667790, 39445011971815652339269684354662384233762324101772527154326649363032953335580, 78890023943631304678539368709324768467524648203545054308653298726065906671160, 67571073096311612023437897207346829960053441358225603844051092445605348252971, 44933171401672226713234954203390952945111027667586702914846679884684231416593, 89866342803344453426469908406781905890222055335173405829693359769368462833186, 89523710815737909519298976602261104805448255621482306886131214532210460577023, 88838446840524821704957112993219502635900656194100108999006924057894456064697, 87467918890098646076273385775136298296805457339335713224758343109262447040045, 84726862989246294818905931338969889618615059629806921676261181211998428990741, 79244751187541592304171022466637072262234264210749338579266857417470392892133, 68280527584132187274701204721971437549472673372634172385278209828414320694917, 46352080377313377215761569232640168123949491696403839997300914650302176300485, 2495185963675757097882298253977629272903128343943175221346324294077887511621, 4990371927351514195764596507955258545806256687886350442692648588155775023242, 9980743854703028391529193015910517091612513375772700885385297176311550046484, 19961487709406056783058386031821034183225026751545401770770594352623100092968, 39922975418812113566116772063642068366450053503090803541541188705246200185936, 79845950837624227132233544127284136732900107006181607083082377410492400371872, 69482926884297456930826248043265566490804358963498709392909249814458335654395, 48756878977643916528011655875228426006612862878132914012562994622390206219441, 7304783164336835722382471539154145038229870707401323251870484238253947349533, 14609566328673671444764943078308290076459741414802646503740968476507894699066, 29219132657347342889529886156616580152919482829605293007481936953015789398132, 58438265314694685779059772313233160305838965659210586014963873906031578796264, 26667555838438374224478704415163613636682076269556667256672242805536692503179, 53335111676876748448957408830327227273364152539113334513344485611073385006358, 16461248562802499564273977449351747571732450029362164253433466215620304923367, 32922497125604999128547954898703495143464900058724328506866932431240609846734, 65844994251209998257095909797406990286929800117448657013733864862481219693468, 41481013711468999180550979383511273598863745186032809254212224718435974297587, 82962027422937998361101958767022547197727490372065618508424449436871948595174, 75715080054924999388563077322742387420459125695266732243593393867217432100999, 61221185318899001443485314434182067865922396341668959713931282727908399112649, 32233395846847005553329788657061428756848937634473414654607060449290333135949, 64466791693694011106659577314122857513697875268946829309214120898580666271898, 38724608596437024879678314416943008052399895489029153845172736790634867454447, 77449217192874049759356628833886016104799790978058307690345473581269734908894, 64689459594797102185072417456469325234603726907252110607435442156013004728439, 39169944398643207036503994701635943494211598765639716441615379305499544367529, 78339888797286414073007989403271886988423197531279432883230758610999088735058, 66470802803621830812375138595241067001850540013694360993206012215471712380767, 42732630816292664291109436979179427028705224978524217213156519424416959672185, 85465261632585328582218873958358854057410449957048434426313038848833919344370, 80721548474219659830796907705415001139825044865232364079370572691141373599391, 71234122157488322327952975199527295304654234681600223385485640375756282109433, 52259269524025647322265110187751883634312614314335941997715775744986099129517, 14309564257100297310889380164201060293629373579807379222176046483445733169685, 28619128514200594621778760328402120587258747159614758444352092966891466339370, 57238257028401189243557520656804241174517494319229516888704185933782932678740, 24267539265851381153474201102305775374039133589594529004152866861039400268131, 48535078531702762306948402204611550748078267179189058008305733722078800536262, 6861182272454527280255964197920394521160679309513611243355962437631135983175, 13722364544909054560511928395840789042321358619027222486711924875262271966350, 27444729089818109121023856791681578084642717238054444973423849750524543932700, 54889458179636218242047713583363156169285434476108889946847699501049087865400, 19569941568321439150454586955423605363575013903353275120439893995571710641451, 39139883136642878300909173910847210727150027806706550240879787991143421282902, 78279766273285756601818347821694421454300055613413100481759575982286842565804, 66350557755620515869995855432086135933604256177961696190263646958047220042259, 42492140720290034406350870652869564892212657307058887607271788909567974995169, 84984281440580068812701741305739129784425314614117775214543577819135949990338, 79759588090209140291762642400175552593854774179371045655831650631745434891327, 69310201389467283249884444589048398212713693309877586538407796256964404693305, 48411427987983569166128048966794089450431531570890668303560087507402344297261, 6613881185016140998615257722285471925867208092916831833864670008278223505173, 13227762370032281997230515444570943851734416185833663667729340016556447010346, 26455524740064563994461030889141887703468832371667327335458680033112894020692, 52911049480129127988922061778283775406937664743334654670917360066225788041384, 15613124169307258644203283345264843838879474437804804568579215125925110993419, 31226248338614517288406566690529687677758948875609609137158430251850221986838, 62452496677229034576813133381059375355517897751219218274316860503700443973676, 34696018563507071819985426550816043736039940453573931775378216000874422858003, 69392037127014143639970853101632087472079880907147863550756432001748845716006, 48575099463077289946300865991961467969163906765431222328257358996971226342663, 6941224135203582558960891772620228963331958481997939883259212987415987595977, 13882448270407165117921783545240457926663916963995879766518425974831975191954, 27764896540814330235843567090480915853327833927991759533036851949663950383908, 55529793081628660471687134180961831706655667855983519066073703899327900767816, 20850611372306323609733428150620956438315480663102533358891902792129336446283, 41701222744612647219466856301241912876630961326205066717783805584258672892566, 83402445489225294438933712602483825753261922652410133435567611168517345785132, 76595916187499591544226584993664944531527990255955762097879717330508226480915, 62982857584048185754812329776027182088060125463047019422503929654489987872481, 35756740377145374175983819340751657201124395877229534071752354302453510655613, 71513480754290748351967638681503314402248791754459068143504708604907021311226, 52817986717630499370294437151703921829501728460053631513753912203287577533103, 15426998644310001406948034092105136684007601871242758254252319400048689976857, 30853997288620002813896068184210273368015203742485516508504638800097379953714, 61707994577240005627792136368420546736030407484971033017009277600194759907428, 33207014363529013921943432525538386497064959921077561260763050193863054725507, 66414028727058027843886865051076772994129919842155122521526100387726109451014, 42619082663165058354132889890850839013263984635445740269796695768925753812679, 85238165326330116708265779781701678026527969270891480539593391537851507625358, 80267355861709236082890719352100649078060083492918456305931278069176550161367, 70325736932467474832140598492898591181124311936972407838607051131826635233385, 50442499073983952330640356774494475387252768825080310903958597257126805377421, 10676023357016907327639873337686243799509682601296117034661689507727145665493, 21352046714033814655279746675372487599019365202592234069323379015454291330986, 42704093428067629310559493350744975198038730405184468138646758030908582661972, 85408186856135258621118986701489950396077460810368936277293516061817165323944, 80607398921319519908597133191677193817159066571873367781331527117107865558539, 71005823051688042483553426172051680659322278094882230789407549227689266027729, 51802671312425087633466012132800654343648701140899956805559593448852066966109, 13396367833899177933291184054298601712301547232935408837863681891177668842869, 26792735667798355866582368108597203424603094465870817675727363782355337685738, 53585471335596711733164736217194406849206188931741635351454727564710675371476, 16961967880242426132688632223086106723416522814618765929653950122894885653603, 33923935760484852265377264446172213446833045629237531859307900245789771307206, 67847871520969704530754528892344426893666091258475063718615800491579542614412, 45486768250988411727868217573386146812336327468085622663976095976632620139475, 764561711025826122095594935469586649676799887306740554696686946738775189601, 1529123422051652244191189870939173299353599774613481109393373893477550379202, 3058246844103304488382379741878346598707199549226962218786747786955100758404, 6116493688206608976764759483756693197414399098453924437573495573910201516808, 12232987376413217953529518967513386394828798196907848875146991147820403033616, 24465974752826435907059037935026772789657596393815697750293982295640806067232, 48931949505652871814118075870053545579315192787631395500587964591281612134464, 7654924220354746294595311528804384183634530526398286227920424176036759179579, 15309848440709492589190623057608768367269061052796572455840848352073518359158, 30619696881418985178381246115217536734538122105593144911681696704147036718316, 61239393762837970356762492230435073469076244211186289823363393408294073436632, 32269812734724943379884144249567439963156633373508074873471281810061681783915, 64539625469449886759768288499134879926313266747016149746942563620123363567830, 38870276147948776185895736786967052877630678445167794720629622233720262046311, 77740552295897552371791473573934105755261356890335589441259244467440524092622, 65272129800844107409942106936565504535526858731806674109262983928354583095895, 40335284810737217486243373661828302096057862414748843445270462850182701102441, 80670569621474434972486747323656604192115724829497686890540925700365402204882, 71132164451997872611332654436010501409235594610130869007826346394204339320415, 52055354113044747889024468660718295843475334171397233242397187781882213551481, 13901733435138498444408097110133884711954813293929961711538870557237962013613, 27803466870276996888816194220267769423909626587859923423077741114475924027226, 55606933740553993777632388440535538847819253175719846846155482228951848054452, 21004892690156990221623936669768370720642651302575188919055459451377231019555, 42009785380313980443247873339536741441285302605150377838110918902754462039110, 84019570760627960886495746679073482882570605210300755676221837805508924078220, 77830166730304924439350653146844258790145355371737006579188170604491383067091, 65451358669658851545060466082385810605294855694609508385120836202456301044833]a2= 102146678855348749881681741830301892566150942749854546938156269348575567682569b2= 57926598868103510549704115342815226386495366694945712679089221082045615713293c= 79112540456632613121737537841885533313599936328220061653608162113976717833173xor = 0x2079677330734e7d07116d73543d03316c6501555c02403b7201080612101049n = crack_unknown_modulus(output)a=(output[2]-output[1])*inverse((output[1]-output[0]),n)%nb=(output[1]-a*output[0])%nseed = (inverse(a,n)*(output[0]-b))%n# sage# sum = seed# nbits=len(m)# A=Matrix(ZZ,nbits+1,nbits+1)# for i in range(nbits):# A[i,i]=2# A[i,-1]=m[i]# for i in range(nbits+1):# A[-1,i]=1# A[-1,-1]=sum# A[:,-1]=2**100# r=A.LLL()# for i in r:# if len(set(i[:-1])) == 2:# print(i)key=[-1, 1, 1, 1, 1, 1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, -1, 1, -1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, -1, 1, -1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, 1, 1, -1, -1, 1, -1, 1, -1, -1, 0]key0=[]for i in range(len(key)): if key[i]==-1: key0.append(1) if key[i]==1: key0.append(0)state = int(&#x27;&#x27;.join([str(i) for i in key0]), 2)# 矩阵快速幂# a = 102146678855348749881681741830301892566150942749854546938156269348575567682569# b = 57926598868103510549704115342815226386495366694945712679089221082045615713293# c = 79112540456632613121737537841885533313599936328220061653608162113976717833173# state = 1459518099080641908882248947391577149455413355# A=[state,1]# A = Matrix(Zmod(c),A)# C = Matrix(Zmod(c),[[a, 0], [b, 1]])# state=A*C^(10**10000)# print(state)state=5413978693489756582509930284917854732906886271552898511650182850401353715151state_md5=hashlib.md5(str(state).encode()).hexdigest()state_md5=bytes_to_long(state_md5.encode())flag=long_to_bytes(state_md5^xor)print(flag)# b&#x27;DASCTF&#123;D0u_Ge_1S_R4al1y_G00d!!!&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"背包加密算法","slug":"背包问题算法","date":"2022-11-28T16:00:00.000Z","updated":"2022-12-01T09:50:05.003Z","comments":true,"path":"2022/11/29/背包问题算法/","link":"","permalink":"https://sch01ar.github.io/2022/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/","excerpt":"","text":"前言 在一次CTF比赛中遇到了，写了10个for嵌套硬爆出来了，复现的时候发现是背包加密。 Merkle–Hellman 公钥加密算法 整体加密流程 12345678import numpyx = [1,0,0,1,0]#明文对应的2进制数a = [3,7,16,50,120]# 产生一个超递增序列，称作私钥#对私钥a进行加密，产生公钥b。m = 251#选取一个模数w = 300#选取一个乘数b = [w * x % m for x in a]#产生公钥S = numpy.dot(x,b)#加密结果 可以发现，加密十分容易，但解密十分困难，这也是非对称加密的特点。 ### 加密 生成私钥 超递增序列，也就是a中每一位元素需要大于其之前所有元素的和。 123a =[randint(20, 50)]for i in range(nbits - 1): a.append(randint(2 * a[-1], 3 * a[-1])) 生成公钥 模数m要求：m &gt; sum(a) 乘数w要求：gcd(w,m) == 1 1234567while True: m = randint(2 * a[-1] + 1, 3 * a[-1]) w = randint(2 * a[-1] + 1, 3 * a[-1]) if gcd(w, m) == 1: breakb = [w * x % m for x in a] b和m作为公钥。 加密：S = numpy.dot(x,b) 解密 拿到公钥\\(M=(m_1,m_2,\\ldots,m_n)\\)，构造如下矩阵 \\[ \\begin{bmatrix} 2 &amp; 0 &amp; \\ldots &amp; 0 &amp; m_1 \\\\ 0 &amp; 2 &amp; \\ldots &amp; 0 &amp; m_2 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\ldots &amp; 2 &amp; m_n \\\\ 1 &amp; 1 &amp; \\ldots &amp; 1 &amp; S \\\\ \\end{bmatrix} \\] 这个矩阵的所有行向量的线性组合构成了一个格，接下来将通过明文的特点和格上的特殊解法来进行解密。 LLL 对于明文\\(X=(x_1,x_2,\\ldots,x_n)\\)这一组数来说，构造一个向量 \\[ a=\\sum_{i=1}^nx_iv_i-v_{n+1}=(2x_1-1,2x_2-1,\\ldots,2x_n-1,0) \\] 显然，a向量在格L上。因为X中的所有x只能取值0或1，因此a向量的长度很小，约为\\(\\sqrt{n}\\)，对于很大的格基来说，a向量无疑是格L上的最小向量，因此我们利用LLL算法即可求出a向量。 例题 12345678910111213sum=492226042629702nbits=32M=[19620578458228, 39616682530092, 3004204909088, 6231457508054, 3702963666023, 48859283851499, 4385984544187, 11027662187202, 18637179189873, 29985033726663, 20689315151593, 20060155940897, 46908062454518, 8848251127828, 28637097081675, 35930247189963, 20695167327567, 36659598017280, 10923228050453, 29810039803392, 4443991557077, 31801732862419, 23368424737916, 15178683835989, 34641771567914, 44824471397533, 31243260877608, 27158599500744, 2219939459559, 20255089091807, 24667494760808, 46915118179747]A=Matrix(ZZ,nbits+1,nbits+1)for i in range(nbits): A[i,i]=2 A[i,-1]=M[i]for i in range(nbits+1): A[-1,i]=1A[-1,-1]=sumr=A.LLL()print(r[0])#(-1, -1, 1, -1, 1, -1, -1, -1, -1, 1, 1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, 0) 这里注意一下，第一行向量中是有+1与-1，需要进行取反，即-1代表1，1代表0。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"非对称加密","slug":"非对称加密","permalink":"https://sch01ar.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"}]},{"title":"Hitcon 2022-㊙️BabySSS","slug":"hitcon2022-BabySSS","date":"2022-11-27T16:00:00.000Z","updated":"2022-12-01T09:37:56.735Z","comments":true,"path":"2022/11/28/hitcon2022-BabySSS/","link":"","permalink":"https://sch01ar.github.io/2022/11/28/hitcon2022-BabySSS/","excerpt":"","text":"I implemented a toy Shamir's Secret Sharing for fun. Can you help me check is there any issues with this? Shamir's Secret Sharing密钥分享算法 \\[f(x)=a_0 + a_1x + a_2x^2 + …… + a_{k-1} x^{k-1} mod p \\] 题目源码 12345678910111213141516171819202122232425262728293031from random import SystemRandomfrom Crypto.Cipher import AESfrom hashlib import sha256from secret import flagrand = SystemRandom()def polyeval(poly, x): return sum([a * x**i for i, a in enumerate(poly)])DEGREE = 128SHARES_FOR_YOU = 8 # I am really stingy :)poly = [rand.getrandbits(64) for _ in range(DEGREE + 1)]shares = []for _ in range(SHARES_FOR_YOU): x = rand.getrandbits(16) y = polyeval(poly, x) shares.append((x, y))print(shares)secret = polyeval(poly, 0x48763)key = sha256(str(secret).encode()).digest()[:16]cipher = AES.new(key, AES.MODE_CTR)print(cipher.encrypt(flag))print(cipher.nonce)#[(41458, 3015894889650529600470920314593280408459518223054415623846810748413393737686521849609926975694824777687791824408686652245102687392987299828716863372946074882798754477101786150262288970710451710086966378817944448615584285684364802621112755627795146504720812935041851556318832824799502759754100408717888912062197676588256634343721633045179136302533777168978134770315363985448879229514802330846792965525004570768212871252658334277172395338054448791891165981203069346039654617938169527772805687564575525262812469960675835101499054296722994451502140787064163668418661661374437567033971648550576296023422536253955229), (3389, 188433716494377932944071544153838579057591833387651830021721770473524507947811754295899393634645349682360212761145039355690817927625249659010181081209481357850193656763556243022791637306094953982811471415645267589939465925098159204147714779617946431727015863707468081949286110249296858079354949234074465541940264775783884708819566758872542606519408358277173683256608326688673226933790117016596834640875497643330432185114931410656582728964222203181026468387428893233826461), (20016, 100434774699078525844435127144579870564983915777345068724291926367405061427748836490810414860997895358378538088786283372231649911113841061354335739776409724471256377867811133591349442950556374825868587940833009529662869081130218551306459690738900795035660420986807973542512081415453215211908130387754214098414826747340962722685373241806099462750595976574593799013733614097923338311883793416643213898201680852118540438376386415411317989072583126108177482838299109479175882214603698768498421016054035672774286507312986602290254323930575001551875601243671354491241420409219), (50683, 444545881882748849210617532697661279371689521082184772844723908765173319859389018743414369945234307906596253496624659734919646710483514374218993496994560985318096082923429834553341897367168830049334302307406087637232329348570485341223211629167329394484624055745054495405880099706580380696671879365741197827080224977821589102425678989782880274304484630899425664722718972847034030888019348402685383311095030884356731112886316823960378572796288532824588478234949384868912708000223119984161992105752059185137674711077940232530298853451166664700609238496874366152042676602089571801873748042888046623717879084695143810047335029), (6445, 101461065764578261241074518788237888467081270902741849861528201922043223477790661159690684156056890167304291810116447916457265705130707166062372766839626095333813681671546097679623755546322833727082145873422243641505450049118758544298328784536759107951763715458884889255549767465897671061295486677353893450789955616926292534325337544782386120469581214993770910137353221116457111551538222138388416162630076391624447865248920466274175229034129561913505977209131490066291917549232913771218316393849495621818397), (1359, 301175604076484656987097022479686300460199620068959954988990822483114048418823291831080744590394713639405681060973359346474547015206086229256524657214311815578895906855833813636970640902962286472992468394831014254279137613828904924898823470285520515090889491445149243620044782726415898188702226878029241518020146726699446397961112596830223444821094650508662477147134721631935528182772284099429814417490160457082241680661), (45286, 244867719210730952183489456726726432791149629831242968845409984537752132549250274779516590253042559196452609852176114909791657154092483479876795482861784431886143414585698773882088948703730268947925790809436449512089696895048994874003651088538416399435467483409931121063976149037130454114161175715871108284419975118570732022104749321213013756795645219060997019373915339235627535694458093194617642834806820772479160496966470147893963746139947337914575231526069667124822677688977724313174612816604463495630041075005651663546036363128325535621487658461744362098985183050127661470315454320073092665472364666768205258769), (5649, 4766101906865350375503575239791521167258753430948472304582908507542293595346756303331383584550516424087839316050412570112796817549423179461056531056102741963677007097061600281918678364910813585444151640384802648969082273001142879806475184857246441212406056540028447374033197873299250076862108042582790928405869475508762352345569281589853917902601519294573327847401601789315980414998055948162169170771240383220643819333682845459742335249254576151835966500230706707674854493184181354958093926469960861)]#b&#x27;G$\\xf5\\x9e\\xa9\\xb1e\\xb5\\x86w\\xdfz\\xbeP\\xecJ\\xb8wT&lt;&lt;\\x84\\xc5v\\xb4\\x02Z\\xa4\\xed\\x8fB\\x00[\\xc0\\x02\\xf9\\xc0x\\x16\\xf9\\xa4\\x02\\xb8\\xbb&#x27;#b&#x27;\\x8f\\xa5z\\xb4mZ\\x97\\xe9&#x27; 题目分析 题目给了8组x，y的值，可通过CRT模x求出a_0 ，通过模x^2 可求出a_1 ，同理可求出所有系数，恢复出polyeval函数，从而得到正确的secret。 EXP 123456789101112131415161718192021222324from Crypto.Cipher import AESfrom hashlib import sha256from Crypto.Util.number import *from sympy.ntheory.modular import crtdef polyeval(poly, x): return sum([a * x**i for i, a in enumerate(poly)])shares = [(41458, 3015894889650529600470920314593280408459518223054415623846810748413393737686521849609926975694824777687791824408686652245102687392987299828716863372946074882798754477101786150262288970710451710086966378817944448615584285684364802621112755627795146504720812935041851556318832824799502759754100408717888912062197676588256634343721633045179136302533777168978134770315363985448879229514802330846792965525004570768212871252658334277172395338054448791891165981203069346039654617938169527772805687564575525262812469960675835101499054296722994451502140787064163668418661661374437567033971648550576296023422536253955229), (3389, 188433716494377932944071544153838579057591833387651830021721770473524507947811754295899393634645349682360212761145039355690817927625249659010181081209481357850193656763556243022791637306094953982811471415645267589939465925098159204147714779617946431727015863707468081949286110249296858079354949234074465541940264775783884708819566758872542606519408358277173683256608326688673226933790117016596834640875497643330432185114931410656582728964222203181026468387428893233826461), (20016, 100434774699078525844435127144579870564983915777345068724291926367405061427748836490810414860997895358378538088786283372231649911113841061354335739776409724471256377867811133591349442950556374825868587940833009529662869081130218551306459690738900795035660420986807973542512081415453215211908130387754214098414826747340962722685373241806099462750595976574593799013733614097923338311883793416643213898201680852118540438376386415411317989072583126108177482838299109479175882214603698768498421016054035672774286507312986602290254323930575001551875601243671354491241420409219), (50683, 444545881882748849210617532697661279371689521082184772844723908765173319859389018743414369945234307906596253496624659734919646710483514374218993496994560985318096082923429834553341897367168830049334302307406087637232329348570485341223211629167329394484624055745054495405880099706580380696671879365741197827080224977821589102425678989782880274304484630899425664722718972847034030888019348402685383311095030884356731112886316823960378572796288532824588478234949384868912708000223119984161992105752059185137674711077940232530298853451166664700609238496874366152042676602089571801873748042888046623717879084695143810047335029), (6445, 101461065764578261241074518788237888467081270902741849861528201922043223477790661159690684156056890167304291810116447916457265705130707166062372766839626095333813681671546097679623755546322833727082145873422243641505450049118758544298328784536759107951763715458884889255549767465897671061295486677353893450789955616926292534325337544782386120469581214993770910137353221116457111551538222138388416162630076391624447865248920466274175229034129561913505977209131490066291917549232913771218316393849495621818397), (1359, 301175604076484656987097022479686300460199620068959954988990822483114048418823291831080744590394713639405681060973359346474547015206086229256524657214311815578895906855833813636970640902962286472992468394831014254279137613828904924898823470285520515090889491445149243620044782726415898188702226878029241518020146726699446397961112596830223444821094650508662477147134721631935528182772284099429814417490160457082241680661), (45286, 244867719210730952183489456726726432791149629831242968845409984537752132549250274779516590253042559196452609852176114909791657154092483479876795482861784431886143414585698773882088948703730268947925790809436449512089696895048994874003651088538416399435467483409931121063976149037130454114161175715871108284419975118570732022104749321213013756795645219060997019373915339235627535694458093194617642834806820772479160496966470147893963746139947337914575231526069667124822677688977724313174612816604463495630041075005651663546036363128325535621487658461744362098985183050127661470315454320073092665472364666768205258769), (5649, 4766101906865350375503575239791521167258753430948472304582908507542293595346756303331383584550516424087839316050412570112796817549423179461056531056102741963677007097061600281918678364910813585444151640384802648969082273001142879806475184857246441212406056540028447374033197873299250076862108042582790928405869475508762352345569281589853917902601519294573327847401601789315980414998055948162169170771240383220643819333682845459742335249254576151835966500230706707674854493184181354958093926469960861)]c = b&#x27;G$\\xf5\\x9e\\xa9\\xb1e\\xb5\\x86w\\xdfz\\xbeP\\xecJ\\xb8wT&lt;&lt;\\x84\\xc5v\\xb4\\x02Z\\xa4\\xed\\x8fB\\x00[\\xc0\\x02\\xf9\\xc0x\\x16\\xf9\\xa4\\x02\\xb8\\xbb&#x27;cn = b&#x27;\\x8f\\xa5z\\xb4mZ\\x97\\xe9&#x27;poly=[]for i in range(129): x, y = zip(*shares) tmp=crt(x,y)[0] shares = [(x, (y - tmp) // x) for x, y in shares] poly.append(tmp)secret = polyeval(poly, 0x48763)key = sha256(str(secret).encode()).digest()[:16]cipher = AES.new(key, AES.MODE_CTR,nonce=cn)print(cipher.decrypt(c))#hitcon&#123;doing_SSS_in_integers_is_not_good_:(&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"Gauss格基约简算法","slug":"Gauss格基约简算法","date":"2022-11-23T16:00:00.000Z","updated":"2022-12-07T09:39:00.075Z","comments":true,"path":"2022/11/24/Gauss格基约简算法/","link":"","permalink":"https://sch01ar.github.io/2022/11/24/Gauss%E6%A0%BC%E5%9F%BA%E7%BA%A6%E7%AE%80%E7%AE%97%E6%B3%95/","excerpt":"","text":"由Gauss提出的二维格基约化算法 算法伪代码 即对给定的两个基向量进行不断的相互约化，最终求得格上的最小向量 Loop If ||v2|| &lt; ||v1||, swap v1, v2 Compute m = ⌊ v1∙v2 / v1∙v1 ⌉ If m = 0, return v1, v2 v2 = v2 - m*v1 Continue Loop 代码实现 123456789101112131415161718192021222324252627#pythonimport numpy as npdef e_norm(a): n = len(a) s = 0 for i in range(n): res = a[i] * a[i] s += res return sdef gauss_reduction(v1, v2): while True: v1_enorm = e_norm(v1) v2_enorm = e_norm(v2) if v1_enorm &gt; v2_enorm: v1, v2 = v2, v1 v1_enorm, v2_enorm = v2_enorm, v1_enorm m = np.dot(v1, v2) / v1_enorm m = int(round(m)) if m == 0: print(&quot;v1:&quot; + str(v1)) print(&quot;v2:&quot; + str(v2)) return True else: v2 = v2 - np.dot(m, v1)#最后输出的两个向量，v1即为格上最短向量 例题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import numpy as npfrom Crypto.Util.number import getPrime, inverse, bytes_to_long,long_to_bytesimport randomimport mathFLAG = b&#x27;crypto&#123;?????????????????????&#125;&#x27;def gen_key(): q = getPrime(512) upper_bound = int(math.sqrt(q // 2)) lower_bound = int(math.sqrt(q // 4)) f = random.randint(2, upper_bound) while True: g = random.randint(lower_bound, upper_bound) if math.gcd(f, g) == 1: break h = (inverse(f, q)*g) % q return (q, h), (f, g)def encrypt(q, h, m): assert m &lt; int(math.sqrt(q // 2)) r = random.randint(2, int(math.sqrt(q // 2))) e = (r*h + m) % q return edef decrypt(q, h, f, g, e): a = (f*e) % q m = (a*inverse(f, g)) % g return mpublic, private = gen_key()q, h = publicf, g = privatem = bytes_to_long(FLAG)e = encrypt(q, h, m)print(f&#x27;Public key: &#123;(q,h)&#125;&#x27;)print(f&#x27;Encrypted Flag: &#123;e&#125;&#x27;)&#x27;&#x27;&#x27;Public key: (7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257, 2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800)Encrypted Flag: 5605696495253720664142881956908624307570671858477482119657436163663663844731169035682344974286379049123733356009125671924280312532755241162267269123486523&#x27;&#x27;&#x27; 思路 给定公钥q、h，以及明文e 要求私钥f、g 他们之间有如下关系： fh ≡ g mod q 即 kq + g =fh g = fh -kq 根据这一特点即可构造格，也就是格密码中很经典的，遇到一个向量乘矩阵，即可进行构造 由于存在一组a、b，使得a（1，h）+ b（0，q）=（f，g）\\(a(1,h) + b(0,q) = (f,g)\\) a = f，b = k 选取一组基底为（1，h）和（0，q），也就是上述高斯约简算法当中的v1与v2，求出v1与v2格上最小的向量，即为（f，g） EXP 1234567891011q = 7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257h = 2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800e = 5605696495253720664142881956908624307570671858477482119657436163663663844731169035682344974286379049123733356009125671924280312532755241162267269123486523u = np.array([1,h])v = np.array([0,q])gauss_reduction(u,v)f = 47251817614431369468151088301948722761694622606220578981561236563325808178756g = 43997957885147078115851147456370880089696256470389782348293341937915504254589m = decrypt(q,h,f,g,e)print(long_to_bytes(m))#crypto&#123;Gauss_lattice_attack!&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"lattice","slug":"lattice","permalink":"https://sch01ar.github.io/tags/lattice/"}]},{"title":"二叉树建立与遍历","slug":"二叉树建立与遍历","date":"2022-11-09T16:00:00.000Z","updated":"2022-12-01T05:15:01.487Z","comments":true,"path":"2022/11/10/二叉树建立与遍历/","link":"","permalink":"https://sch01ar.github.io/2022/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/","excerpt":"","text":"网上很多算法通过直接将二叉树结点连接，从而构成二叉树，这里我构建了一个二叉树类，通过用户控制输入来建立二叉树。 有层序遍历，递归、非递归的前序遍历、中序遍历、后序遍历算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;using namespace std;class Binarytreenode&#123; public: int data; Binarytreenode *leftchild; Binarytreenode *rightchild; Binarytreenode()&#123;&#125;; Binarytreenode(const int &amp;a,Binarytreenode *l=NULL,Binarytreenode*r=NULL) &#123; this-&gt;data=a; this-&gt;leftchild=l; this-&gt;rightchild=r; &#125;&#125;;class BinaryTree&#123; private: public: Binarytreenode *root; BinaryTree()&#123;root =new Binarytreenode;&#125;; ~BinaryTree()&#123;delete[]root;&#125; void visit(Binarytreenode*t) &#123; cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;; &#125; Binarytreenode* creatTree(Binarytreenode* temp) &#123; int n; cout&lt;&lt;&quot;请输入2叉树结点的值,输入-1以表示停止创建某子树&quot;&lt;&lt;endl; cin&gt;&gt;n; if(n==-1) &#123; return NULL; &#125; else&#123; temp = new Binarytreenode; temp-&gt;data=n; temp-&gt;leftchild=creatTree(temp-&gt;leftchild); temp-&gt;rightchild=creatTree(temp-&gt;rightchild); &#125; root=temp; return root; &#125; void levelOrder() &#123; queue &lt;Binarytreenode *&gt; nodeQueue; Binarytreenode *p=root; if (p) nodeQueue.push(p); while(!nodeQueue.empty()) &#123; p=nodeQueue.front(); visit(p); nodeQueue.pop(); if (p-&gt;leftchild) &#123; nodeQueue.push(p-&gt;leftchild); &#125; if (p-&gt;rightchild) &#123; nodeQueue.push(p-&gt;rightchild); &#125; &#125; &#125; void preOrder0(Binarytreenode *root)//先序递归 &#123; if (root!=NULL) &#123; visit(root); preOrder0(root-&gt;leftchild); preOrder0(root-&gt;rightchild); &#125; &#125; void inOrder0(Binarytreenode *root)//中序递归 &#123; if (root!=NULL) &#123; inOrder0(root-&gt;leftchild); visit(root); inOrder0(root-&gt;rightchild); &#125; &#125; void postOrder0(Binarytreenode *root)//后序递归 &#123; if (root!=NULL) &#123; postOrder0(root-&gt;leftchild); postOrder0(root-&gt;rightchild); visit(root); &#125; &#125; void preOrder1(Binarytreenode *root) &#123; stack&lt;Binarytreenode *&gt;nodeStack; Binarytreenode *p=root; while (!nodeStack.empty()||p) &#123; if(p) &#123; visit(p);//先访问当前结点，也就是根 if (p-&gt;rightchild!=NULL)//若右子树不空，则先存到栈中 &#123; nodeStack.push(p-&gt;rightchild); &#125; p=p-&gt;leftchild;//p指向左子树，开始访问。 &#125;else//左子树遍历完毕后，进行弹栈，继续遍历 &#123; p=nodeStack.top(); nodeStack.pop(); &#125; &#125; &#125; void inOrder1(Binarytreenode *root) &#123; stack&lt;Binarytreenode *&gt;nodeStack; Binarytreenode *p=root; while (!nodeStack.empty()||p) &#123; if(p) &#123; nodeStack.push(p);//一路向左全压栈。 p=p-&gt;leftchild; &#125;else &#123; p=nodeStack.top(); visit(p); p=p-&gt;rightchild; nodeStack.pop(); &#125; &#125; &#125; void postOrder1(Binarytreenode *root) &#123; stack&lt;Binarytreenode *&gt;nodeStack; Binarytreenode *p=root; Binarytreenode *pre=root; while (p) &#123; while(p-&gt;leftchild!=NULL)//向左搜索全压栈，直到没有左子树。 &#123; nodeStack.push(p); p=p-&gt;leftchild; &#125; //读取栈顶，访问右子树 while (p!=NULL&amp;&amp; (p-&gt;rightchild==NULL || p-&gt;rightchild==pre)) &#123; visit(p); pre=p; if (nodeStack.empty()) &#123; return; &#125; p=nodeStack.top(); nodeStack.pop(); &#125; nodeStack.push(p); p=p-&gt;rightchild; &#125; &#125;&#125;;int main()&#123; BinaryTree t1; t1.creatTree(t1.root); cout&lt;&lt;&quot;层次遍历:&quot;&lt;&lt;endl; t1.levelOrder(); cout&lt;&lt;endl&lt;&lt;&quot;前序遍历(递归):&quot;&lt;&lt;endl; t1.preOrder0(t1.root); cout&lt;&lt;endl&lt;&lt;&quot;前序遍历(非递归):&quot;&lt;&lt;endl; t1.preOrder1(t1.root); cout&lt;&lt;endl&lt;&lt;&quot;中序遍历(递归):&quot;&lt;&lt;endl; t1.inOrder0(t1.root); cout&lt;&lt;endl&lt;&lt;&quot;中序遍历(非递归):&quot;&lt;&lt;endl; t1.inOrder0(t1.root); cout&lt;&lt;endl&lt;&lt;&quot;后序遍历(递归):&quot;&lt;&lt;endl; t1.postOrder0(t1.root); cout&lt;&lt;endl&lt;&lt;&quot;后序遍历(非递归):&quot;&lt;&lt;endl; t1.postOrder0(t1.root); cout&lt;&lt;endl; return 0;&#125;// 1// 2 3// 4 5 7//输入1 2 4 -1 -1 5 -1 -1 3 -1 7 -1 -1//层序: 1 2 3 4 5 7//前序: 1 2 4 5 3 7//中序: 4 2 5 1 3 7//后序: 4 5 2 7 3 1","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sch01ar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sch01ar.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"2022祥云杯wp-crypto","slug":"2022-10-30-2022祥云杯wp-crypto","date":"2022-10-29T16:00:00.000Z","updated":"2022-12-07T09:43:16.370Z","comments":true,"path":"2022/10/30/2022-10-30-2022祥云杯wp-crypto/","link":"","permalink":"https://sch01ar.github.io/2022/10/30/2022-10-30-2022%E7%A5%A5%E4%BA%91%E6%9D%AFwp-crypto/","excerpt":"","text":"little little fermat 题目源码 1234567891011121314151617181920212223242526272829303132333435from Crypto.Util.number import *from random import *from libnum import *import gmpy2from secret import xflag = b&#x27;?????????&#x27;m = bytes_to_long(flag)def obfuscate(p, k): nbit = p.bit_length() while True: l1 = [getRandomRange(-1, 1) for _ in &#x27;_&#x27; * k] l2 = [getRandomRange(100, nbit) for _ in &#x27;_&#x27; * k] l3 = [getRandomRange(10, nbit//4) for _ in &#x27;_&#x27; * k] l4 = [getRandomRange(2, 6) for _ in &#x27;_&#x27; *k] A = sum([l1[_] * 2 ** ((l2[_]+l3[_])//l4[_]) for _ in range(0, k)]) q = p + A if isPrime(q) * A != 0: return qp = getPrime(512)q = obfuscate(p, 5)e = 65537n = p*qprint(f&#x27;n = &#123;n&#125;&#x27;)assert 114514 ** x % p == 1m = m ^ (x**2)c = pow(m, e, n)print(f&#x27;c = &#123;c&#125;&#x27;)&#x27;&#x27;&#x27;n = 141321067325716426375483506915224930097246865960474155069040176356860707435540270911081589751471783519639996589589495877214497196498978453005154272785048418715013714419926299248566038773669282170912502161620702945933984680880287757862837880474184004082619880793733517191297469980246315623924571332042031367393c = 81368762831358980348757303940178994718818656679774450300533215016117959412236853310026456227434535301960147956843664862777300751319650636299943068620007067063945453310992828498083556205352025638600643137849563080996797888503027153527315524658003251767187427382796451974118362546507788854349086917112114926883&#x27;&#x27;&#x27; 题目分析 根据题目名字来看，此题和费马小定理的使用有关，题目中有一个obfuscate函数，进行了对q的生成，q=p+A，这里可以看一下A的范围，是在2[18,319]之间，因此p、q接近，尝试一下yafu分解。 题目对m先进行了处理，再进行RSA加密，因此我们需要知道x。assert 114514 ** x % p == 1运用费马小定理，若114514与p互素，则x=p-1，即可求解m。 EXP 1234567891011121314151617from Crypto.Util.number import *import gmpy2import mathe=65537n = 141321067325716426375483506915224930097246865960474155069040176356860707435540270911081589751471783519639996589589495877214497196498978453005154272785048418715013714419926299248566038773669282170912502161620702945933984680880287757862837880474184004082619880793733517191297469980246315623924571332042031367393c = 81368762831358980348757303940178994718818656679774450300533215016117959412236853310026456227434535301960147956843664862777300751319650636299943068620007067063945453310992828498083556205352025638600643137849563080996797888503027153527315524658003251767187427382796451974118362546507788854349086917112114926883p = 11887853772894265642834649929578157180848240939084164222334476057487485972806971092902627112665734648016476153593841839977704512156756634066593725142934001q = 11887853772894265642834649929578157180848240939084164222334476057487485972806971092902627112665734646483980612727952939084061619889139517526028673988305393print(math.gcd(p,114514))#1x=p-1phi=(p-1)*(q-1)d=gmpy2.invert(e,phi)m0=pow(c,d,n)m=m0^(x**2)print(long_to_bytes(m))#flag&#123;I~ju5t_w@nt_30_te11_y0u_how_I_@m_f3ll1ng~&#125; fill 题目源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from Crypto.Util.number import *from random import *from gmpy2 import gcdfrom numpy import dotnbits = 32msg = getRandomNBitInteger(nbits)flag = b&#x27;flag&#123;sha256(msg)&#125;&#x27;tmp_m = bin(msg)[2:]f_list = []for i in range(len(tmp_m)): f_list.append(int(tmp_m[i]))r_list =[randint(20, 50)]for i in range(nbits - 1): r_list.append(randint(2 * r_list[-1], 3 * r_list[-1]))while True: A = randint(2 * r_list[-1] + 1, 3 * r_list[-1]) B = randint(2 * r_list[-1] + 1, 3 * r_list[-1]) if gcd(A, B) == 1: breakM = [A * x % B for x in r_list]S = dot(f_list, M)print(S)seed = getRandomNBitInteger(30)s = [0] * nbitss[0] = seedm = getRandomNBitInteger(20)c = getPrime(24)n = 991125622for i in range(1, nbits): s[i] = (s[i-1]*m+c)%nprint(s[0], s[1], s[2])for t in range(nbits): M[t] = M[t] + s[t]print(M)&#x27;&#x27;&#x27;492226042629702562734112 859151551 741682801M = [19621141192340, 39617541681643, 3004946591889, 6231471734951, 3703341368174, 48859912097514, 4386411556216, 11028070476391, 18637548953150, 29985057892414, 20689980879644, 20060557946852, 46908191806199, 8849137870273, 28637782510640, 35930273563752, 20695924342882, 36660291028583, 10923264012354, 29810154308143, 4444597606142, 31802472725414, 23368528779283, 15179021971456, 34642073901253, 44824809996134, 31243873675161, 27159321498211, 2220647072602, 20255746235462, 24667528459211, 46916059974372]&#x27;&#x27;&#x27; 题目分析 随机产生32位的数，sha256()加密后作为flag，并将其2进制的每一位存到了f_list数组中。 又 创建了一个r_list32位数组，里面存着随机数，先暂时不管。 双 对r_list数组中的随机数做了加密，产生了M数组。 对f_list和M数组进行了numpy.dot运算，即向量乘法，得到和为S。 叒 创建了一个s数组，这个很明显，用LCG线性同余算法进行了加密。 最后将M数组与s数组相加。 这就是这道题整体的流程，每一步并不难，只是步骤多，略显复杂。 EXP 0x01 可以先进行一下LCG的求解，把s数组求解出来，从而求出M数组。 1234567891011121314151617n = 991125622output =[562734112,859151551,741682801]MMI = lambda A, n,s=1,t=0,N=0: (n &lt; 2 and t%N or MMI(n, A%n, t, s-A//n*t, N or n),-1)[n&lt;1] #逆元计算a=(output[2]-output[1])*MMI((output[1]-output[0]),n)%nani=MMI(a,n)b=(output[1]-a*output[0])%nseed = 562734112a=55365664b= 8712091s = [0] * nbitss[0] = seedfor i in range(1, nbits): s[i] = (s[i-1]*a+b)%nM = [19621141192340, 39617541681643, 3004946591889, 6231471734951, 3703341368174, 48859912097514, 4386411556216, 11028070476391, 18637548953150, 29985057892414, 20689980879644, 20060557946852, 46908191806199, 8849137870273, 28637782510640, 35930273563752, 20695924342882, 36660291028583, 10923264012354, 29810154308143, 4444597606142, 31802472725414, 23368528779283, 15179021971456, 34642073901253, 44824809996134, 31243873675161, 27159321498211, 2220647072602, 20255746235462, 24667528459211, 46916059974372]for t in range(nbits): M[t] = M[t] - s[t] 0x02 按理来说，感觉应该根据求出来的M数组进行逆运算，求出r_list数组，但是求出来r_list有什么用呢，所以直接尝试求f_list。因为f_list中不是0就是1，与M做向量乘法，即为M数组中若干元素的和。根据题目给定和S，先大概看一下需要M中多少个元素累加。发现在M前21位和 &lt; S，前22位和 &gt; S，所以猜想应该是M当中，除10个左右元素之外的和。 这里就遍历了一下，复杂度实在太高了，也没想着能出，结果还真算出来了o.O 123456789101112131415 for a in range(nbits): for b in range(a,nbits): for c in range(b,nbits): for d in range(c,nbits): for e in range(d,nbits): for f in range(e,nbits): for g in range(f,nbits): for h in range(g,nbits): for i in range(h,nbits): for j in range(i,nbits): for k in range(j,nbits): if M[a]+M[b]+M[c]+M[d]+M[e]+M[f]+M[g] +M[h] + M[i] +M[j] +M[k] == sum-S: print(a,b,c,d,e,f,g,h,i,j,k) break#2 4 9 10 15 19 24 27 28 30 31 也就说明，f_list中下标为这些的，对应值是0，其余为1，即可得到msg的2进制数，转为十进制后进行sha256()加密即可。 12345678f = [&#x27;1&#x27;] * nbitsf[2]=f[4]=f[9]=f[10]=f[15]=f[19]=f[24]=f[27]=f[28]=f[30]=f[31]=&#x27;0&#x27;a=&quot;&quot;for i in range(nbits): a+=f[i]print(int(a,2))#3617517412#sha256加密后：8f504aee71626212f275117326722b6c0ccc94f4039ed31fbcfde08e026352c4，套上flag&#123;&#125;提交即可","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"2022NewStarCTF-flip_flop","slug":"2022NewStarCTF-flip_flop","date":"2022-10-26T16:00:00.000Z","updated":"2022-12-07T09:41:52.644Z","comments":true,"path":"2022/10/27/2022NewStarCTF-flip_flop/","link":"","permalink":"https://sch01ar.github.io/2022/10/27/2022NewStarCTF-flip_flop/","excerpt":"","text":"flip-flop AES-CBC加密模式 题目 源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import osfrom Crypto.Cipher import AESfrom secret import FLAGauth_major_key = os.urandom(16)BANNER = &quot;&quot;&quot;Login as admin to get the flag ! &quot;&quot;&quot;MENU = &quot;&quot;&quot;Enter your choice[1] Create NewStarCTF Account[2] Create Admin Account[3] Login[4] Exit&quot;&quot;&quot;print(BANNER)while True: print(MENU) option = int(input(&#x27;&gt; &#x27;)) if option == 1: auth_pt = b&#x27;NewStarCTFer____&#x27; user_key = os.urandom(16) cipher = AES.new(auth_major_key, AES.MODE_CBC, user_key) code = cipher.encrypt(auth_pt) print(f&#x27;here is your authcode: &#123;user_key.hex() + code.hex()&#125;&#x27;) elif option == 2: print(&#x27;GET OUT !!!!!!&#x27;) elif option == 3: authcode = input(&#x27;Enter your authcode &gt; &#x27;) user_key = bytes.fromhex(authcode)[:16] code = bytes.fromhex(authcode)[16:] cipher = AES.new(auth_major_key, AES.MODE_CBC, user_key) auth_pt = cipher.decrypt(code) if auth_pt == b&#x27;AdminAdmin______&#x27;: print(FLAG) elif auth_pt == b&#x27;NewStarCTFer____&#x27;: print(&#x27;Have fun!!&#x27;) else: print(&#x27;Who are you?&#x27;) elif option == 4: print(&#x27;ByeBye&#x27;) exit(0) else: print(&quot;WTF&quot;) ## 题目分析 此题是通过注册得到的用户账户的密文，然后输入管理员账户对应的密文，才能得到flag。 对用户账户和管理员账户的加密解密均采用AES-CBC模式，但是本题仅有一组明文，iv仅作为偏移量，也就是本题中的user_key。 这里先来说一下我最一开始的思路，由于user_key每次是随机产生的，但是一次程序的运行当中是不变的。由于密文由两部分组成，前半部分为user_key.hex()，后半部分为code.hex()，所以只要构造出admin对应的code即可，那么就需要AES加密当中的key，所以就需要构造一个key来产生出admin对应的code。查询了很多资料发现都难以实现。于是…… 那为什么不换一下思路？不能构造code，能不能构造iv？ 先来看一下加密方式： C = encrypt(M ^ iv) M = decrypt(C)^iv 对应一下本题当中的NewStarCTFer和admin： b'NewStarCTFer____' = decrypt(code) ^ iv1 b'AdminAdmin______' = decrypt(code) ^ iv2 因此可求出admin对应的iv2，随后拼接上普通用户的后半段code即可。 EXP 12345678910from Crypto.Util.number import *authcode= &quot;4f72b2079005a15e30efb3febea8cda266f4c3b47147e79167c3cde81ca84a4b&quot;n=bytes_to_long(b&#x27;NewStarCTFer____&#x27;)a=bytes_to_long(b&#x27;AdminAdmin______&#x27;)iv1= int(authcode[:len(authcode)//2],16)code = authcode[len(authcode)//2:]decode = iv1 ^ niv2 = a ^ decodeprint((hex(iv2)+code)[2:])#flag&#123;filp_the_word!!!!!!!!&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"BUU刷题日记20221026","slug":"BUU刷题日记20221026","date":"2022-10-25T16:00:00.000Z","updated":"2022-12-07T09:39:19.641Z","comments":true,"path":"2022/10/26/BUU刷题日记20221026/","link":"","permalink":"https://sch01ar.github.io/2022/10/26/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221026/","excerpt":"","text":"RSA5 题目分析 给定e=65537 给了很多组n、c 由于e过大，所以不考虑使用CRT，由于m是同一个，因此遍历一下，求出两个n的最大公约数，即为p，后续就简单了。 EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677n1 = 20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207c1 = 974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320n2 = 20918819960648891349438263046954902210959146407860980742165930253781318759285692492511475263234242002509419079545644051755251311392635763412553499744506421566074721268822337321637265942226790343839856182100575539845358877493718334237585821263388181126545189723429262149630651289446553402190531135520836104217160268349688525168375213462570213612845898989694324269410202496871688649978370284661017399056903931840656757330859626183773396574056413017367606446540199973155630466239453637232936904063706551160650295031273385619470740593510267285957905801566362502262757750629162937373721291789527659531499435235261620309759c2 = 15819636201971185538694880505120469332582151856714070824521803121848292387556864177196229718923770810072104155432038682511434979353089791861087415144087855679134383396897817458726543883093567600325204596156649305930352575274039425470836355002691145864435755333821133969266951545158052745938252574301327696822347115053614052423028835532509220641378760800693351542633860702225772638930501021571415907348128269681224178300248272689705308911282208685459668200507057183420662959113956077584781737983254788703048275698921427029884282557468334399677849962342196140864403989162117738206246183665814938783122909930082802031855n3 = 25033254625906757272369609119214202033162128625171246436639570615263949157363273213121556825878737923265290579551873824374870957467163989542063489416636713654642486717219231225074115269684119428086352535471683359486248203644461465935500517901513233739152882943010177276545128308412934555830087776128355125932914846459470221102007666912211992310538890654396487111705385730502843589727289829692152177134753098649781412247065660637826282055169991824099110916576856188876975621376606634258927784025787142263367152947108720757222446686415627479703666031871635656314282727051189190889008763055811680040315277078928068816491c3 = 4185308529416874005831230781014092407198451385955677399668501833902623478395669279404883990725184332709152443372583701076198786635291739356770857286702107156730020004358955622511061410661058982622055199736820808203841446796305284394651714430918690389486920560834672316158146453183789412140939029029324756035358081754426645160033262924330248675216108270980157049705488620263485129480952814764002865280019185127662449318324279383277766416258142275143923532168798413011028271543085249029048997452212503111742302302065401051458066585395360468447460658672952851643547193822775218387853623453638025492389122204507555908862n4 = 21206968097314131007183427944486801953583151151443627943113736996776787181111063957960698092696800555044199156765677935373149598221184792286812213294617749834607696302116136745662816658117055427803315230042700695125718401646810484873064775005221089174056824724922160855810527236751389605017579545235876864998419873065217294820244730785120525126565815560229001887622837549118168081685183371092395128598125004730268910276024806808565802081366898904032509920453785997056150497645234925528883879419642189109649009132381586673390027614766605038951015853086721168018787523459264932165046816881682774229243688581614306480751c4 = 4521038011044758441891128468467233088493885750850588985708519911154778090597136126150289041893454126674468141393472662337350361712212694867311622970440707727941113263832357173141775855227973742571088974593476302084111770625764222838366277559560887042948859892138551472680654517814916609279748365580610712259856677740518477086531592233107175470068291903607505799432931989663707477017904611426213770238397005743730386080031955694158466558475599751940245039167629126576784024482348452868313417471542956778285567779435940267140679906686531862467627238401003459101637191297209422470388121802536569761414457618258343550613n5 = 22822039733049388110936778173014765663663303811791283234361230649775805923902173438553927805407463106104699773994158375704033093471761387799852168337898526980521753614307899669015931387819927421875316304591521901592823814417756447695701045846773508629371397013053684553042185725059996791532391626429712416994990889693732805181947970071429309599614973772736556299404246424791660679253884940021728846906344198854779191951739719342908761330661910477119933428550774242910420952496929605686154799487839923424336353747442153571678064520763149793294360787821751703543288696726923909670396821551053048035619499706391118145067c5 = 15406498580761780108625891878008526815145372096234083936681442225155097299264808624358826686906535594853622687379268969468433072388149786607395396424104318820879443743112358706546753935215756078345959375299650718555759698887852318017597503074317356745122514481807843745626429797861463012940172797612589031686718185390345389295851075279278516147076602270178540690147808314172798987497259330037810328523464851895621851859027823681655934104713689539848047163088666896473665500158179046196538210778897730209572708430067658411755959866033531700460551556380993982706171848970460224304996455600503982223448904878212849412357n6 = 21574139855341432908474064784318462018475296809327285532337706940126942575349507668289214078026102682252713757703081553093108823214063791518482289846780197329821139507974763780260290309600884920811959842925540583967085670848765317877441480914852329276375776405689784571404635852204097622600656222714808541872252335877037561388406257181715278766652824786376262249274960467193961956690974853679795249158751078422296580367506219719738762159965958877806187461070689071290948181949561254144310776943334859775121650186245846031720507944987838489723127897223416802436021278671237227993686791944711422345000479751187704426369c6 = 20366856150710305124583065375297661819795242238376485264951185336996083744604593418983336285185491197426018595031444652123288461491879021096028203694136683203441692987069563513026001861435722117985559909692670907347563594578265880806540396777223906955491026286843168637367593400342814725694366078337030937104035993569672959361347287894143027186846856772983058328919716702982222142848848117768499996617588305301483085428547267337070998767412540225911508196842253134355901263861121500650240296746702967594224401650220168780537141654489215019142122284308116284129004257364769474080721001708734051264841350424152506027932n7 = 25360227412666612490102161131174584819240931803196448481224305250583841439581008528535930814167338381983764991296575637231916547647970573758269411168219302370541684789125112505021148506809643081950237623703181025696585998044695691322012183660424636496897073045557400768745943787342548267386564625462143150176113656264450210023925571945961405709276631990731602198104287528528055650050486159837612279600415259486306154947514005408907590083747758953115486124865486720633820559135063440942528031402951958557630833503775112010715604278114325528993771081233535247118481765852273252404963430792898948219539473312462979849137c7 = 19892772524651452341027595619482734356243435671592398172680379981502759695784087900669089919987705675899945658648623800090272599154590123082189645021800958076861518397325439521139995652026377132368232502108620033400051346127757698623886142621793423225749240286511666556091787851683978017506983310073524398287279737680091787333547538239920607761080988243639547570818363788673249582783015475682109984715293163137324439862838574460108793714172603672477766831356411304446881998674779501188163600664488032943639694828698984739492200699684462748922883550002652913518229322945040819064133350314536378694523704793396169065179n8 = 22726855244632356029159691753451822163331519237547639938779517751496498713174588935566576167329576494790219360727877166074136496129927296296996970048082870488804456564986667129388136556137013346228118981936899510687589585286517151323048293150257036847475424044378109168179412287889340596394755257704938006162677656581509375471102546261355748251869048003600520034656264521931808651038524134185732929570384705918563982065684145766427962502261522481994191989820110575981906998431553107525542001187655703534683231777988419268338249547641335718393312295800044734534761692799403469497954062897856299031257454735945867491191c8 = 6040119795175856407541082360023532204614723858688636724822712717572759793960246341800308149739809871234313049629732934797569781053000686185666374833978403290525072598774001731350244744590772795701065129561898116576499984185920661271123665356132719193665474235596884239108030605882777868856122378222681140570519180321286976947154042272622411303981011302586225630859892731724640574658125478287115198406253847367979883768000812605395482952698689604477719478947595442185921480652637868335673233200662100621025061500895729605305665864693122952557361871523165300206070325660353095592778037767395360329231331322823610060006n9 = 23297333791443053297363000786835336095252290818461950054542658327484507406594632785712767459958917943095522594228205423428207345128899745800927319147257669773812669542782839237744305180098276578841929496345963997512244219376701787616046235397139381894837435562662591060768476997333538748065294033141610502252325292801816812268934171361934399951548627267791401089703937389012586581080223313060159456238857080740699528666411303029934807011214953984169785844714159627792016926490955282697877141614638806397689306795328344778478692084754216753425842557818899467945102646776342655167655384224860504086083147841252232760941c9 = 5418120301208378713115889465579964257871814114515046096090960159737859076829258516920361577853903925954198406843757303687557848302302200229295916902430205737843601806700738234756698575708612424928480440868739120075888681672062206529156566421276611107802917418993625029690627196813830326369874249777619239603300605876865967515719079797115910578653562787899019310139945904958024882417833736304894765433489476234575356755275147256577387022873348906900149634940747104513850154118106991137072643308620284663108283052245750945228995387803432128842152251549292698947407663643895853432650029352092018372834457054271102816934n10 = 28873667904715682722987234293493200306976947898711255064125115933666968678742598858722431426218914462903521596341771131695619382266194233561677824357379805303885993804266436810606263022097900266975250431575654686915049693091467864820512767070713267708993899899011156106766178906700336111712803362113039613548672937053397875663144794018087017731949087794894903737682383916173267421403408140967713071026001874733487295007501068871044649170615709891451856792232315526696220161842742664778581287321318748202431466508948902745314372299799561625186955234673012098210919745879882268512656931714326782335211089576897310591491c10 = 9919880463786836684987957979091527477471444996392375244075527841865509160181666543016317634963512437510324198702416322841377489417029572388474450075801462996825244657530286107428186354172836716502817609070590929769261932324275353289939302536440310628698349244872064005700644520223727670950787924296004296883032978941200883362653993351638545860207179022472492671256630427228461852668118035317021428675954874947015197745916918197725121122236369382741533983023462255913924692806249387449016629865823316402366017657844166919846683497851842388058283856219900535567427103603869955066193425501385255322097901531402103883869n11 = 22324685947539653722499932469409607533065419157347813961958075689047690465266404384199483683908594787312445528159635527833904475801890381455653807265501217328757871352731293000303438205315816792663917579066674842307743845261771032363928568844669895768092515658328756229245837025261744260614860746997931503548788509983868038349720225305730985576293675269073709022350700836510054067641753713212999954307022524495885583361707378513742162566339010134354907863733205921845038918224463903789841881400814074587261720283879760122070901466517118265422863420376921536734845502100251460872499122236686832189549698020737176683019c11 = 1491527050203294989882829248560395184804977277747126143103957219164624187528441047837351263580440686474767380464005540264627910126483129930668344095814547592115061057843470131498075060420395111008619027199037019925701236660166563068245683975787762804359520164701691690916482591026138582705558246869496162759780878437137960823000043988227303003876410503121370163303711603359430764539337597866862508451528158285103251810058741879687875218384160282506172706613359477657215420734816049393339593755489218588796607060261897905233453268671411610631047340459487937479511933450369462213795738933019001471803157607791738538467n12 = 27646746423759020111007828653264027999257847645666129907789026054594393648800236117046769112762641778865620892443423100189619327585811384883515424918752749559627553637785037359639801125213256163008431942593727931931898199727552768626775618479833029101249692573716030706695702510982283555740851047022672485743432464647772882314215176114732257497240284164016914018689044557218920300262234652840632406067273375269301008409860193180822366735877288205783314326102263756503786736122321348320031950012144905869556204017430593656052867939493633163499580242224763404338807022510136217187779084917996171602737036564991036724299c12 = 21991524128957260536043771284854920393105808126700128222125856775506885721971193109361315961129190814674647136464887087893990660894961612838205086401018885457667488911898654270235561980111174603323721280911197488286585269356849579263043456316319476495888696219344219866516861187654180509247881251251278919346267129904739277386289240394384575124331135655943513831009934023397457082184699737734388823763306805326430395849935770213817533387235486307008892410920611669932693018165569417445885810825749609388627231235840912644654685819620931663346297596334834498661789016450371769203650109994771872404185770230172934013971n13 = 20545487405816928731738988374475012686827933709789784391855706835136270270933401203019329136937650878386117187776530639342572123237188053978622697282521473917978282830432161153221216194169879669541998840691383025487220850872075436064308499924958517979727954402965612196081404341651517326364041519250125036424822634354268773895465698920883439222996581226358595873993976604699830613932320720554130011671297944433515047180565484495191003887599891289037982010216357831078328159028953222056918189365840711588671093333013117454034313622855082795813122338562446223041211192277089225078324682108033843023903550172891959673551c13 = 14227439188191029461250476692790539654619199888487319429114414557975376308688908028140817157205579804059783807641305577385724758530138514972962209062230576107406142402603484375626077345190883094097636019771377866339531511965136650567412363889183159616188449263752475328663245311059988337996047359263288837436305588848044572937759424466586870280512424336807064729894515840552404756879590698797046333336445465120445087587621743906624279621779634772378802959109714400516183718323267273824736540168545946444437586299214110424738159957388350785999348535171553569373088251552712391288365295267665691357719616011613628772175n14 = 27359727711584277234897157724055852794019216845229798938655814269460046384353568138598567755392559653460949444557879120040796798142218939251844762461270251672399546774067275348291003962551964648742053215424620256999345448398805278592777049668281558312871773979931343097806878701114056030041506690476954254006592555275342579529625231194321357904668512121539514880704046969974898412095675082585315458267591016734924646294357666924293908418345508902112711075232047998775303603175363964055048589769318562104883659754974955561725694779754279606726358588862479198815999276839234952142017210593887371950645418417355912567987c14 = 3788529784248255027081674540877016372807848222776887920453488878247137930578296797437647922494510483767651150492933356093288965943741570268943861987024276610712717409139946409513963043114463933146088430004237747163422802959250296602570649363016151581364006795894226599584708072582696996740518887606785460775851029814280359385763091078902301957226484620428513604630585131511167015763190591225884202772840456563643159507805711004113901417503751181050823638207803533111429510911616160851391754754434764819568054850823810901159821297849790005646102129354035735350124476838786661542089045509656910348676742844957008857457n15 = 27545937603751737248785220891735796468973329738076209144079921449967292572349424539010502287564030116831261268197384650511043068738911429169730640135947800885987171539267214611907687570587001933829208655100828045651391618089603288456570334500533178695238407684702251252671579371018651675054368606282524673369983034682330578308769886456335818733827237294570476853673552685361689144261552895758266522393004116017849397346259119221063821663280935820440671825601452417487330105280889520007917979115568067161590058277418371493228631232457972494285014767469893647892888681433965857496916110704944758070268626897045014782837c15 = 14069112970608895732417039977542732665796601893762401500878786871680645798754783315693511261740059725171342404186571066972546332813667711135661176659424619936101038903439144294886379322591635766682645179888058617577572409307484708171144488708410543462972008179994594087473935638026612679389759756811490524127195628741262871304427908481214992471182859308828778119005750928935764927967212343526503410515793717201360360437981322576798056276657140363332700714732224848346808963992302409037706094588964170239521193589470070839790404597252990818583717869140229811712295005710540476356743378906642267045723633874011649259842n16 = 25746162075697911560263181791216433062574178572424600336856278176112733054431463253903433128232709054141607100891177804285813783247735063753406524678030561284491481221681954564804141454666928657549670266775659862814924386584148785453647316864935942772919140563506305666207816897601862713092809234429096584753263707828899780979223118181009293655563146526792388913462557306433664296966331469906428665127438829399703002867800269947855869262036714256550075520193125987011945192273531732276641728008406855871598678936585324782438668746810516660152018244253008092470066555687277138937298747951929576231036251316270602513451c16 = 17344284860275489477491525819922855326792275128719709401292545608122859829827462088390044612234967551682879954301458425842831995513832410355328065562098763660326163262033200347338773439095709944202252494552172589503915965931524326523663289777583152664722241920800537867331030623906674081852296232306336271542832728410803631170229642717524942332390842467035143631504401140727083270732464237443915263865880580308776111219718961746378842924644142127243573824972533819479079381023103585862099063382129757560124074676150622288706094110075567706403442920696472627797607697962873026112240527498308535903232663939028587036724n17 = 23288486934117120315036919418588136227028485494137930196323715336208849327833965693894670567217971727921243839129969128783853015760155446770590696037582684845937132790047363216362087277861336964760890214059732779383020349204803205725870225429985939570141508220041286857810048164696707018663758416807708910671477407366098883430811861933014973409390179948577712579749352299440310543689035651465399867908428885541237776143404376333442949397063249223702355051571790555151203866821867908531733788784978667478707672984539512431549558672467752712004519300318999208102076732501412589104904734983789895358753664077486894529499c17 = 10738254418114076548071448844964046468141621740603214384986354189105236977071001429271560636428075970459890958274941762528116445171161040040833357876134689749846940052619392750394683504816081193432350669452446113285638982551762586656329109007214019944975816434827768882704630460001209452239162896576191876324662333153835533956600295255158377025198426950944040643235430211011063586032467724329735785947372051759042138171054165854842472990583800899984893232549092766400510300083585513014171220423103452292891496141806956300396540682381668367564569427813092064053993103537635994311143010708814851867239706492577203899024n18 = 19591441383958529435598729113936346657001352578357909347657257239777540424811749817783061233235817916560689138344041497732749011519736303038986277394036718790971374656832741054547056417771501234494768509780369075443550907847298246275717420562375114406055733620258777905222169702036494045086017381084272496162770259955811174440490126514747876661317750649488774992348005044389081101686016446219264069971370646319546429782904810063020324704138495608761532563310699753322444871060383693044481932265801505819646998535192083036872551683405766123968487907648980900712118052346174533513978009131757167547595857552370586353973c18= 3834917098887202931981968704659119341624432294759361919553937551053499607440333234018189141970246302299385742548278589896033282894981200353270637127213483172182529890495903425649116755901631101665876301799865612717750360089085179142750664603454193642053016384714515855868368723508922271767190285521137785688075622832924829248362774476456232826885801046969384519549385428259591566716890844604696258783639390854153039329480726205147199247183621535172450825979047132495439603840806501254997167051142427157381799890725323765558803808030109468048682252028720241357478614704610089120810367192414352034177484688502364022887n19 = 19254242571588430171308191757871261075358521158624745702744057556054652332495961196795369630484782930292003238730267396462491733557715379956969694238267908985251699834707734400775311452868924330866502429576951934279223234676654749272932769107390976321208605516299532560054081301829440688796904635446986081691156842271268059970762004259219036753174909942343204432795076377432107630203621754552804124408792358220071862369443201584155711893388877350138023238624566616551246804054720492816226651467017802504094070614892556444425915920269485861799532473383304622064493223627552558344088839860178294589481899206318863310603c19 = 6790553533991297205804561991225493105312398825187682250780197510784765226429663284220400480563039341938599783346724051076211265663468643826430109013245014035811178295081939958687087477312867720289964506097819762095244479129359998867671811819738196687884696680463458661374310994610760009474264115750204920875527434486437536623589684519411519100170291423367424938566820315486507444202022408003879118465761273916755290898112991525546114191064022991329724370064632569903856189236177894007766690782630247443895358893983735822824243487181851098787271270256780891094405121947631088729917398317652320497765101790132679171889n20 = 26809700251171279102974962949184411136459372267620535198421449833298448092580497485301953796619185339316064387798092220298630428207556482805739803420279056191194360049651767412572609187680508073074653291350998253938793269214230457117194434853888765303403385824786231859450351212449404870776320297419712486574804794325602760347306432927281716160368830187944940128907971027838510079519466846176106565164730963988892400240063089397720414921398936399927948235195085202171264728816184532651138221862240969655185596628285814057082448321749567943946273776184657698104465062749244327092588237927996419620170254423837876806659c20 = 386213556608434013769864727123879412041991271528990528548507451210692618986652870424632219424601677524265011043146748309774067894985069288067952546139416819404039688454756044862784630882833496090822568580572859029800646671301748901528132153712913301179254879877441322285914544974519727307311002330350534857867516466612474769753577858660075830592891403551867246057397839688329172530177187042229028685862036140779065771061933528137423019407311473581832405899089709251747002788032002094495379614686544672969073249309703482556386024622814731015767810042969813752548617464974915714425595351940266077021672409858645427346n=[n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19,n20]import mathimport gmpy2from Crypto.Util.number import long_to_bytesfor i in range(20): for j in range(i+1,20): if math.gcd(n[i],n[j]) &gt; 1: p=math.gcd(n[i],n[j]) print(i,j,p) break#i=4,j=17e=65537q = n[4]// pphi4=(p-1)*(q-1)d=gmpy2.invert(e,phi4)m=pow(c5,d,n[4])print(long_to_bytes(m))# b&#x27;flag&#123;abdcbe5fd94e23b3de429223ab9c2fdf&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"2022 DASCTF 10月挑战赛wp","slug":"2022DASCTF10月挑战赛wp","date":"2022-10-22T16:00:00.000Z","updated":"2022-12-07T09:42:51.960Z","comments":true,"path":"2022/10/23/2022DASCTF10月挑战赛wp/","link":"","permalink":"https://sch01ar.github.io/2022/10/23/2022DASCTF10%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwp/","excerpt":"","text":"RSA 题目如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from Crypto.Util.number import *from secret import flagn_2 = 675835056744450121024004008337170937331109883435712066354955474563267257037603081555653829598886559337325172694278764741403348512872239277008719548968016702852609803016353158454788807563316656327979897318887566108985783153878668451688372252234938716250621575338314779485058267785731636967957494369458211599823364746908763588582489400785865427060804408606617016267936273888743392372620816053927031794575978032607311497491069242347165424963308662091557862342478844612402720375931726316909635118113432836702120449010n_3 = 91294511667572917673898699346231897684542006136956966126836916292947639514392684487940336406038086150289315439796780158189004157494824987037667065310517044311794725172075653186677331434123198117797575528982908532086038107428540586044471407073066169603930082133459486076777574046803264038780927350142555712567e_1 = 65537e_2 = 3c_1 = 47029848959680138397125259006172340325269302342762903311733700258745280761154948381409328053449580957972265859283407071931484707002138926840483316880087281153554181290481533c_2 = 332431c_3 = 11951299411967534922967467740790967733301092706094553308467975774492025797106594440070380723007894861454249455013202734019215071856834943490096156048504952328784989777263664832098681831398770963056616417301705739505187754236801407014715780468333977293887519001724078504320344074325196167699818117367329779609m = 9530454742891231590945778054072843874837824815724564463369259282490619049557772650832818763768769359762168560563265763313176741847581931364k = 8139616873420730499092246564709331937498029453340099806219977060224838957080870950877930756958455278369862703151353509623205172658012437573652818022676431def encrypt1(n): n1 = hex(n&gt;&gt;200).encode() n2 = str(hex(n))[20:].encode() return n1,n2def encrypt2(m , n_1): c_1 = pow(m,e_1,n_1) print(&#x27;c_1 = &#x27;+str(c_1))def encrypt3(m , n_2): c_2 = pow( m , e_2 , n_2) print(&#x27;c_2 = &#x27;+str(c_2))def encrypt4(m): k = getPrime(512) m = m % k c_3 = pow(m, e_2, n_3) print(&#x27;c_3 = &#x27; + str(c_3)) print(&#x27;m = &#x27; + str(m)) print(&#x27;k = &#x27; + str(k))m1,m2 = encrypt1(flag)m1 = bytes_to_long(m1)m2 = bytes_to_long(m2)print(&#x27;n_2 = &#x27; + str(n_2))print(&#x27;n_3 = &#x27; + str(n_3))print(&#x27;e_1 = &#x27; + str(e_1))print(&#x27;e_2 = &#x27; + str(e_2))encrypt2(m1,n_1)encrypt3(n_1,n_2)encrypt4(m2) 题目分析 该题的加密顺序是： 1、加密flag，分为两部分m1、m2 2、加密m1 3、加密m2 同理我们解密的顺序应该也是 1、解出m1、m2 2、解出flag 求m2 先观察一下encrypt4函数 虽然说e_2=3，按理来说使用低加密指数攻击，但并不可行。 又因为m = m % k 可通过这点和c_3 = pow(m, e_2, n_3)做遍历求出m 最后发现m即为m2，m2 &lt; k 求m1 发现m1加密方式采用RSA，但是n_1未知 n_1又通过一次RSA加密，已知n_1对应的密文 利用低加密指数攻击解出n1 发现n1可分解为3个素数乘积 故phi可求，即求出m1 求flag 观察encryt1 m1是flag右移200位之后转为字节 m2是flag的20位之后转成字节 所以来说m2是没什么问题，主要找到flag的前20位，再把m2拼到后面即可。 由于m1是flag右移200位，因此flag的低位缺失，但高位还在，由于不知道flag总长度，抱着试一试的心态，猜测一下它的高位前20位没有缺失 我们将m1和m2转为字节发现 m1:b'0x666c61677b3230366538353964' m2:b'383539643865383534633466363030636231323735376262663966357d' 发现m1和m2有重叠部分，即38353开始 可以证实m1前20位确实没有缺失 因此取m1前20位，加m2，即可解出flag EXP 1234567891011121314151617181920212223242526272829303132333435363738394041import mathfrom typing import ByteStringimport gmpy2from Crypto.Util.number import *n_2 = 675835056744450121024004008337170937331109883435712066354955474563267257037603081555653829598886559337325172694278764741403348512872239277008719548968016702852609803016353158454788807563316656327979897318887566108985783153878668451688372252234938716250621575338314779485058267785731636967957494369458211599823364746908763588582489400785865427060804408606617016267936273888743392372620816053927031794575978032607311497491069242347165424963308662091557862342478844612402720375931726316909635118113432836702120449010e_2=3c_1 = 47029848959680138397125259006172340325269302342762903311733700258745280761154948381409328053449580957972265859283407071931484707002138926840483316880087281153554181290481533c_2 = 332431def dec(c,e,n): i=0 while(1): m1=c+n*i result,flag=gmpy2.iroot(m1,e) if flag==True: return result i+=1n_1=70406706457855863712635967741447303613971473150228480705119773604469794649140239446237334040048504811343327173817296308781190911727763110615393368497803655390445303946160971p_1=2732337821e_1 = 65537t_1=2224243981q_1=11585031296201346891716939633970482508158508580350404805965250133832632323150440185890235814142601827544669601048550999405490149435265122374459158586377571phi_1=(p_1-1)*(q_1-1)*(t_1-1)d_1=gmpy2.invert(e_1,phi_1)m1=pow(c_1,d_1,n_1)c=pow(m1,e_1,n_1)n_3 = 91294511667572917673898699346231897684542006136956966126836916292947639514392684487940336406038086150289315439796780158189004157494824987037667065310517044311794725172075653186677331434123198117797575528982908532086038107428540586044471407073066169603930082133459486076777574046803264038780927350142555712567c_3 = 11951299411967534922967467740790967733301092706094553308467975774492025797106594440070380723007894861454249455013202734019215071856834943490096156048504952328784989777263664832098681831398770963056616417301705739505187754236801407014715780468333977293887519001724078504320344074325196167699818117367329779609m = 9530454742891231590945778054072843874837824815724564463369259282490619049557772650832818763768769359762168560563265763313176741847581931364k = 8139616873420730499092246564709331937498029453340099806219977060224838957080870950877930756958455278369862703151353509623205172658012437573652818022676431m2=long_to_bytes(m)print(m2)print(long_to_bytes(m1)[:20])m=0x666c61677b32303665383539643865383534633466363030636231323735376262663966357dprint(long_to_bytes(m))# b&#x27;383539643865383534633466363030636231323735376262663966357d&#x27;# b&#x27;0x666c61677b32303665&#x27;# b&#x27;flag&#123;206e859d8e854c4f600cb12757bbf9f5&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"BUU刷题日记20221022","slug":"BUU刷题日记20221022","date":"2022-10-21T16:00:00.000Z","updated":"2022-12-07T09:40:10.592Z","comments":true,"path":"2022/10/22/BUU刷题日记20221022/","link":"","permalink":"https://sch01ar.github.io/2022/10/22/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221022/","excerpt":"","text":"RSA4 题目只给了三组n、c，采用中国剩余定理，具体推导如下 推导过程 me ≡ c1 mod n1 me ≡ c2 mod n2 me ≡ c3 mod n3 中国剩余定理（CRT） 中国剩余定理的内容是： 针对上述方程组，若n1、n2、n3互质，对于任意的c1、c2、c3，方程组都有解，使用条件是m^e &lt; n1、n2、n3。通解形式如下： 令N = n1 * n2 * n3，N1 = N/n1，N2、N3同理 令t1 = N1(-1)，即其对应的模n1运算的逆元，t2，t3同理，可用t1=gmpy2.invert(N1,n1)表示。 有了Ni和ti的定义，我们就可以给出通解形式： x = c1 * N1 * t1 …… 有了通解公式我们就可以求出m^e，对e进行一下遍历即可，m开方成功即可。 EXP 123456789101112131415161718192021222324252627import gmpy2from sympy.ntheory.modular import crtfrom Crypto.Util.number import long_to_bytese = 3n1 = &#x27;331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004&#x27;c1 = &#x27;310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243&#x27;n2 = &#x27;302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114&#x27;c2 = &#x27;112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344&#x27;n3 = &#x27;332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323&#x27;c3 = &#x27;10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242&#x27;c1=int(c1,5)n1=int(n1,5)c2=int(c2,5)n2=int(n2,5)c3=int(c3,5)n3=int(n3,5)e=3n=[n1,n2,n3]c=[c1,c2,c3]resultant,mod= crt(n, c)# 有现成的库函数可以调用print(gmpy2.iroot(resultant, e))m=259362307225540148883586283191025214233097658309244310540770399135748418469298031742173624766441014006294782333print(long_to_bytes(m))#noxCTF&#123;D4mn_y0u_h4s74d_wh47_4_b100dy_b4s74rd!&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"BUU刷题日记20221021","slug":"BUU刷题日记20221021","date":"2022-10-20T16:00:00.000Z","updated":"2022-12-08T05:42:21.849Z","comments":true,"path":"2022/10/21/BUU刷题日记20221021/","link":"","permalink":"https://sch01ar.github.io/2022/10/21/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221021/","excerpt":"","text":"RSA2 题目给定n、e、dp、c 非预期解：直接分解n 下面考虑n不能分解的情况 推导过程 dp ≡ d mod (p-1) ed ≡ 1 mod (p-1) * (q-1) ed = 1 + k2(p-1)(q-1) 对1式两端同乘e，得 e * dp ≡ ed mod (p-1) e * dp = k1(p-1) + ed 代入ed得 e * dp = k1(p-1) + 1 + k2(p-1)(q-1) 由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余p-1，即可消掉n e * dp ≡ 1 mod (p-1) e * dp =k(p-1) + 1 得到这个式子后，其实真正意义上的未知数只有我们要求的p，但是还存在一个k。 针对k，我们判断一下他的范围，看看能否采用爆破的方式。 k = (e * dp - 1)/(p-1) 因为dp &lt; p-1 所以k &lt; e 通过遍历k然后找到(e * dp - 1)可以整除k的情况即可。 (跑了一下发现限制条件还不够) 因此再加一个n能否整除p即可。 EXP 1234567891011121314151617181920import gmpy2from Crypto.Util.number import long_to_bytese = 65537n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751# p = 13468634736343473907717969603434376212206335187555458742257940406618189481177835992217885676243155145465521141546915941147336786447889325606555333350540003# q = 18432009829596386103558375461387837845170621179295293289126504231317130550979989727125205467379713835047300158256398009229511746203459540859429194971855371for k in range(1,e): if (e*dp-1)%k == 0: p=(e*dp-1)//k + 1 if n%p == 0: print(p) breakq=n//pphi= (p-1)*(q-1)d= gmpy2.invert(e,phi)m=pow(c,d,n)print(long_to_bytes(m))#flag&#123;wow_leaking_dp_breaks_rsa?_98924743502&#125; RSA3 给定n、e1、c1、e2、c2。 m ≡ c1^e1 mod n m ≡ c2^e2 mod n 这里采用共模攻击，详细原理如下： 扩展欧几里得算法：给定两个整数a、b，必定存在x、y，使得gcd(a,b)=ax+by 对应到本题当中，由于e1、e2互为素数，因此gcd(e1,e2)=1，从而存在s1、s2使得: s1 * e1 + s2 * e2 = 1 推导过程 m = m % n m = m^(s1 * e1 + s2 * e2)^ % n m = m^(e1 * s1)^ * m^(e2 * s2)^ % n m = (m^(e1 * s1)^ % n) * (m^(e2 * s2)^ % n) % n m = (c1s1 % n) * (c2s2 % n) % n EXP 123456789101112import gmpy2from Crypto.Util.number import long_to_bytesc1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801e1=11187289c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397e2=9647291r,s1,s2=gmpy2.gcdext(e1,e2)m=(pow(c1,s1,n) * pow(c2,s2,n)) %nprint(long_to_bytes(m))#flag&#123;49d91077a1abcb14f1a9d546c80be9ef&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"BUU刷题日记20221020","slug":"BUU刷题日记20221020","date":"2022-10-19T16:00:00.000Z","updated":"2022-12-06T07:25:59.850Z","comments":true,"path":"2022/10/20/BUU刷题日记20221020/","link":"","permalink":"https://sch01ar.github.io/2022/10/20/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221020/","excerpt":"","text":"RSA1 给定dp、dq类型 dp ≡ d mod (p-1) dq ≡ d mod (q-1) m ≡ cd mod n m = cd + k * n m = cd +k * p * q 对上式两端同时对p、q分别取余，得：（中国剩余定理） m1 ≡ cd mod p m2 ≡ cd mod q 同理，可得到 cd = m1 +k * p 代入到 m2 ≡ cd mod q 中： m2 ≡ (m1 + k * p)mod q ，两端减去m1得 m2 - m1 ≡ k * p mod q ，两端乘p的逆元得 (m2 - m1)p-1 ≡ k mod q 将k代入到 cd = m1 +k * p 中得： cd = m1 + ((m2 - m1)p-1 mod q) * p m=cd mod n 得到 m ≡ (((m2 - m1) * p-1 mod q) * p + m1) mod n 接下来就是求解m1，m2 m1 ≡ cdp+k(p-1) mod p m2 ≡ cdq+k(q-1) mod q 根据费马小定理 若p是素数，则a(p-1) ≡ 1 mod p 因此 m1 ≡ cdp mod p，m2 ≡ cdq mod q 最终可求得m exp 1234567891011121314import gmpy2from Crypto.Util.number import long_to_bytesp = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852m1=pow(c,dp,p)m2=pow(c,dq,q)n=p*qp0=gmpy2.invert(p,q)m=(((m2-m1)*p0 % q)* p +m1)%nprint(long_to_bytes(m))#noxCTF&#123;W31c0m3_70_Ch1n470wn&#125; RSAROLL 1234RSA roll！roll！roll！Only number and a-z（don&#x27;t use editorwhich MS provide） 给了一个data.txt文件，打开盲猜一下第一行是n，e，后面是c 1234567891011121314151617import gmpy2from Crypto.Util.number import long_to_bytesn = 920139713e = 19p=18443q=49891phi =(p-1)*(q-1)d=gmpy2.invert(e,phi)c=[704796792,752211152,274704164,18414022,368270835,483295235,263072905,459788476,483295235,459788476,663551792,475206804,459788476,428313374,475206804,459788476,425392137,704796792,458265677,341524652,483295235,534149509,425392137,428313374,425392137,341524652,458265677,263072905,483295235,828509797,341524652,425392137,475206804,428313374,483295235,475206804,459788476,306220148,]m=[]flag=b&#x27;&#x27;for i in range (len(c)): m.append(pow(c[i],d,n)) flag+=long_to_bytes(m[i])print(flag)#flag&#123;13212je2ue28fy71w8u87y31r78eu1e2&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"2022BUUCTF新生赛-RSA","slug":"2022BUUCTF新生赛-RSA","date":"2022-10-15T16:00:00.000Z","updated":"2022-12-08T07:35:16.441Z","comments":true,"path":"2022/10/16/2022BUUCTF新生赛-RSA/","link":"","permalink":"https://sch01ar.github.io/2022/10/16/2022BUUCTF%E6%96%B0%E7%94%9F%E8%B5%9B-RSA/","excerpt":"","text":"题目源码 123456789101112131415161718from Crypto.Util.number import *import gmpy2m = bytes_to_long(flag)p = getPrime(512)q = getPrime(512)n = p * p * qe = 0x10001d = inverse(e, p * (p-1) * (q-1))assert m &lt; nc = pow(m, e, n)hint = pow(d, e, n)print(f&#x27;c = &#123;c&#125;&#x27;)print(f&#x27;hint = &#123;hint&#125;&#x27;)print(f&#x27;n = &#123;n&#125;&#x27;)#c = 295390424904695335160238045484482823778874523176268561514416832384667341911461624807479360352155340771798064104910086195729675369023485015714514440154903376061747094964841316582559859939271083212458383263813162552258150862316694340739316654325015871916752667846321388549685578217102034863664378037876690856340358410405404601972377258035410485778168718251025950362254734939336524237028597772764421048442121802994478847811235518434239824115849516645106981074204342#hint = 381689393821386814936953643422859595359427105930487728052490073810065861656721298489533943537291889430179955685768552743683931382858386278229412048061640902207419922278984960983464060741314251570306423515751064678573919676919458734440112312205062810416467534525851481716577433432802746104452081670842385746300503903217917867773267569384218933894515975838815295351900841003897643955266573211223356519224254883905741607839206824725522319870208594077622555096443077#n = 1330047950007581682981905423145560321016033324862143764072994099149659943994269827526733343998097272206411640734177032076844564188190644548214106206913310385320478977860962140014336074250277764844699709526956803401392604949854612016074894825128737598849968249437120905834713554348840283463250157701334045079523107114507765969484185723955713386597151991074970735613177368468450679646585239506590480790958808030534070060413924423517044064816910208776798401702408317 题目分析 发现n和phin都不常规，没入手点，发现hint，hint=pow(d,e,n)，有趣，用d做明文，尝试推理一下： d = pow(hint,d,n) d = pow((d ** e % n),d,n) d = (d ** e % n) ** d % n d = d ** (e*d) % n d = pow(d e,d,n) 把d e再次看做密文，可得 d e = pow(d,e,n) 因为hint = pow(d,e,n) 可得hint = d e d e * e e-&gt;(ed) e-&gt;(ed) e == 1 mod phin 因此根据e和hint即可求得phin 从而得到phin和n的最大公约数p 脚本如下 1234567891011121314from Crypto.Util.number import *import gmpy2import mathe = 0x10001c = 295390424904695335160238045484482823778874523176268561514416832384667341911461624807479360352155340771798064104910086195729675369023485015714514440154903376061747094964841316582559859939271083212458383263813162552258150862316694340739316654325015871916752667846321388549685578217102034863664378037876690856340358410405404601972377258035410485778168718251025950362254734939336524237028597772764421048442121802994478847811235518434239824115849516645106981074204342hint = 381689393821386814936953643422859595359427105930487728052490073810065861656721298489533943537291889430179955685768552743683931382858386278229412048061640902207419922278984960983464060741314251570306423515751064678573919676919458734440112312205062810416467534525851481716577433432802746104452081670842385746300503903217917867773267569384218933894515975838815295351900841003897643955266573211223356519224254883905741607839206824725522319870208594077622555096443077n = 1330047950007581682981905423145560321016033324862143764072994099149659943994269827526733343998097272206411640734177032076844564188190644548214106206913310385320478977860962140014336074250277764844699709526956803401392604949854612016074894825128737598849968249437120905834713554348840283463250157701334045079523107114507765969484185723955713386597151991074970735613177368468450679646585239506590480790958808030534070060413924423517044064816910208776798401702408317p=math.gcd((hint*pow(e,e) -1),n)q=n//(p**2)phi=p*(p-1)*(q-1)d=gmpy2.invert(e,phi)m=pow(c,d,n)print(long_to_bytes(m))#flag&#123;43075d24-77a7-4f57-ae89-54fe4f96db69&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"2021ByteCTF-easyxor","slug":"2021ByteCTF-easyxor","date":"2022-10-15T16:00:00.000Z","updated":"2022-12-07T09:34:59.756Z","comments":true,"path":"2022/10/16/2021ByteCTF-easyxor/","link":"","permalink":"https://sch01ar.github.io/2022/10/16/2021ByteCTF-easyxor/","excerpt":"","text":"题目源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#! /usr/bin/env pythonfrom Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randint, getrandbitsdef shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; cdef convert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(4): m = shift(m, key[t], c_list[t]) return mdef encrypt(m, k, iv, mode=&#x27;CBC&#x27;): assert len(m) % 8 == 0 num = len(m) // 8 groups = [] for i in range(num): groups.append(bytes_to_long(m[i * 8: (i + 1) * 8])) last = iv cipher = [] if mode == &#x27;CBC&#x27;: for eve in groups: cur = eve ^ last cur_c = convert(cur, k) cipher.append(cur_c) last = cur_c elif mode == &#x27;OFB&#x27;: for eve in groups: cur_c = convert(last, k) cipher.append(cur_c ^ eve) last = cur_c else: print &#x27;Not supported now!&#x27; return &#x27;&#x27;.join([hex(eve)[2:].strip(&#x27;L&#x27;).rjust(16, &#x27;0&#x27;) for eve in cipher])if __name__ == &#x27;__main__&#x27;: from secret import flag if len(flag) % 8 != 0: flag += &#x27;$&#x27; * (8 - len(flag) % 8) length = len(flag) num = length // 8 keys = [randint(-32, 32) for _ in range(4)] IV = getrandbits(64) front = flag[:length // 2] back = flag[length // 2:] cipher1 = encrypt(front, keys, IV, mode=&#x27;OFB&#x27;) cipher2 = encrypt(back, keys, IV) print cipher1 + cipher2#89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912 题目分析 将flag分为两段，前半段采用OFB加密，后半段采用CBC加密 OFB解密 将前半段flag又进行切分，将其8位分为一组，存到group数组中。 123456#主要加密代码elif mode == &#x27;OFB&#x27;: for eve in groups: cur_c = convert(last, k) cipher.append(cur_c ^ eve) last = cur_c 针对一个随机生成的64位的last，与keys进行convert加密，再与group中的数进行异或。 keys是四个-32～32的数，可爆破。 对于OFB解密十分简单，因为我们已知第一组明文，恰好是8位的'ByteCTF{'，由于分组密码的性质，所以后面的也就迎刃而解，通过group[ 0]^cipher[ 0] 即可得到cur_c，从而求得下一次的cur_c，以此类推。 expOFB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#OFB解密#! /usr/bin/env pythonfrom Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randint, getrandbitsdef shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; cdef convert(m, key): c_list = [ 0x37386180AF9AE39E, 0xAF754E29895EE11A, 0x85E1A429A2B7030C, 0x964C5A89F6D3AE8C, ] for t in range(4): m = shift(m, key[t], c_list[t]) return mdef check(s): c=1 for i in s: if 32&lt;=i&lt;=127: continue else: c=0 break return cc = &quot;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912&quot;c=c[:len(c)//2]cipher = []for i in range(len(c)//16): cipher.append(int(c[i*16:(i+1)*16],16))flag = b&#x27;ByteCTF&#123;&#x27;m0 = bytes_to_long(flag)m_m = m0 ^ cipher[0]for a in range(-32,32): for b in range(-32,32): for c in range(-32,32): for d in range(-32,32): keys=[a,b,c,d] m_m1=convert(m_m,keys) m1=long_to_bytes((m_m1^cipher[1])) if check(m1): m_m2 = convert(m_m1, keys) m2 = long_to_bytes((m_m2 ^ cipher[2])) if check(m2): flag+=m1 flag+=m2 print(flag) print(a,b,c,d)#b&#x27;ByteCTF&#123;5831a241s-f30980&#x27;#keys：-12 26 -3 -31 CBC解密 针对后半部分，我们需要逆向解出convert函数，因此就是对shift函数中的加密运算进行解密。 之前上网搜的wp都一笔带过，没解释unshift逆函数怎么写的。“难道有什么定理？？” 这里简单写一下我的理解。 分析shift 1234def shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; c 推理过程 这里我们举例k&gt;0时的情况。（k&lt;0同理） m和c都是64位,k是-32～32的10进制数。 1、m &lt;&lt; k相当于在m后补k位0，得到的新数我们称为a，a=m &lt;&lt; k。 2、令b = a &amp; c，由于a是64+k位，c是64位，所以b是64位，并且b的后k位都是0。 3、令x = m ^ b，x则是shift加密之后的值，x也是64位，并且x的后k位是与m的后k位相同的，与0异或得本身。 我们走完了一遍shift加密，得到的结论是，密文的位数同样是64，并且密文的后k位与明文相同。 分析unshift 12345678910def unshift(m, k, c, bits=64): tmp = m if k &lt; 0: for i in range(bits // (-k)): tmp = m ^ tmp &gt;&gt; (-k) &amp; c else: for i in range(bits // k): tmp = m ^ tmp &lt;&lt; k &amp; c assert shift(tmp, k, c) == m return tmp 推理过程 同样我们举例k&gt;0的情况。 之前我们得到的密文x，相当于tmp。 1、a'=tmp &lt;&lt; k，tmp后k位为0，tmp后2k～k位等于m的后k位。 2、b'=a' &amp; c，b'后k位为0，后2k～k位为m&amp;c。 3、y=x ^ b'，y的后k位，等于x的后k位，也就是m的后k位。 4、y的后2k～k位，在shift加密当中，a &amp; c的后2k～k位等于m的后k位&amp;c，记作m1 &amp; c。 shift中的x，也就是m ^ b，m ^(m1 &amp; c)，在unshift最后的一步操作中，y= m ^(m1 &amp; c) ^ b'。 这时我们只考虑y的后2k～k位，y=m ^(m1 &amp; c)^(m1 &amp; c) = m 所以这时y的2k～k位也等于m了。 总结 因此，我们发现每经过unshift一次，就有k位被还原，何时才能被完全还原？即循环bits//k次。 此推理正确，可以在unshift函数运行时输出每次的tmp观察即可。 ps：自我感觉这种位运算应该是属于一种性质或者定理，网上大佬们都是说“简单写个逆”。。。 expCBC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randint, getrandbitsdef shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; cdef unconvert(m, key): tmp = m c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(3,-1,-1): m = unshift(m, key[t], c_list[t]) return mdef unshift(m, k, c, bits=64): tmp = m if k &lt; 0: for i in range(bits // (-k)): tmp = m ^ tmp &gt;&gt; (-k) &amp; c else: for i in range(bits // k): tmp = m ^ tmp &lt;&lt; k &amp; c assert shift(tmp, k, c) == m return tmpkeys=[-12,26,-3,-31]c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c]flag=b&#x27;ByteCTF&#123;&#x27;flag=bytes_to_long(flag)iv=16476971533267772345c = &quot;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912&quot;c=c[len(c)//2:]cipher = []for i in range(len(c)//16): cipher.append(int(c[i*16:(i+1)*16],16))group=[]curc1=unconvert(cipher[0],keys)group.append(long_to_bytes(curc1^iv))curc2=unconvert(cipher[1],keys)group.append(long_to_bytes(curc2^cipher[0]))curc3=unconvert(cipher[2],keys)group.append(long_to_bytes(curc3^cipher[1]))group[0]+=group[1]group[0]+=group[2]print(group[0])#b&#x27;q535af-2156547475u2t&#125;$$$&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"梦开始的地方","slug":"梦开始的地方","date":"2022-10-15T07:59:58.000Z","updated":"2022-12-01T05:15:04.679Z","comments":true,"path":"2022/10/15/梦开始的地方/","link":"","permalink":"https://sch01ar.github.io/2022/10/15/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/","excerpt":"","text":"Mac下利用Hexo和github pages搭建个人博客 环境配置 1.Node.js安装 下载地址：Node.js 2.淘宝镜像安装 12//打开终端terminal$ npm install -g cnpm --registry=https://registry.npm.taobao.org 3.安装Hexo 1234// 使用命令去安装Hexocnpm install -g hexo-cli//安装成功后查看版本hexo -v 初始化Hexo Blog 1.初始化Hexo 新建一个文件夹并进入，例如blog 12//初始化hexohexo init #### 2.本地启动Hexo 1hexo s 浏览器打开网站，即可看到本地博客 创建博客文章 1.创建文章 1hexo n &quot;我的第一篇文章&quot; 在blog文件夹中的_post里即可看到新建的md文件 #### 2.清理缓存项目 在新建博客或修改博客时，需要进行该操作 1hexo clean #### 3.重新生成博客 1hexo g 4.启动博客 1hexo d","categories":[{"name":"建站","slug":"建站","permalink":"https://sch01ar.github.io/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://sch01ar.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-10-15T07:57:23.442Z","updated":"2022-12-01T05:15:29.274Z","comments":true,"path":"2022/10/15/hello-world/","link":"","permalink":"https://sch01ar.github.io/2022/10/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sch01ar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"建站","slug":"建站","permalink":"https://sch01ar.github.io/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"},{"name":"非对称加密","slug":"非对称加密","permalink":"https://sch01ar.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"},{"name":"lattice","slug":"lattice","permalink":"https://sch01ar.github.io/tags/lattice/"},{"name":"二叉树","slug":"二叉树","permalink":"https://sch01ar.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://sch01ar.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}