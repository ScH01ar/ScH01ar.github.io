{"meta":{"title":"Y's blog","subtitle":"","description":"","author":"Roo1e","url":"https://sch01ar.github.io","root":"/"},"pages":[{"title":"书单","date":"2022-10-16T02:30:27.247Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"books/index.html","permalink":"https://sch01ar.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-12-10T07:36:44.999Z","updated":"2022-12-02T03:15:20.960Z","comments":false,"path":"about/index.html","permalink":"https://sch01ar.github.io/about/index.html","excerpt":"","text":"🐭🐭"},{"title":"分类","date":"2022-10-16T02:33:21.117Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"categories/index.html","permalink":"https://sch01ar.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-10-17T01:02:57.129Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"links/index.html","permalink":"https://sch01ar.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-10-16T03:25:28.438Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"repository/index.html","permalink":"https://sch01ar.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-10-16T02:41:49.050Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"tags/index.html","permalink":"https://sch01ar.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"VNCTF2023","slug":"VNCTF2023","date":"2023-02-20T12:05:45.000Z","updated":"2023-02-20T12:50:29.436Z","comments":true,"path":"2023/02/20/VNCTF2023/","link":"","permalink":"https://sch01ar.github.io/2023/02/20/VNCTF2023/","excerpt":"","text":"crypto-sign-in-1 一道 ECDLP 题目，当时想到使用Pohlig-Hellman算法，但是一直没能找到合适的 A、B 来确定 G 的阶 n，赛后看大佬 wp，果然是用 pwntools 远程多试几组 y1、y2，找到光滑的阶，从而解密成功。 题目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123from sympy.ntheory.residue_ntheory import nthroot_modfrom Crypto.Util.number import *from Crypto.Cipher import AESfrom random import randrange,choicefrom hashlib import *from secret import flagimport socketserverimport osimport signalimport stringtable = string.ascii_letters+string.digitsnbit = 128def pad(m,lenth): return m + bytes([i for i in range(lenth-int(len(m)%lenth))])class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b&#x27;&#x27; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) &lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b&#x27;\\n&#x27; self.request.sendall(msg) except: pass def recv(self, prompt=b&#x27;&#x27;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (&#x27;&#x27;.join([choice(table)for _ in range(20)])).encode() sha = sha256(proof).hexdigest().encode() self.send(b&quot;[+] sha256(XXXX+&quot; + proof[4:] + b&quot;) == &quot; + sha ) XXXX = self.recv(prompt = b&#x27;[+] Plz Tell Me XXXX :&#x27;) if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def handle(self): proof = self.proof_of_work() if not proof: self.request.close() while 1: qa = randrange(0,2**31) * 2 qb = getPrime(nbit - 32) if isPrime(qa * qb + 1): q = qa * qb + 1 break for _ in range(len(b&#x27;vnctf2023&#x27;) - 8): self.send(b&quot;Send 2 `y&#x27; elements to me: &quot;) ans = self.recv() try: y1, y2 = [int(_) % q for _ in ans.split(b&#x27;,&#x27;)] except: self.send(b&quot;Your parameters are not valid! Bye!!&quot;) break AA = (y1**2 - y2**2 - 2022**3 + 2023**3) * inverse(-1, q) % q BB = (y1**2 - 2022**3 - AA * 2022) % q def add(P,Q): if P[0] != Q[0] and P[1] != Q[1]: t = ((Q[1]-P[1]) * inverse(Q[0]-P[0],q)) %q else: t = ((3*P[0]*P[0]+AA)*inverse(2*P[1],q))%q x3 = t*t - P[0] - Q[0] y3 = t*(P[0] - x3) - P[1] return (x3%q, y3%q) def mul(t, A, B=0): if not t: return B return mul(t//2, add(A,A), B if not t&amp;1 else add(B,A) if B else A) while 1: Gx = randrange(0,q - 1) try: Gy = int(nthroot_mod((Gx**3 + AA * Gx + BB) % q,2,q)) assert (pow(Gy,2,q) == (Gx**3 + AA * Gx + BB) % q) break except: continue G = (Gx,Gy) m = randrange(0,q-1) C = mul(m,G) aes = AES.new(m.to_bytes(16, &#x27;big&#x27;), AES.MODE_CBC, bytes(16)) enc_flag = aes.encrypt(pad(flag,16)) self.send(b&#x27;The parameters and encrypted flag are:&#x27;) self.send(b&#x27;q = &#x27; + str(q).encode()) self.send(b&#x27;G = (&#x27;+ str(Gx).encode() + b&#x27;,&#x27; + str(Gy).encode() + b&#x27;)&#x27;) self.send(b&#x27;m * G = (&#x27;+ str(C[0]).encode() + b&#x27;,&#x27; + str(C[1]).encode() + b&#x27;)&#x27;) self.send(b&#x27;encrypt flag = &#x27; + enc_flag.hex().encode()) self.request.close()class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): passif __name__ == &quot;__main__&quot;: HOST, PORT = &#x27;0.0.0.0&#x27;, 10001 print(&quot;HOST:POST &quot; + HOST+&quot;:&quot; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() EXP 以后终于能用 sage 跑远程了，个人用的 sage 的 console，在里面下了 pwntools 库和 crypto 库，不知道为什么 remote 使用的时候端口号也要加个引号，不然会报错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#sagefrom pwn import *from itertools import productimport stringfrom hashlib import sha256from random import getrandbitsfrom ast import literal_evalfrom Crypto.Util.number import *from Crypto.Cipher import AEStable = string.ascii_letters+string.digitsdef set_connect_proof(): io=remote(&#x27;node4.buuoj.cn&#x27;,&#x27;25385&#x27;) io.recvuntil(b&quot;sha256(XXXX+&quot;) alphabet = string.ascii_letters + string.digits lattar_part=io.recv(16).decode(&#x27;utf8&#x27;) io.recvuntil(b&#x27;== &#x27;) h=io.recvline().strip().decode(&#x27;utf8&#x27;) # print(h) io.recvuntil(b&#x27;[+] Plz Tell Me XXXX :&#x27;) bruteforce=[ &#x27;&#x27;.join(prefix)+lattar_part for prefix in product(alphabet,repeat=4)] for proof in bruteforce: if sha256(proof.encode()).hexdigest()==h: io.sendline(proof.encode()[:4]) print(&quot;proof done&quot;) return iowhile True: io = set_connect_proof() io.recvuntil(b&quot;Send 2 `y&#x27; elements to me: &quot;) y1,y2 = getrandbits(128),getrandbits(128) io.sendline(f&#x27;&#123;str(y1)&#125;,&#123;str(y2)&#125;&#x27;.encode()) q = int(io.recvline_contains(b&#x27;q = &#x27;).decode().strip()[4:]) G = literal_eval(io.recvline_contains(b&quot;G = &quot;).decode().strip()[4:]) mG = literal_eval(io.recvline_contains(b&quot;m * G = &quot;).decode().strip()[8:]) encflag = io.recvline_contains(b&#x27;encrypt flag = &#x27;).decode().strip()[len(b&#x27;encrypt flag = &#x27;):] AA = (y1**2 - y2**2 - 2022**3 + 2023**3) * inverse(-1, q) % q BB = (y1**2 - 2022**3 - AA * 2022) % q E = EllipticCurve(GF(q), [AA, BB]) g_order = E(G).order() order_ls = factor(g_order) print(f&quot;[+] G order &#123;order_ls&#125;&quot;) sub_group_order = 1 for p,e in order_ls: if p.nbits() &lt;= 42: sub_group_order*= (p^e) expon = g_order//sub_group_order print(f&quot;[+] &#123;sub_group_order.nbits() = &#125;&quot;) if sub_group_order.nbits() &lt; 120: io.close() continue mm = discrete_log(expon*E(mG),expon*E(G),ord = sub_group_order,operation = &quot;+&quot;) print(f&quot;[+] subgroup dlp (m mod &#123;sub_group_order&#125;) = &quot;, mm) io.close() breakaes = AES.new(int(mm).to_bytes(16, &#x27;big&#x27;), AES.MODE_CBC, bytes(16))flag = aes.decrypt(bytes.fromhex(encflag))print(flag)","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"2023寒假集合","slug":"2023寒假集合","date":"2023-02-04T06:05:45.000Z","updated":"2023-02-16T01:46:57.593Z","comments":true,"path":"2023/02/04/2023寒假集合/","link":"","permalink":"https://sch01ar.github.io/2023/02/04/2023%E5%AF%92%E5%81%87%E9%9B%86%E5%90%88/","excerpt":"","text":"ECC ¶sage 环境 进行简单运算 &lt;!–code￼0–&gt; ¶ECDLP 给定椭圆曲线 E，已知 P、Q 以及$Q=kP$，求 k。 &lt;!–code￼1–&gt; ¶RWCTF2023 体验赛 RSA ¶rabin 适用于 RSA 中 e=2 的情况 ¶pqpq(seccon2022) &lt;!–code￼2–&gt; ¶大致思路 根据题目，可先通过计算 c1、c2 表达式，合并找出公因子，即可求出 p、q，从而 r 也可求得。 发现 e=65537 * 2，因此是无逆元存在的，索性就将 e 拆分为 65537 与 2，e2=2 时便可通过 Rabin 算法解密。 ¶求 p、q、r $c2 = (p - q)^e \\mod n \\$ 左右同乘 r $c2 * r = rp^e + rq^e + X*pqr = rp^e + rq^e \\mod n\\$ $c2 = p^e + q^e \\mod n\\$ 同理得到$c1 = p^e - q^e \\mod n \\$ 从而求得 p、q $p=gcd(c1+c2,n)\\$ $q=gcd(c1-c2,n)\\$ ¶求解 m^2 $\\phi(n)=(p-1)(q-1)(r-1)\\$ 通过 e1(e/2)和$\\phi(n)$求出 d，得到$cmd=m{2e1d}=m^2 \\mod n$ ¶Rabin 解密 接下来就是传统 Rabin 解密，找了两种脚本，exp 中的sqrtPrime(n,p)和Tonelli_Shanks(n,p)任选其一即可，都是基于二次剩余定理所实现的解密算法 &lt;!–code￼3–&gt; ¶","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"RSA补充","slug":"RSA补充","date":"2022-12-07T13:05:45.000Z","updated":"2023-02-09T09:15:46.189Z","comments":true,"path":"2022/12/07/RSA补充/","link":"","permalink":"https://sch01ar.github.io/2022/12/07/RSA%E8%A1%A5%E5%85%85/","excerpt":"","text":"回顾 RSA 中加、解密： 加密$c = m^e\\quad mod\\quad n$ 解密$m = c^d\\quad mod\\quad n$ 接下来证明一下解密过程，先引入欧拉定理。 ¶欧拉定理 对于互为质数的 m、n 两个数，有$m^{\\phi(n)} = 1\\quad mod\\quad n$，其中$\\phi(n)$表示小于 n 的质数的个数。 ¶解密原理 通过$c = m^e\\quad mod\\quad n$与欧拉定理$m^{\\phi(n)} = 1\\quad mod\\quad n$，我们便可进行推导。 对欧拉定理进行变形，得到$m^{k\\phi(n)+1} = m\\quad mod\\quad n$ 因为我们已经知道$c = m^e\\quad mod\\quad n$，所以寻找一个 d，使得$ed = k\\phi(n)+1$,则可以得到$m^{ed}=m\\quad mod \\quad n$ 则得到了$c^d =m\\quad mod\\quad n$ 共模攻击 所谓共模，就是 n 相同，会对应多组 c，e。 例：给定 n、c1、c2、e1、e2 m = c1e1 mod n m = c2e2 mod n ¶扩展欧几里得算法 给定两个整数 a、b，必定存在 x、y，使得 gcd(a,b)=ax+by 运用该算法推导过程 m = m % n m = ms1e1+s2e2 % n m = (me1s1 * me2s2)% n m = (me1s1 % n) * (me2s2 % n) % n m = (c1s1 % n) * (c2s2 % n) % n ¶EXP &lt;!–code￼0–&gt; 低加密指数广播攻击 特点是 e 小，有多组 n，对应了多组 c me = c1 mod n1 me = c2 mod n2 me = c3 mod n3 ¶中国剩余定理(CRT) 定理内容如下 针对上述方程组，若 n1、n2、n3 互质，对于任意的 c1、c2、c3，方程组都有解 m。 使用条件是 m^e &lt; n1、n2、n3。通解推导如下： 设$N=n_1 \\times n_2 \\times n_3, N_1=N/n_1, N_2=N/n_2, N_3=N/n_3$ 设$t_i=N_i^{-1}$,这里表示$t_i$是$N_i$在模$n_i$的逆元。 有了以上几个数，我们可以给出通解形式： $$m=c_1t_1N_1+c_2t_2N_2+c_3t_3N_3+kN=kN+\\sum_{i=1}^3c_it_iN_i$$ 在模 N 后，只剩唯一解$m=\\sum_{i=1}^3c_it_iN_i$ ¶EXP &lt;!–code￼1–&gt; dp、dq 相关 ¶给定 dp、dq 类型 dp ≡ d mod (p-1) dq ≡ d mod (q-1) m ≡ cd mod n m = cd + k * n m = cd +k _ p _ q 对上式两端同时对 p、q 分别取余，得：（中国剩余定理） m1 ≡ cd mod p m2 ≡ cd mod q 同理，可得到 cd = m1 +k * p 代入到 m2 ≡ cd mod q 中： m2 ≡ (m1 + k * p)mod q ，两端减去 m1 得 m2 - m1 ≡ k * p mod q ，两端乘 p 的逆元得 (m2 - m1)p-1 ≡ k mod q 将 k 代入到 cd = m1 +k * p 中得： cd = m1 + ((m2 - m1)p-1 mod q) * p m=cd mod n 得到 m ≡ (((m2 - m1) _ p-1 mod q) _ p + m1) mod n 接下来就是求解 m1，m2 m1 ≡ cdp+k(p-1) mod p m2 ≡ cdq+k(q-1) mod q 根据费马小定理 若 p 是素数，则 a(p-1) ≡ 1 mod p 因此 m1 ≡ cdp mod p，m2 ≡ cdq mod q 最终可求得 m ¶EXP &lt;!–code￼2–&gt; ¶只给定 dp dp ≡ d mod (p-1) ed ≡ 1 mod (p-1) * (q-1) ed = 1 + k2(p-1)(q-1) 对 1 式两端同乘 e，得 e * dp ≡ ed mod (p-1) e * dp = k1(p-1) + ed 代入 ed 得 e * dp = k1(p-1) + 1 + k2(p-1)(q-1) 由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余 p-1，即可消掉 n e * dp ≡ 1 mod (p-1) e * dp =k(p-1) + 1 得到这个式子后，其实真正意义上的未知数只有我们要求的 p，但是还存在一个 k。 针对 k，我们判断一下他的范围，看看能否采用爆破的方式。 k = (e * dp - 1)/(p-1) 因为 dp &lt; p-1 所以 k &lt; e 通过遍历 k 然后找到(e * dp - 1)可以整除 k 的情况即可。 (跑了一下发现限制条件还不够) 因此再加一个 n 能否整除 p 即可。 ¶EXP &lt;!–code￼3–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"2022DASCTF_NOV-lllcccggg-wp","slug":"2022DASCTF_NOV-lllcccgggwp","date":"2022-11-30T02:05:45.000Z","updated":"2022-12-01T09:42:22.869Z","comments":true,"path":"2022/11/30/2022DASCTF_NOV-lllcccgggwp/","link":"","permalink":"https://sch01ar.github.io/2022/11/30/2022DASCTF_NOV-lllcccgggwp/","excerpt":"","text":"题目描述 如题目名字一样，有好多个lcg，当时看晕了 &lt;!–code￼0–&gt; 题目分析 1.key是一个背包问题，已知公钥m，和的话目前不知道。 2.以1中的和为seed，通过LCG产生了一组序列output。 至此，已经可以根据output来求出LCG中的a、b、n，从而求出seed，从而通过背包可求得key。 3.以key为seed，称作state，再进行LCG，state = (a * state + b) % c，并且a，b，c已知。 但是想要直接正向求解出最后的state，十分困难，for循环了10^10000次，这里涉及到了矩阵快速幂的使用。 通过构造矩阵 $$ \\mathbf{A} = \\begin{bmatrix} state &amp; 1 \\end{bmatrix} $$ $$ \\mathbf{C} = \\begin{bmatrix} a &amp; 0\\ b &amp; 1\\ \\end{bmatrix} $$ 通过计算$AC^{1010000}$即可得到矩阵B，B = [ state, 1] 4.求出state后进行异或解密即可。 EXP &lt;!–code￼1–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"背包加密算法","slug":"背包问题算法","date":"2022-11-28T16:00:00.000Z","updated":"2022-12-01T09:50:05.003Z","comments":true,"path":"2022/11/29/背包问题算法/","link":"","permalink":"https://sch01ar.github.io/2022/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/","excerpt":"","text":"¶前言 在一次CTF比赛中遇到了，写了10个for嵌套硬爆出来了，复现的时候发现是背包加密。 ¶Merkle–Hellman 公钥加密算法 整体加密流程 &lt;!–code￼0–&gt; 可以发现，加密十分容易，但解密十分困难，这也是非对称加密的特点。 ¶加密 ¶生成私钥 超递增序列，也就是a中每一位元素需要大于其之前所有元素的和。 &lt;!–code￼1–&gt; ¶生成公钥 模数m要求：m &gt; sum(a) 乘数w要求：gcd(w,m) == 1 &lt;!–code￼2–&gt; b和m作为公钥。 加密：S = numpy.dot(x,b) ¶解密 拿到公钥$M=(m_1,m_2,\\ldots,m_n)$，构造如下矩阵 $$ \\begin{bmatrix} 2 &amp; 0 &amp; \\ldots &amp; 0 &amp; m_1 \\ 0 &amp; 2 &amp; \\ldots &amp; 0 &amp; m_2 \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\ 0 &amp; 0 &amp; \\ldots &amp; 2 &amp; m_n \\ 1 &amp; 1 &amp; \\ldots &amp; 1 &amp; S \\ \\end{bmatrix} $$ 这个矩阵的所有行向量的线性组合构成了一个格，接下来将通过明文的特点和格上的特殊解法来进行解密。 ¶LLL 对于明文$X=(x_1,x_2,\\ldots,x_n)$这一组数来说，构造一个向量 $$ a=\\sum_{i=1}^nx_iv_i-v_{n+1}=(2x_1-1,2x_2-1,\\ldots,2x_n-1,0) $$ 显然，a向量在格L上。因为X中的所有x只能取值0或1，因此a向量的长度很小，约为$\\sqrt{n}$，对于很大的格基来说，a向量无疑是格L上的最小向量，因此我们利用LLL算法即可求出a向量。 ¶例题 &lt;!–code￼3–&gt; 这里注意一下，第一行向量中是有+1与-1，需要进行取反，即-1代表1，1代表0。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"非对称加密","slug":"非对称加密","permalink":"https://sch01ar.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"}]},{"title":"Hitcon 2022-㊙️BabySSS","slug":"hitcon2022-BabySSS","date":"2022-11-27T16:00:00.000Z","updated":"2022-12-01T09:37:56.735Z","comments":true,"path":"2022/11/28/hitcon2022-BabySSS/","link":"","permalink":"https://sch01ar.github.io/2022/11/28/hitcon2022-BabySSS/","excerpt":"","text":"I implemented a toy Shamir’s Secret Sharing for fun. Can you help me check is there any issues with this? Shamir’s Secret Sharing密钥分享算法 $$f(x)=a_0 + a_1x + a_2x^2 + …… + a_{k-1} x^{k-1} mod p $$ 题目源码 &lt;!–code￼0–&gt; 题目分析 题目给了8组x，y的值，可通过CRT模x求出a_0 ，通过模x^2 可求出a_1 ，同理可求出所有系数，恢复出polyeval函数，从而得到正确的secret。 EXP &lt;!–code￼1–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"Gauss格基约简算法","slug":"Gauss格基约简算法","date":"2022-11-23T16:00:00.000Z","updated":"2022-12-07T09:39:00.075Z","comments":true,"path":"2022/11/24/Gauss格基约简算法/","link":"","permalink":"https://sch01ar.github.io/2022/11/24/Gauss%E6%A0%BC%E5%9F%BA%E7%BA%A6%E7%AE%80%E7%AE%97%E6%B3%95/","excerpt":"","text":"由Gauss提出的二维格基约化算法 算法伪代码 即对给定的两个基向量进行不断的相互约化，最终求得格上的最小向量 Loop (a) If ||v2|| &lt; ||v1||, swap v1, v2 (b) Compute m = ⌊ v1∙v2 / v1∙v1 ⌉ © If m = 0, return v1, v2 (d) v2 = v2 - m*v1 Continue Loop 代码实现 &lt;!–code￼0–&gt; 例题 &lt;!–code￼1–&gt; ¶思路 给定公钥q、h，以及明文e 要求私钥f、g 他们之间有如下关系： fh ≡ g mod q 即 kq + g =fh g = fh -kq 根据这一特点即可构造格，也就是格密码中很经典的，遇到一个向量乘矩阵，即可进行构造 由于存在一组a、b，使得a（1，h）+ b（0，q）=（f，g）$a(1,h) + b(0,q) = (f,g)$ a = f，b = k 选取一组基底为（1，h）和（0，q），也就是上述高斯约简算法当中的v1与v2，求出v1与v2格上最小的向量，即为（f，g） ¶EXP &lt;!–code￼2–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"lattice","slug":"lattice","permalink":"https://sch01ar.github.io/tags/lattice/"}]},{"title":"二叉树建立与遍历","slug":"二叉树建立与遍历","date":"2022-11-09T16:00:00.000Z","updated":"2022-12-01T05:15:01.487Z","comments":true,"path":"2022/11/10/二叉树建立与遍历/","link":"","permalink":"https://sch01ar.github.io/2022/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/","excerpt":"","text":"网上很多算法通过直接将二叉树结点连接，从而构成二叉树，这里我构建了一个二叉树类，通过用户控制输入来建立二叉树。 有层序遍历，递归、非递归的前序遍历、中序遍历、后序遍历算法。 &lt;!–code￼0–&gt;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sch01ar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sch01ar.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"2022祥云杯wp-crypto","slug":"2022-10-30-2022祥云杯wp-crypto","date":"2022-10-29T16:00:00.000Z","updated":"2022-12-07T09:43:16.370Z","comments":true,"path":"2022/10/30/2022-10-30-2022祥云杯wp-crypto/","link":"","permalink":"https://sch01ar.github.io/2022/10/30/2022-10-30-2022%E7%A5%A5%E4%BA%91%E6%9D%AFwp-crypto/","excerpt":"","text":"little little fermat ¶题目源码 &lt;!–code￼0–&gt; ¶题目分析 根据题目名字来看，此题和费马小定理的使用有关，题目中有一个 obfuscate函数，进行了对q的生成，q=p+A，这里可以看一下A的范围，是在2[18,319]之间，因此p、q接近，尝试一下yafu分解。 题目对m先进行了处理，再进行RSA加密，因此我们需要知道x。assert 114514 ** x % p == 1运用费马小定理，若114514与p互素，则x=p-1，即可求解m。 ¶EXP &lt;!–code￼1–&gt; fill ¶题目源码 &lt;!–code￼2–&gt; ¶题目分析 随机产生32位的数，sha256()加密后作为flag，并将其2进制的每一位存到了f_list数组中。 又 创建了一个r_list32位数组，里面存着随机数，先暂时不管。 双 对r_list数组中的随机数做了加密，产生了M数组。 对f_list和M数组进行了numpy.dot运算，即向量乘法，得到和为S。 叒 创建了一个s数组，这个很明显，用LCG线性同余算法进行了加密。 最后将M数组与s数组相加。 这就是这道题整体的流程，每一步并不难，只是步骤多，略显复杂。 ¶EXP ¶0x01 可以先进行一下LCG的求解，把s数组求解出来，从而求出M数组。 &lt;!–code￼3–&gt; ¶0x02 按理来说，感觉应该根据求出来的M数组进行逆运算，求出r_list数组，但是求出来r_list有什么用呢，所以直接尝试求f_list。因为f_list中不是0就是1，与M做向量乘法，即为M数组中若干元素的和。根据题目给定和S，先大概看一下需要M中多少个元素累加。发现在M前21位和 &lt; S，前22位和 &gt; S，所以猜想应该是M当中，除10个左右元素之外的和。 这里就遍历了一下，复杂度实在太高了，也没想着能出，结果还真算出来了o.O &lt;!–code￼4–&gt; 也就说明，f_list中下标为这些的，对应值是0，其余为1，即可得到msg的2进制数，转为十进制后进行sha256()加密即可。 &lt;!–code￼5–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"2022NewStarCTF-flip_flop","slug":"2022NewStarCTF-flip_flop","date":"2022-10-26T16:00:00.000Z","updated":"2022-12-07T09:41:52.644Z","comments":true,"path":"2022/10/27/2022NewStarCTF-flip_flop/","link":"","permalink":"https://sch01ar.github.io/2022/10/27/2022NewStarCTF-flip_flop/","excerpt":"","text":"flip-flop AES-CBC加密模式 ¶题目 源码如下： &lt;!–code￼0–&gt; ¶题目分析 此题是通过注册得到的用户账户的密文，然后输入管理员账户对应的密文，才能得到flag。 对用户账户和管理员账户的加密解密均采用AES-CBC模式，但是本题仅有一组明文，iv仅作为偏移量，也就是本题中的user_key。 这里先来说一下我最一开始的思路，由于user_key每次是随机产生的，但是一次程序的运行当中是不变的。由于密文由两部分组成，前半部分为user_key.hex()，后半部分为code.hex()，所以只要构造出admin对应的code即可，那么就需要AES加密当中的key，所以就需要构造一个key来产生出admin对应的code。查询了很多资料发现都难以实现。于是…… 那为什么不换一下思路？不能构造code，能不能构造iv？ 先来看一下加密方式： C = encrypt(M ^ iv) M = decrypt©^iv 对应一下本题当中的NewStarCTFer和admin： b'NewStarCTFer____' = decrypt(code) ^ iv1 b'AdminAdmin______' = decrypt(code) ^ iv2 因此可求出admin对应的iv2，随后拼接上普通用户的后半段code即可。 ¶EXP &lt;!–code￼1–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"BUU刷题日记20221026","slug":"BUU刷题日记20221026","date":"2022-10-25T16:00:00.000Z","updated":"2022-12-07T09:39:19.641Z","comments":true,"path":"2022/10/26/BUU刷题日记20221026/","link":"","permalink":"https://sch01ar.github.io/2022/10/26/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221026/","excerpt":"","text":"RSA5 ¶题目分析 给定e=65537 给了很多组n、c 由于e过大，所以不考虑使用CRT，由于m是同一个，因此遍历一下，求出两个n的最大公约数，即为p，后续就简单了。 ¶EXP &lt;!–code￼0–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"2022 DASCTF 10月挑战赛wp","slug":"2022DASCTF10月挑战赛wp","date":"2022-10-22T16:00:00.000Z","updated":"2022-12-07T09:42:51.960Z","comments":true,"path":"2022/10/23/2022DASCTF10月挑战赛wp/","link":"","permalink":"https://sch01ar.github.io/2022/10/23/2022DASCTF10%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwp/","excerpt":"","text":"RSA ¶题目如下 &lt;!–code￼0–&gt; ¶题目分析 该题的加密顺序是： 1、加密flag，分为两部分m1、m2 2、加密m1 3、加密m2 同理我们解密的顺序应该也是 1、解出m1、m2 2、解出flag ¶求m2 先观察一下encrypt4函数 虽然说e_2=3，按理来说使用低加密指数攻击，但并不可行。 又因为m = m % k 可通过这点和c_3 = pow(m, e_2, n_3)做遍历求出m 最后发现m即为m2，m2 &lt; k ¶求m1 发现m1加密方式采用RSA，但是n_1未知 n_1又通过一次RSA加密，已知n_1对应的密文 利用低加密指数攻击解出n1 发现n1可分解为3个素数乘积 故phi可求，即求出m1 ¶求flag 观察encryt1 m1是flag右移200位之后转为字节 m2是flag的20位之后转成字节 所以来说m2是没什么问题，主要找到flag的前20位，再把m2拼到后面即可。 由于m1是flag右移200位，因此flag的低位缺失，但高位还在，由于不知道flag总长度，抱着试一试的心态，猜测一下它的高位前20位没有缺失 我们将m1和m2转为字节发现 m1:b’0x666c61677b3230366538353964’ m2:b’383539643865383534633466363030636231323735376262663966357d’ 发现m1和m2有重叠部分，即38353开始 可以证实m1前20位确实没有缺失 因此取m1前20位，加m2，即可解出flag ¶EXP &lt;!–code￼1–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"BUU刷题日记20221022","slug":"BUU刷题日记20221022","date":"2022-10-21T16:00:00.000Z","updated":"2022-12-07T09:40:10.592Z","comments":true,"path":"2022/10/22/BUU刷题日记20221022/","link":"","permalink":"https://sch01ar.github.io/2022/10/22/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221022/","excerpt":"","text":"RSA4 题目只给了三组n、c，采用中国剩余定理，具体推导如下 ¶推导过程 me ≡ c1 mod n1 me ≡ c2 mod n2 me ≡ c3 mod n3 ¶中国剩余定理（CRT） 中国剩余定理的内容是： 针对上述方程组，若n1、n2、n3互质，对于任意的c1、c2、c3，方程组都有解，使用条件是m^e &lt; n1、n2、n3。通解形式如下： 令N = n1 * n2 * n3，N1 = N/n1，N2、N3同理 令t1 = N1(-1)，即其对应的模n1运算的逆元，t2，t3同理，可用t1=gmpy2.invert(N1,n1)表示。 有了Ni和ti的定义，我们就可以给出通解形式： x = c1 * N1 * t1 …… 有了通解公式我们就可以求出m^e，对e进行一下遍历即可，m开方成功即可。 ¶EXP &lt;!–code￼0–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"BUU刷题日记20221021","slug":"BUU刷题日记20221021","date":"2022-10-20T16:00:00.000Z","updated":"2022-12-08T05:42:21.849Z","comments":true,"path":"2022/10/21/BUU刷题日记20221021/","link":"","permalink":"https://sch01ar.github.io/2022/10/21/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221021/","excerpt":"","text":"RSA2 题目给定n、e、dp、c 非预期解：直接分解n 下面考虑n不能分解的情况 ¶推导过程 dp ≡ d mod (p-1) ed ≡ 1 mod (p-1) * (q-1) ed = 1 + k2(p-1)(q-1) 对1式两端同乘e，得 e * dp ≡ ed mod (p-1) e * dp = k1(p-1) + ed 代入ed得 e * dp = k1(p-1) + 1 + k2(p-1)(q-1) 由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余p-1，即可消掉n e * dp ≡ 1 mod (p-1) e * dp =k(p-1) + 1 得到这个式子后，其实真正意义上的未知数只有我们要求的p，但是还存在一个k。 针对k，我们判断一下他的范围，看看能否采用爆破的方式。 k = (e * dp - 1)/(p-1) 因为dp &lt; p-1 所以k &lt; e 通过遍历k然后找到(e * dp - 1)可以整除k的情况即可。 (跑了一下发现限制条件还不够) 因此再加一个n能否整除p即可。 ¶EXP &lt;!–code￼0–&gt; RSA3 给定n、e1、c1、e2、c2。 m ≡ c1^e1 mod n m ≡ c2^e2 mod n 这里采用共模攻击，详细原理如下： 扩展欧几里得算法：给定两个整数a、b，必定存在x、y，使得gcd(a,b)=ax+by 对应到本题当中，由于e1、e2互为素数，因此gcd(e1,e2)=1，从而存在s1、s2使得: s1 * e1 + s2 * e2 = 1 ¶推导过程 m = m % n m = m^(s1 * e1 + s2 * e2)^ % n m = m^(e1 * s1)^ * m^(e2 * s2)^ % n m = (m^(e1 * s1)^ % n) * (m^(e2 * s2)^ % n) % n m = (c1s1 % n) * (c2s2 % n) % n ¶EXP &lt;!–code￼1–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"BUU刷题日记20221020","slug":"BUU刷题日记20221020","date":"2022-10-19T16:00:00.000Z","updated":"2022-12-06T07:25:59.850Z","comments":true,"path":"2022/10/20/BUU刷题日记20221020/","link":"","permalink":"https://sch01ar.github.io/2022/10/20/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221020/","excerpt":"","text":"RSA1 给定dp、dq类型 dp ≡ d mod (p-1) dq ≡ d mod (q-1) m ≡ cd mod n m = cd + k * n m = cd +k * p * q 对上式两端同时对p、q分别取余，得：（中国剩余定理） m1 ≡ cd mod p m2 ≡ cd mod q 同理，可得到 cd = m1 +k * p 代入到 m2 ≡ cd mod q 中： m2 ≡ (m1 + k * p)mod q ，两端减去m1得 m2 - m1 ≡ k * p mod q ，两端乘p的逆元得 (m2 - m1)p-1 ≡ k mod q 将k代入到 cd = m1 +k * p 中得： cd = m1 + ((m2 - m1)p-1 mod q) * p m=cd mod n 得到 m ≡ (((m2 - m1) * p-1 mod q) * p + m1) mod n 接下来就是求解m1，m2 m1 ≡ cdp+k(p-1) mod p m2 ≡ cdq+k(q-1) mod q 根据费马小定理 若p是素数，则a(p-1) ≡ 1 mod p 因此 m1 ≡ cdp mod p，m2 ≡ cdq mod q 最终可求得m ¶exp &lt;!–code￼0–&gt; RSAROLL &lt;!–code￼1–&gt; 给了一个data.txt文件，打开盲猜一下第一行是n，e，后面是c &lt;!–code￼2–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"2021ByteCTF-easyxor","slug":"2021ByteCTF-easyxor","date":"2022-10-15T16:00:00.000Z","updated":"2022-12-07T09:34:59.756Z","comments":true,"path":"2022/10/16/2021ByteCTF-easyxor/","link":"","permalink":"https://sch01ar.github.io/2022/10/16/2021ByteCTF-easyxor/","excerpt":"","text":"题目源码如下 &lt;!–code￼0–&gt; 题目分析 将flag分为两段，前半段采用OFB加密，后半段采用CBC加密 ¶OFB解密 将前半段flag又进行切分，将其8位分为一组，存到group数组中。 &lt;!–code￼1–&gt; 针对一个随机生成的64位的last，与keys进行convert加密，再与group中的数进行异或。 keys是四个-32～32的数，可爆破。 对于OFB解密十分简单，因为我们已知第一组明文，恰好是8位的’ByteCTF{'，由于分组密码的性质，所以后面的也就迎刃而解，通过group[ 0]^cipher[ 0] 即可得到cur_c，从而求得下一次的cur_c，以此类推。 ¶expOFB &lt;!–code￼2–&gt; ¶CBC解密 针对后半部分，我们需要逆向解出convert函数，因此就是对shift函数中的加密运算进行解密。 之前上网搜的wp都一笔带过，没解释unshift逆函数怎么写的。“难道有什么定理？？” 这里简单写一下我的理解。 ¶分析shift &lt;!–code￼3–&gt; ¶推理过程 这里我们举例k&gt;0时的情况。（k&lt;0同理） m和c都是64位,k是-32～32的10进制数。 1、m &lt;&lt; k相当于在m后补k位0，得到的新数我们称为a，a=m &lt;&lt; k。 2、令b = a &amp; c，由于a是64+k位，c是64位，所以b是64位，并且b的后k位都是0。 3、令x = m ^ b，x则是shift加密之后的值，x也是64位，并且x的后k位是与m的后k位相同的，与0异或得本身。 我们走完了一遍shift加密，得到的结论是，密文的位数同样是64，并且密文的后k位与明文相同。 ¶分析unshift &lt;!–code￼4–&gt; ¶推理过程 同样我们举例k&gt;0的情况。 之前我们得到的密文x，相当于tmp。 1、a’=tmp &lt;&lt; k，tmp后k位为0，tmp后2k～k位等于m的后k位。 2、b’=a’ &amp; c，b’后k位为0，后2k～k位为m&amp;c。 3、y=x ^ b’，y的后k位，等于x的后k位，也就是m的后k位。 4、y的后2k～k位，在shift加密当中，a &amp; c的后2k～k位等于m的后k位&amp;c，记作m1 &amp; c。 shift中的x，也就是m ^ b，m ^(m1 &amp; c)，在unshift最后的一步操作中，y= m ^(m1 &amp; c) ^ b’。 这时我们只考虑y的后2k～k位，y=m ^(m1 &amp; c)^(m1 &amp; c) = m 所以这时y的2k～k位也等于m了。 ¶总结 因此，我们发现每经过unshift一次，就有k位被还原，何时才能被完全还原？即循环bits//k次。 此推理正确，可以在unshift函数运行时输出每次的tmp观察即可。 ps：自我感觉这种位运算应该是属于一种性质或者定理，网上大佬们都是说“简单写个逆”。。。 ¶expCBC &lt;!–code￼5–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"2022BUUCTF新生赛-RSA","slug":"2022BUUCTF新生赛-RSA","date":"2022-10-15T16:00:00.000Z","updated":"2022-12-08T07:35:16.441Z","comments":true,"path":"2022/10/16/2022BUUCTF新生赛-RSA/","link":"","permalink":"https://sch01ar.github.io/2022/10/16/2022BUUCTF%E6%96%B0%E7%94%9F%E8%B5%9B-RSA/","excerpt":"","text":"题目源码 &lt;!–code￼0–&gt; 题目分析 发现n和phin都不常规，没入手点，发现hint，hint=pow(d,e,n)，有趣，用d做明文，尝试推理一下： d = pow(hint,d,n) d = pow((d ** e % n),d,n) d = (d ** e % n) ** d % n d = d ** (e*d) % n d = pow(d ** e,d,n) 把d ** e再次看做密文，可得 d ** e = pow(d,e,n) 因为hint = pow(d,e,n) 可得hint = d ** e d ** e * e ** e-&gt;(ed) ** e-&gt;(ed) ** e == 1 mod phin 因此根据e和hint即可求得phin 从而得到phin和n的最大公约数p 脚本如下 &lt;!–code￼1–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"梦开始的地方","slug":"梦开始的地方","date":"2022-10-15T07:59:58.000Z","updated":"2022-12-01T05:15:04.679Z","comments":true,"path":"2022/10/15/梦开始的地方/","link":"","permalink":"https://sch01ar.github.io/2022/10/15/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/","excerpt":"","text":"¶Mac下利用Hexo和github pages搭建个人博客 ¶环境配置 ¶1.Node.js安装 下载地址：Node.js ¶2.淘宝镜像安装 &lt;!–code￼0–&gt; ¶3.安装Hexo &lt;!–code￼1–&gt; ¶初始化Hexo Blog ¶1.初始化Hexo 新建一个文件夹并进入，例如blog &lt;!–code￼2–&gt; ¶2.本地启动Hexo &lt;!–code￼3–&gt; 浏览器打开网站，即可看到本地博客 ¶创建博客文章 ¶1.创建文章 &lt;!–code￼4–&gt; 在blog文件夹中的_post里即可看到新建的md文件 ¶2.清理缓存项目 在新建博客或修改博客时，需要进行该操作 &lt;!–code￼5–&gt; ¶3.重新生成博客 &lt;!–code￼6–&gt; ¶4.启动博客 &lt;!–code￼7–&gt;","categories":[{"name":"建站","slug":"建站","permalink":"https://sch01ar.github.io/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://sch01ar.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-10-15T07:57:23.442Z","updated":"2022-12-01T05:15:29.274Z","comments":true,"path":"2022/10/15/hello-world/","link":"","permalink":"https://sch01ar.github.io/2022/10/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ¶Quick Start ¶Create a new post &lt;!–code￼0–&gt; More info: Writing ¶Run server &lt;!–code￼1–&gt; More info: Server ¶Generate static files &lt;!–code￼2–&gt; More info: Generating ¶Deploy to remote sites &lt;!–code￼3–&gt; More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sch01ar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"建站","slug":"建站","permalink":"https://sch01ar.github.io/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"},{"name":"非对称加密","slug":"非对称加密","permalink":"https://sch01ar.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"},{"name":"lattice","slug":"lattice","permalink":"https://sch01ar.github.io/tags/lattice/"},{"name":"二叉树","slug":"二叉树","permalink":"https://sch01ar.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://sch01ar.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}