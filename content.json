{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"书单","date":"2022-10-16T02:30:27.247Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-10-16T03:25:28.438Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-10-17T01:02:57.129Z","updated":"2022-10-15T08:09:45.464Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-10-16T02:41:49.050Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-10-16T02:33:21.117Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-10-16T02:33:28.077Z","updated":"2022-10-16T01:15:58.120Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"2022NewStarCTFweek5","slug":"2022NewStarCTFweek5","date":"2022-10-25T16:00:00.000Z","updated":"2022-10-26T07:01:32.242Z","comments":true,"path":"2022/10/26/2022NewStarCTFweek5/","link":"","permalink":"http://example.com/2022/10/26/2022NewStarCTFweek5/","excerpt":"","text":"","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"}]},{"title":"2022 DASCTF 10月挑战赛wp","slug":"2022DASCTF10月挑战赛wp","date":"2022-10-22T16:00:00.000Z","updated":"2022-10-24T00:33:47.654Z","comments":true,"path":"2022/10/23/2022DASCTF10月挑战赛wp/","link":"","permalink":"http://example.com/2022/10/23/2022DASCTF10%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwp/","excerpt":"","text":"RSA 题目如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from Crypto.Util.number import *from secret import flagn_2 = 675835056744450121024004008337170937331109883435712066354955474563267257037603081555653829598886559337325172694278764741403348512872239277008719548968016702852609803016353158454788807563316656327979897318887566108985783153878668451688372252234938716250621575338314779485058267785731636967957494369458211599823364746908763588582489400785865427060804408606617016267936273888743392372620816053927031794575978032607311497491069242347165424963308662091557862342478844612402720375931726316909635118113432836702120449010n_3 = 91294511667572917673898699346231897684542006136956966126836916292947639514392684487940336406038086150289315439796780158189004157494824987037667065310517044311794725172075653186677331434123198117797575528982908532086038107428540586044471407073066169603930082133459486076777574046803264038780927350142555712567e_1 = 65537e_2 = 3c_1 = 47029848959680138397125259006172340325269302342762903311733700258745280761154948381409328053449580957972265859283407071931484707002138926840483316880087281153554181290481533c_2 = 332431c_3 = 11951299411967534922967467740790967733301092706094553308467975774492025797106594440070380723007894861454249455013202734019215071856834943490096156048504952328784989777263664832098681831398770963056616417301705739505187754236801407014715780468333977293887519001724078504320344074325196167699818117367329779609m = 9530454742891231590945778054072843874837824815724564463369259282490619049557772650832818763768769359762168560563265763313176741847581931364k = 8139616873420730499092246564709331937498029453340099806219977060224838957080870950877930756958455278369862703151353509623205172658012437573652818022676431def encrypt1(n): n1 = hex(n&gt;&gt;200).encode() n2 = str(hex(n))[20:].encode() return n1,n2def encrypt2(m , n_1): c_1 = pow(m,e_1,n_1) print(&#x27;c_1 = &#x27;+str(c_1))def encrypt3(m , n_2): c_2 = pow( m , e_2 , n_2) print(&#x27;c_2 = &#x27;+str(c_2))def encrypt4(m): k = getPrime(512) m = m % k c_3 = pow(m, e_2, n_3) print(&#x27;c_3 = &#x27; + str(c_3)) print(&#x27;m = &#x27; + str(m)) print(&#x27;k = &#x27; + str(k))m1,m2 = encrypt1(flag)m1 = bytes_to_long(m1)m2 = bytes_to_long(m2)print(&#x27;n_2 = &#x27; + str(n_2))print(&#x27;n_3 = &#x27; + str(n_3))print(&#x27;e_1 = &#x27; + str(e_1))print(&#x27;e_2 = &#x27; + str(e_2))encrypt2(m1,n_1)encrypt3(n_1,n_2)encrypt4(m2) 题目分析 改题的加密顺序是： 1、加密flag，分为两部分m1、m2 2、加密m1 3、加密m2 同理我们解密的顺序应该也是 1、解出m1、m2 2、解出flag 求m2 先观察一下encrypt4函数 虽然说e_2=3，按理来说使用低加密指数攻击，但并不可行。 又因为m = m % k 可通过这点和c_3 = pow(m, e_2, n_3)做遍历求出m 最后发现m即为m2，m2 &lt; k 求m1 发现m1加密方式采用RSA，但是n_1未知 n_1又通过一次RSA加密，已知n_1对应的密文 利用低加密指数攻击解出n1 发现n1可分解为3个素数乘积 故phi可求，即求出m1 求flag 观察encryt1 m1是flag右移200位之后转为字节 m2是flag的20位之后转成字节 所以来说m2是没什么问题，主要找到flag的前20位，再把m2拼到后面即可。 由于m1是flag右移200位，因此flag的低位缺失，但高位还在，由于不知道flag总长度，抱着试一试的心态，猜测一下它的高位前20位没有缺失 我们将m1和m2转为字节发现 m1:b’0x666c61677b3230366538353964’ m2:b’383539643865383534633466363030636231323735376262663966357d’ 发现m1和m2有重叠部分，即38353开始 可以证实m1前20位确实没有缺失 因此取m1前20位，加m2，即可解出flag EXP 1234567891011121314151617181920212223242526272829303132333435363738394041import mathfrom typing import ByteStringimport gmpy2from Crypto.Util.number import *n_2 = 675835056744450121024004008337170937331109883435712066354955474563267257037603081555653829598886559337325172694278764741403348512872239277008719548968016702852609803016353158454788807563316656327979897318887566108985783153878668451688372252234938716250621575338314779485058267785731636967957494369458211599823364746908763588582489400785865427060804408606617016267936273888743392372620816053927031794575978032607311497491069242347165424963308662091557862342478844612402720375931726316909635118113432836702120449010e_2=3c_1 = 47029848959680138397125259006172340325269302342762903311733700258745280761154948381409328053449580957972265859283407071931484707002138926840483316880087281153554181290481533c_2 = 332431def dec(c,e,n): i=0 while(1): m1=c+n*i result,flag=gmpy2.iroot(m1,e) if flag==True: return result i+=1n_1=70406706457855863712635967741447303613971473150228480705119773604469794649140239446237334040048504811343327173817296308781190911727763110615393368497803655390445303946160971p_1=2732337821e_1 = 65537t_1=2224243981q_1=11585031296201346891716939633970482508158508580350404805965250133832632323150440185890235814142601827544669601048550999405490149435265122374459158586377571phi_1=(p_1-1)*(q_1-1)*(t_1-1)d_1=gmpy2.invert(e_1,phi_1)m1=pow(c_1,d_1,n_1)c=pow(m1,e_1,n_1)n_3 = 91294511667572917673898699346231897684542006136956966126836916292947639514392684487940336406038086150289315439796780158189004157494824987037667065310517044311794725172075653186677331434123198117797575528982908532086038107428540586044471407073066169603930082133459486076777574046803264038780927350142555712567c_3 = 11951299411967534922967467740790967733301092706094553308467975774492025797106594440070380723007894861454249455013202734019215071856834943490096156048504952328784989777263664832098681831398770963056616417301705739505187754236801407014715780468333977293887519001724078504320344074325196167699818117367329779609m = 9530454742891231590945778054072843874837824815724564463369259282490619049557772650832818763768769359762168560563265763313176741847581931364k = 8139616873420730499092246564709331937498029453340099806219977060224838957080870950877930756958455278369862703151353509623205172658012437573652818022676431m2=long_to_bytes(m)print(m2)print(long_to_bytes(m1)[:20])m=0x666c61677b32303665383539643865383534633466363030636231323735376262663966357dprint(long_to_bytes(m))# b&#x27;383539643865383534633466363030636231323735376262663966357d&#x27;# b&#x27;0x666c61677b32303665&#x27;# b&#x27;flag&#123;206e859d8e854c4f600cb12757bbf9f5&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"}]},{"title":"BUU刷题日记20221022","slug":"BUU刷题日记20221022","date":"2022-10-21T16:00:00.000Z","updated":"2022-10-22T12:47:51.674Z","comments":true,"path":"2022/10/22/BUU刷题日记20221022/","link":"","permalink":"http://example.com/2022/10/22/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221022/","excerpt":"","text":"(先表示一下对RNG3:0输掉t1的遗憾，另外，EDG加油) RSA4 题目只给了三组n、c，采用中国剩余定理，具体推导如下 推导过程 m^e ≡ c1 mod n1 m^e ≡ c2 mod n2 m^e ≡ c3 mod n3 中国剩余定理（CRT） 中国剩余定理的内容是： 针对上述方程组，若n1、n2、n3互质，对于任意的c1、c2、c3，方程组都有解，使用条件是m^e &lt; n1、n2、n3。通解形式如下： 令N = n1 * n2 * n3，N1 = N/n1，N2、N3同理 令t1 = N1^(-1)，即其对应的模n1运算的逆元，t2，t3同理，可用t1=gmpy2.invert(N1,n1)表示。 有了Ni和ti的定义，我们就可以给出通解形式： x = c1 * N1 * t1 …… 有了通解公式我们就可以求出m^e，对e进行一下遍历即可，m开方成功即可。 EXP 123456789101112131415161718192021222324252627import gmpy2from sympy.ntheory.modular import crtfrom Crypto.Util.number import long_to_bytese = 3n1 = &#x27;331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004&#x27;c1 = &#x27;310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243&#x27;n2 = &#x27;302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114&#x27;c2 = &#x27;112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344&#x27;n3 = &#x27;332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323&#x27;c3 = &#x27;10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242&#x27;c1=int(c1,5)n1=int(n1,5)c2=int(c2,5)n2=int(n2,5)c3=int(c3,5)n3=int(n3,5)e=3n=[n1,n2,n3]c=[c1,c2,c3]resultant,mod= crt(n, c)# 有现成的库函数可以调用print(gmpy2.iroot(resultant, e))m=259362307225540148883586283191025214233097658309244310540770399135748418469298031742173624766441014006294782333print(long_to_bytes(m))#noxCTF&#123;D4mn_y0u_h4s74d_wh47_4_b100dy_b4s74rd!&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://example.com/tags/diary/"}]},{"title":"BUU刷题日记20221021","slug":"BUU刷题日记20221021","date":"2022-10-20T16:00:00.000Z","updated":"2022-10-21T09:09:16.105Z","comments":true,"path":"2022/10/21/BUU刷题日记20221021/","link":"","permalink":"http://example.com/2022/10/21/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221021/","excerpt":"","text":"RSA2 题目给定n、e、dp、c 非预期解：直接分解n 下面考虑n不能分解的情况 推导过程 dp ≡ d mod (p-1) ed ≡ 1 mod (p-1) * (q-1) ed = 1 + k2(p-1)(q-1) 对1式两端同乘e，得 e * dp ≡ ed mod (p-1) e * dp = k1(p-1) + ed 代入ed得 e * dp = k1(p-1) + 1 + k2(p-1)(q-1) 由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余p-1，即可消掉n e * dp ≡ 1 mod (p-1) e * dp =k(p-1) + 1 得到这个式子后，其实真正意义上的未知数只有我们要求的p，但是还存在一个k。 针对k，我们判断一下他的范围，看看能否采用爆破的方式。 k = (e * dp - 1)/(p-1) 因为dp &lt; p-1 所以k &lt; e 通过遍历k然后找到(e * dp - 1)可以整除k的情况即可。 (跑了一下发现限制条件还不够) 因此再加一个n能否整除p即可。 EXP 1234567891011121314151617181920import gmpy2from Crypto.Util.number import long_to_bytese = 65537n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751# p = 13468634736343473907717969603434376212206335187555458742257940406618189481177835992217885676243155145465521141546915941147336786447889325606555333350540003# q = 18432009829596386103558375461387837845170621179295293289126504231317130550979989727125205467379713835047300158256398009229511746203459540859429194971855371for k in range(1,e): if (e*dp-1)%k == 0: p=(e*dp-1)//k + 1 if n%p == 0: print(p) breakq=n//pphi= (p-1)*(q-1)d= gmpy2.invert(e,phi)m=pow(c,d,n)print(long_to_bytes(m))#flag&#123;wow_leaking_dp_breaks_rsa?_98924743502&#125; RSA3 给定n、e1、c1、e2、c2。 m ≡ c1^e1 mod n m ≡ c2^e2 mod n 这里采用共模攻击，详细原理如下： 扩展欧几里得算法：给定两个整数a、b，必定存在x、y，使得gcd(a,b)=ax+by 对应到本题当中，由于e1、e2互为素数，因此gcd(e1,e2)=1，从而存在s1、s2使得: s1 * e1 + s2 * e2 = 1 推导过程 m = m % n m = m^(s1 * e1 + s2 * e2) % n m = m^(e1 * s1) * m^(e2 * s2) % n m = (m^(e1 * s1) % n) * (m^(e2 * s2) % n) % n m = (c1^s1 % n) * (c2^s2 % n) % n EXP 123456789101112import gmpy2from Crypto.Util.number import long_to_bytesc1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801e1=11187289c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397e2=9647291r,s1,s2=gmpy2.gcdext(e1,e2)m=(pow(c1,s1,n) * pow(c2,s2,n)) %nprint(long_to_bytes(m))#flag&#123;49d91077a1abcb14f1a9d546c80be9ef&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://example.com/tags/diary/"}]},{"title":"BUU刷题日记20221020","slug":"BUU刷题日记20221020","date":"2022-10-19T16:00:00.000Z","updated":"2022-10-21T02:17:03.606Z","comments":true,"path":"2022/10/20/BUU刷题日记20221020/","link":"","permalink":"http://example.com/2022/10/20/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221020/","excerpt":"","text":"RSA1 给定dp、dq类型 dp ≡ d mod (p-1) dq ≡ d mod (q-1) m ≡ cd mod n $$ m = cd + k * n $$ m = cd +k * p * q 对上式两端同时对p、q分别取余，得：（中国剩余定理） m1 ≡ cd mod p m2 ≡ cd mod q 同理，可得到 cd = m1 +k * p 代入到 m2 ≡ cd mod q 中： m2 ≡ (m1 + k * p)mod q ，两端减去m1得 m2 - m1 ≡ k * p mod q ，两端乘p的逆元得 (m2 - m1)p-1 ≡ k mod q 将k代入到 cd = m1 +k * p 中得： cd = m1 + ((m2 - m1)p-1 mod q) * p m=cd mod n 得到 m ≡ (((m2 - m1) * p-1 mod q) * p + m1) mod n 接下来就是求解m1，m2 m1 ≡ cdp+k*(p-1) mod p m2 ≡ cdq+k*(q-1) mod q 根据费马小定理 若p是素数，则a(p-1) ≡ 1 mod p 因此 m1 ≡ cdp mod p，m2 ≡ cdq mod q 最终可求得m exp 1234567891011121314import gmpy2from Crypto.Util.number import long_to_bytesp = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852m1=pow(c,dp,p)m2=pow(c,dq,q)n=p*qp0=gmpy2.invert(p,q)m=(((m2-m1)*p0 % q)* p +m1)%nprint(long_to_bytes(m))#noxCTF&#123;W31c0m3_70_Ch1n470wn&#125; RSAROLL 1234RSA roll！roll！roll！Only number and a-z（don&#x27;t use editorwhich MS provide） 给了一个data.txt文件，打开盲猜一下第一行是n，e，后面是c 1234567891011121314151617import gmpy2from Crypto.Util.number import long_to_bytesn = 920139713e = 19p=18443q=49891phi =(p-1)*(q-1)d=gmpy2.invert(e,phi)c=[704796792,752211152,274704164,18414022,368270835,483295235,263072905,459788476,483295235,459788476,663551792,475206804,459788476,428313374,475206804,459788476,425392137,704796792,458265677,341524652,483295235,534149509,425392137,428313374,425392137,341524652,458265677,263072905,483295235,828509797,341524652,425392137,475206804,428313374,483295235,475206804,459788476,306220148,]m=[]flag=b&#x27;&#x27;for i in range (len(c)): m.append(pow(c[i],d,n)) flag+=long_to_bytes(m[i])print(flag)#flag&#123;13212je2ue28fy71w8u87y31r78eu1e2&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://example.com/tags/diary/"}]},{"title":"2022BUUCTF新生赛-RSA","slug":"2022BUUCTF新生赛-RSA","date":"2022-10-15T16:00:00.000Z","updated":"2022-10-21T02:17:55.524Z","comments":true,"path":"2022/10/16/2022BUUCTF新生赛-RSA/","link":"","permalink":"http://example.com/2022/10/16/2022BUUCTF%E6%96%B0%E7%94%9F%E8%B5%9B-RSA/","excerpt":"","text":"题目源码 123456789101112131415161718from Crypto.Util.number import *import gmpy2m = bytes_to_long(flag)p = getPrime(512)q = getPrime(512)n = p * p * qe = 0x10001d = inverse(e, p * (p-1) * (q-1))assert m &lt; nc = pow(m, e, n)hint = pow(d, e, n)print(f&#x27;c = &#123;c&#125;&#x27;)print(f&#x27;hint = &#123;hint&#125;&#x27;)print(f&#x27;n = &#123;n&#125;&#x27;)#c = 295390424904695335160238045484482823778874523176268561514416832384667341911461624807479360352155340771798064104910086195729675369023485015714514440154903376061747094964841316582559859939271083212458383263813162552258150862316694340739316654325015871916752667846321388549685578217102034863664378037876690856340358410405404601972377258035410485778168718251025950362254734939336524237028597772764421048442121802994478847811235518434239824115849516645106981074204342#hint = 381689393821386814936953643422859595359427105930487728052490073810065861656721298489533943537291889430179955685768552743683931382858386278229412048061640902207419922278984960983464060741314251570306423515751064678573919676919458734440112312205062810416467534525851481716577433432802746104452081670842385746300503903217917867773267569384218933894515975838815295351900841003897643955266573211223356519224254883905741607839206824725522319870208594077622555096443077#n = 1330047950007581682981905423145560321016033324862143764072994099149659943994269827526733343998097272206411640734177032076844564188190644548214106206913310385320478977860962140014336074250277764844699709526956803401392604949854612016074894825128737598849968249437120905834713554348840283463250157701334045079523107114507765969484185723955713386597151991074970735613177368468450679646585239506590480790958808030534070060413924423517044064816910208776798401702408317 题目分析 发现n和phin都不常规，没入手点，发现hint，hint=pow(d,e,n)，有趣，用d做明文，尝试推理一下： d = pow(hint,d,n) d = pow((d ** e % n),d,n) d = (d ** e % n) ** d % n d = d ** (e*d) % n d = pow(d ** e,d,n) 把d ** e再次看做密文，可得 d ** e = pow(d,e,n) 因为hint = pow(d,e,n) 可得hint = d ** e d ** e * e ** e-&gt;(ed) ** e-&gt;(ed) ** e == 1 mod phin 因此根据e和hint即可求得phin 从而得到phin和n的最大公约数p 脚本如下 1234567891011121314from Crypto.Util.number import *import gmpy2import mathe = 0x10001c = 295390424904695335160238045484482823778874523176268561514416832384667341911461624807479360352155340771798064104910086195729675369023485015714514440154903376061747094964841316582559859939271083212458383263813162552258150862316694340739316654325015871916752667846321388549685578217102034863664378037876690856340358410405404601972377258035410485778168718251025950362254734939336524237028597772764421048442121802994478847811235518434239824115849516645106981074204342hint = 381689393821386814936953643422859595359427105930487728052490073810065861656721298489533943537291889430179955685768552743683931382858386278229412048061640902207419922278984960983464060741314251570306423515751064678573919676919458734440112312205062810416467534525851481716577433432802746104452081670842385746300503903217917867773267569384218933894515975838815295351900841003897643955266573211223356519224254883905741607839206824725522319870208594077622555096443077n = 1330047950007581682981905423145560321016033324862143764072994099149659943994269827526733343998097272206411640734177032076844564188190644548214106206913310385320478977860962140014336074250277764844699709526956803401392604949854612016074894825128737598849968249437120905834713554348840283463250157701334045079523107114507765969484185723955713386597151991074970735613177368468450679646585239506590480790958808030534070060413924423517044064816910208776798401702408317p=math.gcd((hint*pow(e,e) -1),n)q=n//(p**2)phi=p*(p-1)*(q-1)d=gmpy2.invert(e,phi)m=pow(c,d,n)print(long_to_bytes(m))#flag&#123;43075d24-77a7-4f57-ae89-54fe4f96db69&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"}]},{"title":"2021ByteCTF-easyxor","slug":"2021ByteCTF-easyxor","date":"2022-10-15T16:00:00.000Z","updated":"2022-10-21T02:18:02.554Z","comments":true,"path":"2022/10/16/2021ByteCTF-easyxor/","link":"","permalink":"http://example.com/2022/10/16/2021ByteCTF-easyxor/","excerpt":"","text":"[TOC] 题目源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#! /usr/bin/env pythonfrom Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randint, getrandbitsdef shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; cdef convert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(4): m = shift(m, key[t], c_list[t]) return mdef encrypt(m, k, iv, mode=&#x27;CBC&#x27;): assert len(m) % 8 == 0 num = len(m) // 8 groups = [] for i in range(num): groups.append(bytes_to_long(m[i * 8: (i + 1) * 8])) last = iv cipher = [] if mode == &#x27;CBC&#x27;: for eve in groups: cur = eve ^ last cur_c = convert(cur, k) cipher.append(cur_c) last = cur_c elif mode == &#x27;OFB&#x27;: for eve in groups: cur_c = convert(last, k) cipher.append(cur_c ^ eve) last = cur_c else: print &#x27;Not supported now!&#x27; return &#x27;&#x27;.join([hex(eve)[2:].strip(&#x27;L&#x27;).rjust(16, &#x27;0&#x27;) for eve in cipher])if __name__ == &#x27;__main__&#x27;: from secret import flag if len(flag) % 8 != 0: flag += &#x27;$&#x27; * (8 - len(flag) % 8) length = len(flag) num = length // 8 keys = [randint(-32, 32) for _ in range(4)] IV = getrandbits(64) front = flag[:length // 2] back = flag[length // 2:] cipher1 = encrypt(front, keys, IV, mode=&#x27;OFB&#x27;) cipher2 = encrypt(back, keys, IV) print cipher1 + cipher2#89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912 题目分析 将flag分为两段，前半段采用OFB加密，后半段采用CBC加密 OFB解密 将前半段flag又进行切分，将其8位分为一组，存到group数组中。 123456#主要加密代码elif mode == &#x27;OFB&#x27;: for eve in groups: cur_c = convert(last, k) cipher.append(cur_c ^ eve) last = cur_c 针对一个随机生成的64位的last，与keys进行convert加密，再与group中的数进行异或。 keys是四个-32～32的数，可爆破。 对于OFB解密十分简单，因为我们已知第一组明文，恰好是8位的’ByteCTF{'，由于分组密码的性质，所以后面的也就迎刃而解，通过group[ 0]^cipher[ 0] 即可得到cur_c，从而求得下一次的cur_c，以此类推。 expOFB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#OFB解密#! /usr/bin/env pythonfrom Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randint, getrandbitsdef shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; cdef convert(m, key): c_list = [ 0x37386180AF9AE39E, 0xAF754E29895EE11A, 0x85E1A429A2B7030C, 0x964C5A89F6D3AE8C, ] for t in range(4): m = shift(m, key[t], c_list[t]) return mdef check(s): c=1 for i in s: if 32&lt;=i&lt;=127: continue else: c=0 break return cc = &quot;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912&quot;c=c[:len(c)//2]cipher = []for i in range(len(c)//16): cipher.append(int(c[i*16:(i+1)*16],16))flag = b&#x27;ByteCTF&#123;&#x27;m0 = bytes_to_long(flag)m_m = m0 ^ cipher[0]for a in range(-32,32): for b in range(-32,32): for c in range(-32,32): for d in range(-32,32): keys=[a,b,c,d] m_m1=convert(m_m,keys) m1=long_to_bytes((m_m1^cipher[1])) if check(m1): m_m2 = convert(m_m1, keys) m2 = long_to_bytes((m_m2 ^ cipher[2])) if check(m2): flag+=m1 flag+=m2 print(flag) print(a,b,c,d)#b&#x27;ByteCTF&#123;5831a241s-f30980&#x27;#keys：-12 26 -3 -31 CBC解密 针对后半部分，我们需要逆向解出convert函数，因此就是对shift函数中的加密运算进行解密。 之前上网搜的wp都一笔带过，没解释unshift逆函数怎么写的。“难道有什么定理？？” 这里简单写一下我的理解。 分析shift 1234def shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; c 推理过程 这里我们举例k&gt;0时的情况。（k&lt;0同理） m和c都是64位,k是-32～32的10进制数。 1、m &lt;&lt; k相当于在m后补k位0，得到的新数我们称为a，a=m &lt;&lt; k。 2、令b = a &amp; c，由于a是64+k位，c是64位，所以b是64位，并且b的后k位都是0。 3、令x = m ^ b，x则是shift加密之后的值，x也是64位，并且x的后k位是与m的后k位相同的，与0异或得本身。 我们走完了一遍shift加密，得到的结论是，密文的位数同样是64，并且密文的后k位与明文相同。 分析unshift 12345678910def unshift(m, k, c, bits=64): tmp = m if k &lt; 0: for i in range(bits // (-k)): tmp = m ^ tmp &gt;&gt; (-k) &amp; c else: for i in range(bits // k): tmp = m ^ tmp &lt;&lt; k &amp; c assert shift(tmp, k, c) == m return tmp 推理过程 同样我们举例k&gt;0的情况。 之前我们得到的密文x，相当于tmp。 1、a’=tmp &lt;&lt; k，tmp后k位为0，tmp后2k～k位等于m的后k位。 2、b’=a’ &amp; c，b’后k位为0，后2k～k位为m&amp;c。 3、y=x ^ b’，y的后k位，等于x的后k位，也就是m的后k位。 4、y的后2k～k位，在shift加密当中，a &amp; c的后2k～k位等于m的后k位&amp;c，记作m1 &amp; c。 shift中的x，也就是m ^ b，m ^(m1 &amp; c)，在unshift最后的一步操作中，y= m ^(m1 &amp; c) ^ b’。 这时我们只考虑y的后2k～k位，y=m ^(m1 &amp; c)^(m1 &amp; c) = m 所以这时y的2k～k位也等于m了。 总结 因此，我们发现每经过unshift一次，就有k位被还原，何时才能被完全还原？即循环bits//k次。 此推理正确，可以在unshift函数运行时输出每次的tmp观察即可。 ps：自我感觉这种位运算应该是属于一种性质或者定理，网上大佬们都是说“简单写个逆”。。。 expCBC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randint, getrandbitsdef shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; cdef unconvert(m, key): tmp = m c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(3,-1,-1): m = unshift(m, key[t], c_list[t]) return mdef unshift(m, k, c, bits=64): tmp = m if k &lt; 0: for i in range(bits // (-k)): tmp = m ^ tmp &gt;&gt; (-k) &amp; c else: for i in range(bits // k): tmp = m ^ tmp &lt;&lt; k &amp; c assert shift(tmp, k, c) == m return tmpkeys=[-12,26,-3,-31]c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c]flag=b&#x27;ByteCTF&#123;&#x27;flag=bytes_to_long(flag)iv=16476971533267772345c = &quot;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912&quot;c=c[len(c)//2:]cipher = []for i in range(len(c)//16): cipher.append(int(c[i*16:(i+1)*16],16))group=[]curc1=unconvert(cipher[0],keys)group.append(long_to_bytes(curc1^iv))curc2=unconvert(cipher[1],keys)group.append(long_to_bytes(curc2^cipher[0]))curc3=unconvert(cipher[2],keys)group.append(long_to_bytes(curc3^cipher[1]))group[0]+=group[1]group[0]+=group[2]print(group[0])#b&#x27;q535af-2156547475u2t&#125;$$$&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"}]},{"title":"梦开始的地方","slug":"梦开始的地方","date":"2022-10-15T07:59:58.000Z","updated":"2022-10-16T05:22:27.882Z","comments":true,"path":"2022/10/15/梦开始的地方/","link":"","permalink":"http://example.com/2022/10/15/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/","excerpt":"","text":"Mac下利用Hexo和github pages搭建个人博客 环境配置 1.Node.js安装 下载地址：Node.js 2.淘宝镜像安装 12//打开终端terminal$ npm install -g cnpm --registry=https://registry.npm.taobao.org 3.安装Hexo 1234// 使用命令去安装Hexocnpm install -g hexo-cli//安装成功后查看版本hexo -v 初始化Hexo Blog 1.初始化Hexo 新建一个文件夹并进入，例如blog 12//初始化hexohexo init 2.本地启动Hexo 1hexo s 浏览器打开网站，即可看到本地博客 创建博客文章 1.创建文章 1hexo n &quot;我的第一篇文章&quot; 在blog文件夹中的_post里即可看到新建的md文件 2.清理缓存项目 在新建博客或修改博客时，需要进行该操作 1hexo clean 3.重新生成博客 1hexo g 4.启动博客 1hexo d","categories":[{"name":"建站","slug":"建站","permalink":"http://example.com/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-10-15T07:57:23.442Z","updated":"2022-10-15T07:57:23.442Z","comments":true,"path":"2022/10/15/hello-world/","link":"","permalink":"http://example.com/2022/10/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"建站","slug":"建站","permalink":"http://example.com/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"diary","slug":"diary","permalink":"http://example.com/tags/diary/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}