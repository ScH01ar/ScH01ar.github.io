{"meta":{"title":"Y's blog","subtitle":"","description":"","author":"Roo1e","url":"https://sch01ar.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-12-10T07:36:44.999Z","updated":"2022-12-02T03:15:20.960Z","comments":false,"path":"about/index.html","permalink":"https://sch01ar.github.io/about/index.html","excerpt":"","text":"🐭🐭"},{"title":"Repositories","date":"2022-10-16T03:25:28.438Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"repository/index.html","permalink":"https://sch01ar.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-10-16T02:33:21.117Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"categories/index.html","permalink":"https://sch01ar.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-10-16T02:41:49.050Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"tags/index.html","permalink":"https://sch01ar.github.io/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-10-16T02:30:27.247Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"books/index.html","permalink":"https://sch01ar.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-10-17T01:02:57.129Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"links/index.html","permalink":"https://sch01ar.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"NKCTF2023","slug":"2023NKCTF","date":"2023-04-03T02:05:45.000Z","updated":"2023-04-03T11:34:15.402Z","comments":true,"path":"2023/04/03/2023NKCTF/","link":"","permalink":"https://sch01ar.github.io/2023/04/03/2023NKCTF/","excerpt":"","text":"数字中国 Babysecret &lt;!–code￼0–&gt; NKCTF2023 ¶babyRSA 题目 &lt;!–code￼1–&gt; ¶题目分析 题目后半部分是 dp 泄露，通过 N、e、dP 可求出 P、Q &lt;!–code￼2–&gt; ¶法一 之后要通过$P = mp;mod;n$与$Q=mq; mod ;n$来求解 m，下面进行一些数学推导 $$ c_1q=m{pq};mod;n\\\\ c_1{pq}=c_2{p2};mod;n\\\\\\ c_1{pq}=c_2{p2};mod;p\\\\ $$ 根据费马小定理转换可得 $$ c_1n=c_2p;mod;p\\\\ gcd(c_1^n-c_2,n);=;p\\\\ $$ 求出 p 和 q 后，使用 crt 即可求得 m &lt;!–code￼3–&gt; ¶法二 通过推导将原式转换为 $$ PQ=(k_1p+m)(k_2q+m)\\\\ m(P+Q)=2m^2+(k_1p+k_2q)m\\\\ PQ-m(P+Q)+m^2=k_1k_2n\\\\ PQ-m(c_1+c_2)+m^2=0;mod;n $$ &lt;!–code￼4–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"DUTCTF2023","slug":"DUTCTF2023","date":"2023-03-28T02:05:45.000Z","updated":"2023-03-28T09:29:06.114Z","comments":true,"path":"2023/03/28/DUTCTF2023/","link":"","permalink":"https://sch01ar.github.io/2023/03/28/DUTCTF2023/","excerpt":"","text":"DUTCTF2023wp ¶写在前面 仔细一想自己学 CTF 也一年了，纪念一下最后一次参加校赛 🥹，明年可就是出题人了 🤓。但是感觉一年以来荒废了很多时间，在很多方面对题目不熟悉，总跑偏，甚至是自己复现过的一些方法都没意识到（hint 太到位了 😭）。 ¶Crypto 第一次 ak，好爽 😭 ¶*老滚五 百度搜龙语，耐心对着找就出了DUTCTF&#123;YOU_ARE_A_REAL_DRAGONBORN&#125; ¶*神奇的短信 诺基亚手机，9 键，第一位代表哪个键，第二个代表第几个字母，DUTCTF&#123;SCREW&#125; ¶随机数的力量 可先了解一下 MT19937 伪随机数原理，然后看一下破解方法，对于梅森旋转算法之前博客也详细推导过。这里针对题目分析一下，首先 ban 掉了 32 位的预测方法，通过了解到，randcrack库实际上是通过收取特定位数来实现预测，例如 32 位数，就需要 624 个，那么如果使用 64 位数，应该就需要 312 个。后续只要对收取的数字进行一下处理，转成 624 个 32 位数即可。 这里还有一个疑问就是，最大的 64 位数是$2{64}-1$，但是如果传$name=2{64}-1$就无法预测，而改成其余略小一点的 64 位数即可。 ¶exp &lt;!–code￼0–&gt; ¶shamir 直接找脚本跑，具体如何恢复 a0 系数就不细说了。之前 hitcon 有个也是 shamir 的题，也挺有意思的。babysss &lt;!–code￼1–&gt; ¶ECC1 发现是 ECDSA 类型，于是现学。。。下面写一下 ECDSA 的签名与验证过程。 ¶场景 Alice 想要使用她的私钥$d_A$来签名，Bob 想用 Alice 的公钥 $H_A$要验证签名$H_A=d_AG$。 只有 Alice 才能提供正确的签名，而每个人都可以验证签名。 ¶签名 1.选定一条椭圆曲线$E_p(a,b)$。 2.选取一个随机数$k,1&lt;k&lt;n-1$，$n$为椭圆曲线的阶。 3.选取椭圆曲线的基点$G(a,b)$,计算 $K=k * G(a,b)$，令$r=K[0]\\mod n$，即 r 是 K 点的横坐标（若 r 为 0，重新选 k 进行计算）。 4.计算明文 M 的哈希，令$e=hash(M)$，计算$s=k^{-1}(z+rd_A)\\mod n$。 5.给出签名$(r,s)$ ¶验证 1.计算 $u_1=s^{-1}z\\mod n$ 2.计算 $u_2=s^{-1}r\\mod n$ 3.计算点$P=u_1G+u_2H_A$ 当$r=x_P\\mod n$时，签名验证成功。 ¶解题过程 通过对题目的初步阅读，发现关键是求出私钥d=privkey，而想要求出$d$就要求出$k$，虽然$k$ 是以随机数的形式出现，但发现本题中每次签名过程的 k 并不是完全随机，而是线性伪随机$k = (a * k + b)\\mod n$。这里我很想把$k$求出来，然后再去求私钥$d$。所以有没有一种可能，不用求$k$，如果把$k$消掉，方程里只剩一个未知数$d$，即可。细心一点进行数学推导，就会发现答案。 $$k_1s_1=e+r_1d\\mod n$$ $$k_2s_2=e+r_2d\\mod n$$ $$k_2=ak_1+b\\mod n$$ $$k_2=ak_1+b+xn$$ $$s_1s_2k_2=s_1s_2ak_1+s_1s_2b+s_1s_2xn$$ $$s_1(e+r_2d)=s_2a(e+r_1d)+s_1s_2b \\mod n$$ $$d=(s_1r_2-s_2ar_1)^{-1}(s_2ae-s_1e+s_1s_2b)\\mod n$$ 这里两次的使用的$e$一样，是因为传的明文一样，$n$对应的是题目里给的$order$。这里还想说一下自己因为不细致走过的弯路，题目里通过$p$定义的曲线，所以误以为$curve.order$是$p$，这样就会导致前两个式子和第三个算式的模数不同。有趣的是，找到了一篇论文和文章进行了实现。 论文 但其实$curve.order=order$所以上述所有都是在模$order的条件下$，所以进行一下推导就出了。 ¶exp &lt;!–code￼2–&gt; ¶ECC2 hint:二元 copper 看到 hint 瞬间知道怎么做了，前段时间刚学了一下多元 copper，感慨一下还是运用不熟练，没有一眼发现。 ¶解题思路 同样是 ECDSA，相比于上题来说，k 是随机的，但是每次签名的时候会泄露 k 的高位。此题另外一个关键是，$r$是由私钥$d$生成的，所以不管传什么明文，所得到的$r$是一样的，利用这一点，我们可以构造一个二元方程。 $$s_1k_1=z_1+dr \\mod n$$ $$s_2k_2=z_2+dr \\mod n$$ $$k=kh+kl$$ $$s_1(k_1h+k_1l)-z_1=s_2(k_2h+k_2l)-z_2 \\mod n$$ $$f(k_1l,k_2l)=s_1(k_1h+k_1l)-z_1-s_2(k_2h+k_2l)+z_2$$ 随后使用多元 copper 进行求解。具体可看上篇博客。 &lt;!–code￼3–&gt; ¶ez_RSA hint 1:论文 hint 2: &lt;!–code￼4–&gt; ¶解题思路 通过论文，前半部分白给，按照论文造格，即可规约出$_P$。 接下来的问题就是如何求$_E$ $$c=rh+m \\mod p$$ $$h=f^{-1}g \\mod p$$ 将一式带入二式 $$c=r(f^{-1}g)+m \\mod p$$ $$cf=rg+mf \\mod p$$ 因为 r 是 1024 位，g 是 768 位，f 是 1024 位，m 是 128 位，p 是 2048 位，所以 $$rg+mf \\mod p=rg+mf$$ $$cf \\mod p=rg+mf$$ 两边同时对$g$取模，即可消去未知数$r$，得到 $$m=(f*c \\mod p)*f^{-1} \\mod g$$ ¶exp &lt;!–code￼5–&gt; ¶misc ¶*签到 b 站 21 级 pwn 例会评论区 ¶我在哪 放大图片看到十八中，搜索临江十八中，发现是重庆十八中，地图上搜一下附近地铁站，挨着桥的就是，曾家岩。 ¶不要更新 流量分析题，wireshark 里过滤一下 http，找到 github 网页 根据 hint 查看历史提交记录，发现假 flag，对于密码手来说一眼凯撒，移位 13。 ¶web ¶*Trenja F12 打开开发者工具，搜索 flag 字段即可。 ¶pwn ¶*中间人 太好玩了，原理是汽车滚动码。bob 来开车门，截断，开门失败。bob 再开车门，截断，发送第一次截断信号，bob 开门成功。bob 离开，我们发送第二次截断的信号，打开车门！ ¶reverse ¶*贪吃蛇 拖入 IDA，alt+t 搜索 DUT 即可 ¶*GAME 下棋赢了就出了","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"Coppersmith相关攻击","slug":"Coppersmith攻击","date":"2023-03-07T02:05:45.000Z","updated":"2023-03-23T07:22:43.941Z","comments":true,"path":"2023/03/07/Coppersmith攻击/","link":"","permalink":"https://sch01ar.github.io/2023/03/07/Coppersmith%E6%94%BB%E5%87%BB/","excerpt":"","text":"原理 Coppersmith 定理是在一个 e 阶模 n 的多项式$f(x)$中，若有根小于$n^{\\frac{1}{e}}$，则可以用 O(log n)的算法求出根。 直接求解$f(x)$的根可能比较困难，在此利用LLL算法求得多项式$g(x)$，求得的多项式与$f(x)$具有相同的根$x_0$，$g(x)$具有更小的系数，且定义域为整数域。 本质思想就是把有限域上的方程转化到整数域。 理论基础 $$f(x,y) = \\sum_{i=0}{d}\\sum_{j=0}{e} a_{i,j}xiyj$$ ¶Howgrave-Graham 需要构造一个系数更小的多项式，$||g(x)||$代表范数，即最大的系数。构造方法如下 ¶LLL 算法 格基约化算法，通过对构造出的格，从而约化产生符合约束的多项式。 ¶p 高位攻击 &lt;!–code￼0–&gt; ¶dp 高位攻击 给定$e,n,c,dp_0,k,;dp_0=dp&gt;&gt;k$ $$ edp\\equiv ed\\equiv 1;mod;(p-1)\\ edp=k(p-1)+1\\ edp+k-1=kp\\ edp+k-1 \\equiv 0; mod; p\\ \\because dp&lt; p-1\\ \\because edp=k(p-1)+1\\ \\therefore e&gt;k\\ \\therefore e(dp_0 &lt;&lt; k+x)+k-1 \\equiv 0;mod;p $$ &lt;!–code￼1–&gt; ¶EXP &lt;!–code￼2–&gt; ¶多元 coppersmith 原理学习 论文学习 1、 论文学习 2 脚本来源 &lt;!–code￼3–&gt; 具体参数说明，例如 &lt;!–code￼4–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"DLP中常用算法","slug":"DLP中常用算法","date":"2023-02-24T10:05:45.000Z","updated":"2023-03-04T06:03:05.157Z","comments":true,"path":"2023/02/24/DLP中常用算法/","link":"","permalink":"https://sch01ar.github.io/2023/02/24/DLP%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","excerpt":"","text":"Pohlig-Hellman 算法（光滑阶） 给定 a,b,p，p 是素数，求 x，$a^x \\equiv b (mod;p)$ 在模 p 下，设该群的生成元为 g，则有 $$ a \\equiv g^{a1} (mod;p) \\newline b \\equiv g^{b1} (mod;p) $$ 联立条件有 $$ g^{a1x} \\equiv g^{b1} (mod;p) $$ 由欧拉定理得$\\phi§;=;p-1$，则有$a1x;=b1;(mod;(p-1))$ 1.将 p-1 分解，即 $p-1=p_1{k_1}p_2{k_2}\\cdots p_m^{k_m}$ 2.将 x 表示成$p_i$ 进制, 列出方程 $$x;=p_i^0a_0 + p_i1a_1+…+p_i{k_i-1}a*{k_i-1}$$ 3.令 r=1，求$(ax){\\frac{p-1}{p_i^r}}; \\equiv b{\\frac{p-1}{p_ir}}(mod; p)$ 4.将 2 中的公式代入到 3，展开得到 $$a^{a0*\\frac{p-1}{p_i}}* a^{(p-1)a1} * a{(p-1)p_ia_2}…a{(p-1)p_i^{k_i-2}a_{k_i-1}} \\equiv b^{\\frac{p-1}{p_i}}(mod;p)$$ 5.从第二项开始，后面每项都是 1，欧拉定理:$a^{(p-1)} \\equiv 1(mod;p)$，化简得到的式子为 $$\\newline a^{a0*\\frac{p-1}{p_i}} \\equiv b^{\\frac{p-1}{p_i}}(mod ;p)\\newline$$ 因为该方程只有 a0 未知，所以可在[0,pi-1]范围内爆破出 a0 6.再令 r = 2,3,4…ki，重复步骤 3，即可求出所有的$a_2,a_3…a_{k_i-1}$，从而得到 m 个关于 x 的方程，最后使用 CRT 进行求解即可。 总结:将 p-1 的 m 个质因子，分别求出其方程内的所有系数 a，从而构造了 m 个关于 x 的方程，最终利用 CRT 求解。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"近期","slug":"近期","date":"2023-02-20T06:05:45.000Z","updated":"2023-03-04T06:00:15.740Z","comments":true,"path":"2023/02/20/近期/","link":"","permalink":"https://sch01ar.github.io/2023/02/20/%E8%BF%91%E6%9C%9F/","excerpt":"","text":"ECC 常用方程（维尔斯特拉斯标准形式） $y2;=x3+ax+b$，判别式$\\Delta=-16(4a3+27b2);mod;p=0$ ¶sage 环境 进行简单运算 &lt;!–code￼0–&gt; ¶ECDLP 给定椭圆曲线 E，已知 P、Q 以及$Q=kP$，求 k。 &lt;!–code￼1–&gt; ¶crypto-sign-in-1(VNCTF2023) 一道 ECDLP 题目，当时想到使用Pohlig-Hellman算法，但是一直没能找到合适的 A、B 来确定 G 的阶 n，赛后看大佬 wp，果然是用 pwntools 远程多试几组 y1、y2，找到光滑的阶，从而解密成功。 &lt;!–code￼2–&gt; ¶EXP &lt;!–code￼3–&gt; ¶singular attack 利用曲线上的奇异点进行攻击，奇点就是该点导数不存在，或者导数为 0 但不是极值点。 若椭圆曲线的判别式$\\Delta=-16(4a3+27b2);mod;p=0$，说明该曲线有奇点。 ¶RWCTF2023 体验赛 &lt;!–code￼4–&gt; 根据题目，可得到曲线关于 x 的导数，$3x2+4x+1$，所以可得到方程为$y2=x3+2x2+x+C$ 题目已知点(4,10)在曲线上，代入得到 100 = 64 + 32 + 4 + C，即 C = 0，所以方程确定$y2=x3+2x^2+x$ 方程左右求导得到$2y \\frac{dy}{dx}=3x^2+4x+1$，所以当 y=0 时导数不存在，再把 y=0 代入方程，求得 x=-1，所以找到该曲线的奇点为(-1,0)。 下一步我们把曲线平移，使得曲线以(0,0)为奇点，得到y^2 = x^3 + 193387944202565886198256260591909756040*x^2，改写为y^2 = (x + 193387944202565886198256260591909756040) * x^2 因为193387944202565886198256260591909756040 = pow(89654903351345918131227153390056628523,2,p) 我们就可把 P、Q 点映射到乘法群上，从而进行简单的对数计算。 映射法则如下: $$(x,y)\\rightarrow\\frac{y+tx}{y-tx}$$ ¶EXP &lt;!–code￼5–&gt; RSA ¶DLP ¶magic(hitcon2021) &lt;!–code￼6–&gt; ¶EXP ¶rabin 适用于 RSA 中 e=2 的情况 ¶pqpq(seccon2022) &lt;!–code￼7–&gt; ¶大致思路 根据题目，可先通过计算 c1、c2 表达式，合并找出公因子，即可求出 p、q，从而 r 也可求得。 发现 e=65537 * 2，因此是无逆元存在的，索性就将 e 拆分为 65537 与 2，e2=2 时便可通过 Rabin 算法解密。 ¶求 p、q、r $c2 = (p - q)^e \\mod n \\$ 左右同乘 r $c2 * r = rp^e + rq^e + X*pqr = rp^e + rq^e \\mod n\\$ $c2 = p^e + q^e \\mod n\\$ 同理得到$c1 = p^e - q^e \\mod n \\$ 从而求得 p、q $p=gcd(c1+c2,n)\\$ $q=gcd(c1-c2,n)\\$ ¶求解 m^2 $\\phi(n)=(p-1)(q-1)(r-1)\\$ 通过 e1(e/2)和$\\phi(n)$求出 d，得到$cmd=m{2e1d}=m^2 \\mod n$ ¶Rabin 解密 接下来就是传统 Rabin 解密，找了两种脚本，exp 中的sqrtPrime(n,p)和Tonelli_Shanks(n,p)任选其一即可，都是基于二次剩余定理所实现的解密算法 &lt;!–code￼8–&gt; ¶parity","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"RSA补充","slug":"RSA补充","date":"2022-12-07T13:05:45.000Z","updated":"2023-02-09T09:15:46.189Z","comments":true,"path":"2022/12/07/RSA补充/","link":"","permalink":"https://sch01ar.github.io/2022/12/07/RSA%E8%A1%A5%E5%85%85/","excerpt":"","text":"回顾 RSA 中加、解密： 加密$c = m^e\\quad mod\\quad n$ 解密$m = c^d\\quad mod\\quad n$ 接下来证明一下解密过程，先引入欧拉定理。 ¶欧拉定理 对于互为质数的 m、n 两个数，有$m^{\\phi(n)} = 1\\quad mod\\quad n$，其中$\\phi(n)$表示小于 n 的质数的个数。 ¶解密原理 通过$c = m^e\\quad mod\\quad n$与欧拉定理$m^{\\phi(n)} = 1\\quad mod\\quad n$，我们便可进行推导。 对欧拉定理进行变形，得到$m^{k\\phi(n)+1} = m\\quad mod\\quad n$ 因为我们已经知道$c = m^e\\quad mod\\quad n$，所以寻找一个 d，使得$ed = k\\phi(n)+1$,则可以得到$m^{ed}=m\\quad mod \\quad n$ 则得到了$c^d =m\\quad mod\\quad n$ 共模攻击 所谓共模，就是 n 相同，会对应多组 c，e。 例：给定 n、c1、c2、e1、e2 m = c1e1 mod n m = c2e2 mod n ¶扩展欧几里得算法 给定两个整数 a、b，必定存在 x、y，使得 gcd(a,b)=ax+by 运用该算法推导过程 m = m % n m = ms1e1+s2e2 % n m = (me1s1 * me2s2)% n m = (me1s1 % n) * (me2s2 % n) % n m = (c1s1 % n) * (c2s2 % n) % n ¶EXP &lt;!–code￼0–&gt; 低加密指数广播攻击 特点是 e 小，有多组 n，对应了多组 c me = c1 mod n1 me = c2 mod n2 me = c3 mod n3 ¶中国剩余定理(CRT) 定理内容如下 针对上述方程组，若 n1、n2、n3 互质，对于任意的 c1、c2、c3，方程组都有解 m。 使用条件是 m^e &lt; n1、n2、n3。通解推导如下： 设$N=n_1 \\times n_2 \\times n_3, N_1=N/n_1, N_2=N/n_2, N_3=N/n_3$ 设$t_i=N_i^{-1}$,这里表示$t_i$是$N_i$在模$n_i$的逆元。 有了以上几个数，我们可以给出通解形式： $$m=c_1t_1N_1+c_2t_2N_2+c_3t_3N_3+kN=kN+\\sum_{i=1}^3c_it_iN_i$$ 在模 N 后，只剩唯一解$m=\\sum_{i=1}^3c_it_iN_i$ ¶EXP &lt;!–code￼1–&gt; dp、dq 相关 ¶给定 dp、dq 类型 dp ≡ d mod (p-1) dq ≡ d mod (q-1) m ≡ cd mod n m = cd + k * n m = cd +k _ p _ q 对上式两端同时对 p、q 分别取余，得：（中国剩余定理） m1 ≡ cd mod p m2 ≡ cd mod q 同理，可得到 cd = m1 +k * p 代入到 m2 ≡ cd mod q 中： m2 ≡ (m1 + k * p)mod q ，两端减去 m1 得 m2 - m1 ≡ k * p mod q ，两端乘 p 的逆元得 (m2 - m1)p-1 ≡ k mod q 将 k 代入到 cd = m1 +k * p 中得： cd = m1 + ((m2 - m1)p-1 mod q) * p m=cd mod n 得到 m ≡ (((m2 - m1) _ p-1 mod q) _ p + m1) mod n 接下来就是求解 m1，m2 m1 ≡ cdp+k(p-1) mod p m2 ≡ cdq+k(q-1) mod q 根据费马小定理 若 p 是素数，则 a(p-1) ≡ 1 mod p 因此 m1 ≡ cdp mod p，m2 ≡ cdq mod q 最终可求得 m ¶EXP &lt;!–code￼2–&gt; ¶只给定 dp dp ≡ d mod (p-1) ed ≡ 1 mod (p-1) * (q-1) ed = 1 + k2(p-1)(q-1) 对 1 式两端同乘 e，得 e * dp ≡ ed mod (p-1) e * dp = k1(p-1) + ed 代入 ed 得 e * dp = k1(p-1) + 1 + k2(p-1)(q-1) 由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余 p-1，即可消掉 n e * dp ≡ 1 mod (p-1) e * dp =k(p-1) + 1 得到这个式子后，其实真正意义上的未知数只有我们要求的 p，但是还存在一个 k。 针对 k，我们判断一下他的范围，看看能否采用爆破的方式。 k = (e * dp - 1)/(p-1) 因为 dp &lt; p-1 所以 k &lt; e 通过遍历 k 然后找到(e * dp - 1)可以整除 k 的情况即可。 (跑了一下发现限制条件还不够) 因此再加一个 n 能否整除 p 即可。 ¶EXP &lt;!–code￼3–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"2022DASCTF_NOV-lllcccggg-wp","slug":"2022DASCTF_NOV-lllcccgggwp","date":"2022-11-30T02:05:45.000Z","updated":"2022-12-01T09:42:22.869Z","comments":true,"path":"2022/11/30/2022DASCTF_NOV-lllcccgggwp/","link":"","permalink":"https://sch01ar.github.io/2022/11/30/2022DASCTF_NOV-lllcccgggwp/","excerpt":"","text":"题目描述 如题目名字一样，有好多个lcg，当时看晕了 &lt;!–code￼0–&gt; 题目分析 1.key是一个背包问题，已知公钥m，和的话目前不知道。 2.以1中的和为seed，通过LCG产生了一组序列output。 至此，已经可以根据output来求出LCG中的a、b、n，从而求出seed，从而通过背包可求得key。 3.以key为seed，称作state，再进行LCG，state = (a * state + b) % c，并且a，b，c已知。 但是想要直接正向求解出最后的state，十分困难，for循环了10^10000次，这里涉及到了矩阵快速幂的使用。 通过构造矩阵 $$ \\mathbf{A} = \\begin{bmatrix} state &amp; 1 \\end{bmatrix} $$ $$ \\mathbf{C} = \\begin{bmatrix} a &amp; 0\\ b &amp; 1\\ \\end{bmatrix} $$ 通过计算$AC^{1010000}$即可得到矩阵B，B = [ state, 1] 4.求出state后进行异或解密即可。 EXP &lt;!–code￼1–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"背包加密算法","slug":"背包问题算法","date":"2022-11-28T16:00:00.000Z","updated":"2022-12-01T09:50:05.003Z","comments":true,"path":"2022/11/29/背包问题算法/","link":"","permalink":"https://sch01ar.github.io/2022/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/","excerpt":"","text":"¶前言 在一次CTF比赛中遇到了，写了10个for嵌套硬爆出来了，复现的时候发现是背包加密。 ¶Merkle–Hellman 公钥加密算法 整体加密流程 &lt;!–code￼0–&gt; 可以发现，加密十分容易，但解密十分困难，这也是非对称加密的特点。 ¶加密 ¶生成私钥 超递增序列，也就是a中每一位元素需要大于其之前所有元素的和。 &lt;!–code￼1–&gt; ¶生成公钥 模数m要求：m &gt; sum(a) 乘数w要求：gcd(w,m) == 1 &lt;!–code￼2–&gt; b和m作为公钥。 加密：S = numpy.dot(x,b) ¶解密 拿到公钥$M=(m_1,m_2,\\ldots,m_n)$，构造如下矩阵 $$ \\begin{bmatrix} 2 &amp; 0 &amp; \\ldots &amp; 0 &amp; m_1 \\ 0 &amp; 2 &amp; \\ldots &amp; 0 &amp; m_2 \\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\ 0 &amp; 0 &amp; \\ldots &amp; 2 &amp; m_n \\ 1 &amp; 1 &amp; \\ldots &amp; 1 &amp; S \\ \\end{bmatrix} $$ 这个矩阵的所有行向量的线性组合构成了一个格，接下来将通过明文的特点和格上的特殊解法来进行解密。 ¶LLL 对于明文$X=(x_1,x_2,\\ldots,x_n)$这一组数来说，构造一个向量 $$ a=\\sum_{i=1}^nx_iv_i-v_{n+1}=(2x_1-1,2x_2-1,\\ldots,2x_n-1,0) $$ 显然，a向量在格L上。因为X中的所有x只能取值0或1，因此a向量的长度很小，约为$\\sqrt{n}$，对于很大的格基来说，a向量无疑是格L上的最小向量，因此我们利用LLL算法即可求出a向量。 ¶例题 &lt;!–code￼3–&gt; 这里注意一下，第一行向量中是有+1与-1，需要进行取反，即-1代表1，1代表0。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"非对称加密","slug":"非对称加密","permalink":"https://sch01ar.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"}]},{"title":"Hitcon 2022-㊙️BabySSS","slug":"hitcon2022-BabySSS","date":"2022-11-27T16:00:00.000Z","updated":"2022-12-01T09:37:56.735Z","comments":true,"path":"2022/11/28/hitcon2022-BabySSS/","link":"","permalink":"https://sch01ar.github.io/2022/11/28/hitcon2022-BabySSS/","excerpt":"","text":"I implemented a toy Shamir’s Secret Sharing for fun. Can you help me check is there any issues with this? Shamir’s Secret Sharing密钥分享算法 $$f(x)=a_0 + a_1x + a_2x^2 + …… + a_{k-1} x^{k-1} mod p $$ 题目源码 &lt;!–code￼0–&gt; 题目分析 题目给了8组x，y的值，可通过CRT模x求出a_0 ，通过模x^2 可求出a_1 ，同理可求出所有系数，恢复出polyeval函数，从而得到正确的secret。 EXP &lt;!–code￼1–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"Gauss格基约简算法","slug":"Gauss格基约简算法","date":"2022-11-23T16:00:00.000Z","updated":"2022-12-07T09:39:00.075Z","comments":true,"path":"2022/11/24/Gauss格基约简算法/","link":"","permalink":"https://sch01ar.github.io/2022/11/24/Gauss%E6%A0%BC%E5%9F%BA%E7%BA%A6%E7%AE%80%E7%AE%97%E6%B3%95/","excerpt":"","text":"由Gauss提出的二维格基约化算法 算法伪代码 即对给定的两个基向量进行不断的相互约化，最终求得格上的最小向量 Loop (a) If ||v2|| &lt; ||v1||, swap v1, v2 (b) Compute m = ⌊ v1∙v2 / v1∙v1 ⌉ © If m = 0, return v1, v2 (d) v2 = v2 - m*v1 Continue Loop 代码实现 &lt;!–code￼0–&gt; 例题 &lt;!–code￼1–&gt; ¶思路 给定公钥q、h，以及明文e 要求私钥f、g 他们之间有如下关系： fh ≡ g mod q 即 kq + g =fh g = fh -kq 根据这一特点即可构造格，也就是格密码中很经典的，遇到一个向量乘矩阵，即可进行构造 由于存在一组a、b，使得a（1，h）+ b（0，q）=（f，g）$a(1,h) + b(0,q) = (f,g)$ a = f，b = k 选取一组基底为（1，h）和（0，q），也就是上述高斯约简算法当中的v1与v2，求出v1与v2格上最小的向量，即为（f，g） ¶EXP &lt;!–code￼2–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"lattice","slug":"lattice","permalink":"https://sch01ar.github.io/tags/lattice/"}]},{"title":"二叉树建立与遍历","slug":"二叉树建立与遍历","date":"2022-11-09T16:00:00.000Z","updated":"2022-12-01T05:15:01.487Z","comments":true,"path":"2022/11/10/二叉树建立与遍历/","link":"","permalink":"https://sch01ar.github.io/2022/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/","excerpt":"","text":"网上很多算法通过直接将二叉树结点连接，从而构成二叉树，这里我构建了一个二叉树类，通过用户控制输入来建立二叉树。 有层序遍历，递归、非递归的前序遍历、中序遍历、后序遍历算法。 &lt;!–code￼0–&gt;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sch01ar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sch01ar.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"2022祥云杯wp-crypto","slug":"2022-10-30-2022祥云杯wp-crypto","date":"2022-10-29T16:00:00.000Z","updated":"2022-12-07T09:43:16.370Z","comments":true,"path":"2022/10/30/2022-10-30-2022祥云杯wp-crypto/","link":"","permalink":"https://sch01ar.github.io/2022/10/30/2022-10-30-2022%E7%A5%A5%E4%BA%91%E6%9D%AFwp-crypto/","excerpt":"","text":"little little fermat ¶题目源码 &lt;!–code￼0–&gt; ¶题目分析 根据题目名字来看，此题和费马小定理的使用有关，题目中有一个 obfuscate函数，进行了对q的生成，q=p+A，这里可以看一下A的范围，是在2[18,319]之间，因此p、q接近，尝试一下yafu分解。 题目对m先进行了处理，再进行RSA加密，因此我们需要知道x。assert 114514 ** x % p == 1运用费马小定理，若114514与p互素，则x=p-1，即可求解m。 ¶EXP &lt;!–code￼1–&gt; fill ¶题目源码 &lt;!–code￼2–&gt; ¶题目分析 随机产生32位的数，sha256()加密后作为flag，并将其2进制的每一位存到了f_list数组中。 又 创建了一个r_list32位数组，里面存着随机数，先暂时不管。 双 对r_list数组中的随机数做了加密，产生了M数组。 对f_list和M数组进行了numpy.dot运算，即向量乘法，得到和为S。 叒 创建了一个s数组，这个很明显，用LCG线性同余算法进行了加密。 最后将M数组与s数组相加。 这就是这道题整体的流程，每一步并不难，只是步骤多，略显复杂。 ¶EXP ¶0x01 可以先进行一下LCG的求解，把s数组求解出来，从而求出M数组。 &lt;!–code￼3–&gt; ¶0x02 按理来说，感觉应该根据求出来的M数组进行逆运算，求出r_list数组，但是求出来r_list有什么用呢，所以直接尝试求f_list。因为f_list中不是0就是1，与M做向量乘法，即为M数组中若干元素的和。根据题目给定和S，先大概看一下需要M中多少个元素累加。发现在M前21位和 &lt; S，前22位和 &gt; S，所以猜想应该是M当中，除10个左右元素之外的和。 这里就遍历了一下，复杂度实在太高了，也没想着能出，结果还真算出来了o.O &lt;!–code￼4–&gt; 也就说明，f_list中下标为这些的，对应值是0，其余为1，即可得到msg的2进制数，转为十进制后进行sha256()加密即可。 &lt;!–code￼5–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"2022NewStarCTF-flip_flop","slug":"2022NewStarCTF-flip_flop","date":"2022-10-26T16:00:00.000Z","updated":"2022-12-07T09:41:52.644Z","comments":true,"path":"2022/10/27/2022NewStarCTF-flip_flop/","link":"","permalink":"https://sch01ar.github.io/2022/10/27/2022NewStarCTF-flip_flop/","excerpt":"","text":"flip-flop AES-CBC加密模式 ¶题目 源码如下： &lt;!–code￼0–&gt; ¶题目分析 此题是通过注册得到的用户账户的密文，然后输入管理员账户对应的密文，才能得到flag。 对用户账户和管理员账户的加密解密均采用AES-CBC模式，但是本题仅有一组明文，iv仅作为偏移量，也就是本题中的user_key。 这里先来说一下我最一开始的思路，由于user_key每次是随机产生的，但是一次程序的运行当中是不变的。由于密文由两部分组成，前半部分为user_key.hex()，后半部分为code.hex()，所以只要构造出admin对应的code即可，那么就需要AES加密当中的key，所以就需要构造一个key来产生出admin对应的code。查询了很多资料发现都难以实现。于是…… 那为什么不换一下思路？不能构造code，能不能构造iv？ 先来看一下加密方式： C = encrypt(M ^ iv) M = decrypt©^iv 对应一下本题当中的NewStarCTFer和admin： b'NewStarCTFer____' = decrypt(code) ^ iv1 b'AdminAdmin______' = decrypt(code) ^ iv2 因此可求出admin对应的iv2，随后拼接上普通用户的后半段code即可。 ¶EXP &lt;!–code￼1–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"BUU刷题日记20221026","slug":"BUU刷题日记20221026","date":"2022-10-25T16:00:00.000Z","updated":"2022-12-07T09:39:19.641Z","comments":true,"path":"2022/10/26/BUU刷题日记20221026/","link":"","permalink":"https://sch01ar.github.io/2022/10/26/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221026/","excerpt":"","text":"RSA5 ¶题目分析 给定e=65537 给了很多组n、c 由于e过大，所以不考虑使用CRT，由于m是同一个，因此遍历一下，求出两个n的最大公约数，即为p，后续就简单了。 ¶EXP &lt;!–code￼0–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"2022 DASCTF 10月挑战赛wp","slug":"2022DASCTF10月挑战赛wp","date":"2022-10-22T16:00:00.000Z","updated":"2022-12-07T09:42:51.960Z","comments":true,"path":"2022/10/23/2022DASCTF10月挑战赛wp/","link":"","permalink":"https://sch01ar.github.io/2022/10/23/2022DASCTF10%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwp/","excerpt":"","text":"RSA ¶题目如下 &lt;!–code￼0–&gt; ¶题目分析 该题的加密顺序是： 1、加密flag，分为两部分m1、m2 2、加密m1 3、加密m2 同理我们解密的顺序应该也是 1、解出m1、m2 2、解出flag ¶求m2 先观察一下encrypt4函数 虽然说e_2=3，按理来说使用低加密指数攻击，但并不可行。 又因为m = m % k 可通过这点和c_3 = pow(m, e_2, n_3)做遍历求出m 最后发现m即为m2，m2 &lt; k ¶求m1 发现m1加密方式采用RSA，但是n_1未知 n_1又通过一次RSA加密，已知n_1对应的密文 利用低加密指数攻击解出n1 发现n1可分解为3个素数乘积 故phi可求，即求出m1 ¶求flag 观察encryt1 m1是flag右移200位之后转为字节 m2是flag的20位之后转成字节 所以来说m2是没什么问题，主要找到flag的前20位，再把m2拼到后面即可。 由于m1是flag右移200位，因此flag的低位缺失，但高位还在，由于不知道flag总长度，抱着试一试的心态，猜测一下它的高位前20位没有缺失 我们将m1和m2转为字节发现 m1:b’0x666c61677b3230366538353964’ m2:b’383539643865383534633466363030636231323735376262663966357d’ 发现m1和m2有重叠部分，即38353开始 可以证实m1前20位确实没有缺失 因此取m1前20位，加m2，即可解出flag ¶EXP &lt;!–code￼1–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"BUU刷题日记20221022","slug":"BUU刷题日记20221022","date":"2022-10-21T16:00:00.000Z","updated":"2022-12-07T09:40:10.592Z","comments":true,"path":"2022/10/22/BUU刷题日记20221022/","link":"","permalink":"https://sch01ar.github.io/2022/10/22/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221022/","excerpt":"","text":"RSA4 题目只给了三组n、c，采用中国剩余定理，具体推导如下 ¶推导过程 me ≡ c1 mod n1 me ≡ c2 mod n2 me ≡ c3 mod n3 ¶中国剩余定理（CRT） 中国剩余定理的内容是： 针对上述方程组，若n1、n2、n3互质，对于任意的c1、c2、c3，方程组都有解，使用条件是m^e &lt; n1、n2、n3。通解形式如下： 令N = n1 * n2 * n3，N1 = N/n1，N2、N3同理 令t1 = N1(-1)，即其对应的模n1运算的逆元，t2，t3同理，可用t1=gmpy2.invert(N1,n1)表示。 有了Ni和ti的定义，我们就可以给出通解形式： x = c1 * N1 * t1 …… 有了通解公式我们就可以求出m^e，对e进行一下遍历即可，m开方成功即可。 ¶EXP &lt;!–code￼0–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"BUU刷题日记20221021","slug":"BUU刷题日记20221021","date":"2022-10-20T16:00:00.000Z","updated":"2022-12-08T05:42:21.849Z","comments":true,"path":"2022/10/21/BUU刷题日记20221021/","link":"","permalink":"https://sch01ar.github.io/2022/10/21/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221021/","excerpt":"","text":"RSA2 题目给定n、e、dp、c 非预期解：直接分解n 下面考虑n不能分解的情况 ¶推导过程 dp ≡ d mod (p-1) ed ≡ 1 mod (p-1) * (q-1) ed = 1 + k2(p-1)(q-1) 对1式两端同乘e，得 e * dp ≡ ed mod (p-1) e * dp = k1(p-1) + ed 代入ed得 e * dp = k1(p-1) + 1 + k2(p-1)(q-1) 由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余p-1，即可消掉n e * dp ≡ 1 mod (p-1) e * dp =k(p-1) + 1 得到这个式子后，其实真正意义上的未知数只有我们要求的p，但是还存在一个k。 针对k，我们判断一下他的范围，看看能否采用爆破的方式。 k = (e * dp - 1)/(p-1) 因为dp &lt; p-1 所以k &lt; e 通过遍历k然后找到(e * dp - 1)可以整除k的情况即可。 (跑了一下发现限制条件还不够) 因此再加一个n能否整除p即可。 ¶EXP &lt;!–code￼0–&gt; RSA3 给定n、e1、c1、e2、c2。 m ≡ c1^e1 mod n m ≡ c2^e2 mod n 这里采用共模攻击，详细原理如下： 扩展欧几里得算法：给定两个整数a、b，必定存在x、y，使得gcd(a,b)=ax+by 对应到本题当中，由于e1、e2互为素数，因此gcd(e1,e2)=1，从而存在s1、s2使得: s1 * e1 + s2 * e2 = 1 ¶推导过程 m = m % n m = m^(s1 * e1 + s2 * e2)^ % n m = m^(e1 * s1)^ * m^(e2 * s2)^ % n m = (m^(e1 * s1)^ % n) * (m^(e2 * s2)^ % n) % n m = (c1s1 % n) * (c2s2 % n) % n ¶EXP &lt;!–code￼1–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"BUU刷题日记20221020","slug":"BUU刷题日记20221020","date":"2022-10-19T16:00:00.000Z","updated":"2022-12-06T07:25:59.850Z","comments":true,"path":"2022/10/20/BUU刷题日记20221020/","link":"","permalink":"https://sch01ar.github.io/2022/10/20/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221020/","excerpt":"","text":"RSA1 给定dp、dq类型 dp ≡ d mod (p-1) dq ≡ d mod (q-1) m ≡ cd mod n m = cd + k * n m = cd +k * p * q 对上式两端同时对p、q分别取余，得：（中国剩余定理） m1 ≡ cd mod p m2 ≡ cd mod q 同理，可得到 cd = m1 +k * p 代入到 m2 ≡ cd mod q 中： m2 ≡ (m1 + k * p)mod q ，两端减去m1得 m2 - m1 ≡ k * p mod q ，两端乘p的逆元得 (m2 - m1)p-1 ≡ k mod q 将k代入到 cd = m1 +k * p 中得： cd = m1 + ((m2 - m1)p-1 mod q) * p m=cd mod n 得到 m ≡ (((m2 - m1) * p-1 mod q) * p + m1) mod n 接下来就是求解m1，m2 m1 ≡ cdp+k(p-1) mod p m2 ≡ cdq+k(q-1) mod q 根据费马小定理 若p是素数，则a(p-1) ≡ 1 mod p 因此 m1 ≡ cdp mod p，m2 ≡ cdq mod q 最终可求得m ¶exp &lt;!–code￼0–&gt; RSAROLL &lt;!–code￼1–&gt; 给了一个data.txt文件，打开盲猜一下第一行是n，e，后面是c &lt;!–code￼2–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"2021ByteCTF-easyxor","slug":"2021ByteCTF-easyxor","date":"2022-10-15T16:00:00.000Z","updated":"2022-12-07T09:34:59.756Z","comments":true,"path":"2022/10/16/2021ByteCTF-easyxor/","link":"","permalink":"https://sch01ar.github.io/2022/10/16/2021ByteCTF-easyxor/","excerpt":"","text":"题目源码如下 &lt;!–code￼0–&gt; 题目分析 将flag分为两段，前半段采用OFB加密，后半段采用CBC加密 ¶OFB解密 将前半段flag又进行切分，将其8位分为一组，存到group数组中。 &lt;!–code￼1–&gt; 针对一个随机生成的64位的last，与keys进行convert加密，再与group中的数进行异或。 keys是四个-32～32的数，可爆破。 对于OFB解密十分简单，因为我们已知第一组明文，恰好是8位的’ByteCTF{'，由于分组密码的性质，所以后面的也就迎刃而解，通过group[ 0]^cipher[ 0] 即可得到cur_c，从而求得下一次的cur_c，以此类推。 ¶expOFB &lt;!–code￼2–&gt; ¶CBC解密 针对后半部分，我们需要逆向解出convert函数，因此就是对shift函数中的加密运算进行解密。 之前上网搜的wp都一笔带过，没解释unshift逆函数怎么写的。“难道有什么定理？？” 这里简单写一下我的理解。 ¶分析shift &lt;!–code￼3–&gt; ¶推理过程 这里我们举例k&gt;0时的情况。（k&lt;0同理） m和c都是64位,k是-32～32的10进制数。 1、m &lt;&lt; k相当于在m后补k位0，得到的新数我们称为a，a=m &lt;&lt; k。 2、令b = a &amp; c，由于a是64+k位，c是64位，所以b是64位，并且b的后k位都是0。 3、令x = m ^ b，x则是shift加密之后的值，x也是64位，并且x的后k位是与m的后k位相同的，与0异或得本身。 我们走完了一遍shift加密，得到的结论是，密文的位数同样是64，并且密文的后k位与明文相同。 ¶分析unshift &lt;!–code￼4–&gt; ¶推理过程 同样我们举例k&gt;0的情况。 之前我们得到的密文x，相当于tmp。 1、a’=tmp &lt;&lt; k，tmp后k位为0，tmp后2k～k位等于m的后k位。 2、b’=a’ &amp; c，b’后k位为0，后2k～k位为m&amp;c。 3、y=x ^ b’，y的后k位，等于x的后k位，也就是m的后k位。 4、y的后2k～k位，在shift加密当中，a &amp; c的后2k～k位等于m的后k位&amp;c，记作m1 &amp; c。 shift中的x，也就是m ^ b，m ^(m1 &amp; c)，在unshift最后的一步操作中，y= m ^(m1 &amp; c) ^ b’。 这时我们只考虑y的后2k～k位，y=m ^(m1 &amp; c)^(m1 &amp; c) = m 所以这时y的2k～k位也等于m了。 ¶总结 因此，我们发现每经过unshift一次，就有k位被还原，何时才能被完全还原？即循环bits//k次。 此推理正确，可以在unshift函数运行时输出每次的tmp观察即可。 ps：自我感觉这种位运算应该是属于一种性质或者定理，网上大佬们都是说“简单写个逆”。。。 ¶expCBC &lt;!–code￼5–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"2022BUUCTF新生赛-RSA","slug":"2022BUUCTF新生赛-RSA","date":"2022-10-15T16:00:00.000Z","updated":"2022-12-08T07:35:16.441Z","comments":true,"path":"2022/10/16/2022BUUCTF新生赛-RSA/","link":"","permalink":"https://sch01ar.github.io/2022/10/16/2022BUUCTF%E6%96%B0%E7%94%9F%E8%B5%9B-RSA/","excerpt":"","text":"题目源码 &lt;!–code￼0–&gt; 题目分析 发现n和phin都不常规，没入手点，发现hint，hint=pow(d,e,n)，有趣，用d做明文，尝试推理一下： d = pow(hint,d,n) d = pow((d ** e % n),d,n) d = (d ** e % n) ** d % n d = d ** (e*d) % n d = pow(d ** e,d,n) 把d ** e再次看做密文，可得 d ** e = pow(d,e,n) 因为hint = pow(d,e,n) 可得hint = d ** e d ** e * e ** e-&gt;(ed) ** e-&gt;(ed) ** e == 1 mod phin 因此根据e和hint即可求得phin 从而得到phin和n的最大公约数p 脚本如下 &lt;!–code￼1–&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"梦开始的地方","slug":"梦开始的地方","date":"2022-10-15T07:59:58.000Z","updated":"2022-12-01T05:15:04.679Z","comments":true,"path":"2022/10/15/梦开始的地方/","link":"","permalink":"https://sch01ar.github.io/2022/10/15/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/","excerpt":"","text":"¶Mac下利用Hexo和github pages搭建个人博客 ¶环境配置 ¶1.Node.js安装 下载地址：Node.js ¶2.淘宝镜像安装 &lt;!–code￼0–&gt; ¶3.安装Hexo &lt;!–code￼1–&gt; ¶初始化Hexo Blog ¶1.初始化Hexo 新建一个文件夹并进入，例如blog &lt;!–code￼2–&gt; ¶2.本地启动Hexo &lt;!–code￼3–&gt; 浏览器打开网站，即可看到本地博客 ¶创建博客文章 ¶1.创建文章 &lt;!–code￼4–&gt; 在blog文件夹中的_post里即可看到新建的md文件 ¶2.清理缓存项目 在新建博客或修改博客时，需要进行该操作 &lt;!–code￼5–&gt; ¶3.重新生成博客 &lt;!–code￼6–&gt; ¶4.启动博客 &lt;!–code￼7–&gt;","categories":[{"name":"建站","slug":"建站","permalink":"https://sch01ar.github.io/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://sch01ar.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-10-15T07:57:23.442Z","updated":"2022-12-01T05:15:29.274Z","comments":true,"path":"2022/10/15/hello-world/","link":"","permalink":"https://sch01ar.github.io/2022/10/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ¶Quick Start ¶Create a new post &lt;!–code￼0–&gt; More info: Writing ¶Run server &lt;!–code￼1–&gt; More info: Server ¶Generate static files &lt;!–code￼2–&gt; More info: Generating ¶Deploy to remote sites &lt;!–code￼3–&gt; More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sch01ar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"建站","slug":"建站","permalink":"https://sch01ar.github.io/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"},{"name":"非对称加密","slug":"非对称加密","permalink":"https://sch01ar.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"},{"name":"lattice","slug":"lattice","permalink":"https://sch01ar.github.io/tags/lattice/"},{"name":"二叉树","slug":"二叉树","permalink":"https://sch01ar.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://sch01ar.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}