{"meta":{"title":"Y's blog","subtitle":"","description":"","author":"Roo1e","url":"https://sch01ar.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-10-24T03:02:05.262Z","updated":"2023-10-24T03:02:05.262Z","comments":false,"path":"about/index.html","permalink":"https://sch01ar.github.io/about/index.html","excerpt":"","text":"☁️about 🏠Team 弱到不行的觅 🐎 手@Scr1w&amp;大吉北 Do u know djb? 联系方式 🐧 MTUyOTU4OTk0Ng== ✉️ yys1mple@163.com"},{"title":"书单","date":"2022-10-16T02:30:27.247Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"books/index.html","permalink":"https://sch01ar.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-10-16T03:25:28.438Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"repository/index.html","permalink":"https://sch01ar.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-10-16T02:41:49.050Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"tags/index.html","permalink":"https://sch01ar.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-10-16T02:33:21.117Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"categories/index.html","permalink":"https://sch01ar.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-10-17T01:02:57.129Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"links/index.html","permalink":"https://sch01ar.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"2023强网杯","slug":"2023强网杯","date":"2023-12-19T12:05:45.000Z","updated":"2023-12-19T12:00:01.483Z","comments":true,"path":"2023/12/19/2023强网杯/","link":"","permalink":"https://sch01ar.github.io/2023/12/19/2023%E5%BC%BA%E7%BD%91%E6%9D%AF/","excerpt":"","text":"强网是强者的网络安全竞赛，我太菜了。。慢慢复盘，估计得复盘到明年了。 not only rsa(118 solves) 123456789101112131415161718from Crypto.Util.number import bytes_to_longfrom secret import flagimport osn = 6249734963373034215610144758924910630356277447014258270888329547267471837899275103421406467763122499270790512099702898939814547982931674247240623063334781529511973585977522269522704997379194673181703247780179146749499072297334876619475914747479522310651303344623434565831770309615574478274456549054332451773452773119453059618433160299319070430295124113199473337940505806777950838270849e = 641747m = bytes_to_long(flag)flag = flag + os.urandom(n.bit_length() // 8 - len(flag) - 1)m = bytes_to_long(flag)c = pow(m, e, n)with open(&#x27;out.txt&#x27;, &#x27;w&#x27;) as f: print(f&quot;&#123;n = &#125;&quot;, file=f) print(f&quot;&#123;e = &#125;&quot;, file=f) print(f&quot;&#123;c = &#125;&quot;, file=f) 题目中n可分解且n=p^5，但e与phi不互素。好，接下来就是一个简单的有限域分解。 1mp=GF(p)(c).nth_root(e, all=True) 在测试了GF(p)和GF(p^2)都可以开出根，但此题肯定无法使用CRT求m的，n的因子只有p，那么就只能尝试继续开根了。。。但是GF(p^3)域下开根我的sage已经跑不出来了，更何况直接去求GF(p^5)这题也就断在这里了，但是比赛时一直出解，怀疑是不是有别的简单解法。 赛后看wp真无语。。有限域开根做多了，没想到有限环也可以开根，域相对环来说更为严格，环上可以开根但域上不一定可以。此题在环Zmod(p^5)上可以实现秒开根。 直接搬别人脚本了 123456789101112131415161718from tqdm import tqdmfrom Crypto.Util.number import long_to_bytesp = 91027438112295439314606669837102361953591324472804851543344131406676387779969e = 641747c = 730024611795626517480532940587152891926416120514706825368440230330259913837764632826884065065554839415540061752397144140563698277864414584568812699048873820551131185796851863064509294123861487954267708318027370912496252338232193619491860340395824180108335802813022066531232025997349683725357024257420090981323217296019482516072036780365510855555146547481407283231721904830868033930943n = p ^ 5K = Zmod(p ^ 5)a = K(c).nth_root(e)b = K(1).nth_root(e)a = int(a)b = int(b)print(b, a)for i in tqdm(range(e)): a = (a*b) % n m = long_to_bytes(int(a)) if b&quot;flag&quot; in m: print(m) break discrete_log_task(36 solves) 123456789101112131415161718192021from Crypto.Util.number import *from Crypto.Util.Padding import padflag = &#x27;flag&#123;d3b07b0d416ebb&#125;&#x27;assert len(flag) &lt;= 45assert flag.startswith(&#x27;flag&#123;&#x27;)assert flag.endswith(&#x27;&#125;&#x27;)m = bytes_to_long(pad(flag.encode(), 128))p = 0xf6e82946a9e7657cebcd14018a314a33c48b80552169f3069923d49c301f8dbfc6a1ca82902fc99a9e8aff92cef927e8695baeba694ad79b309af3b6a190514cb6bfa98bbda651f9dc8f80d8490a47e8b7b22ba32dd5f24fd7ee058b4f6659726b9ac50c8a7f97c3c4a48f830bc2767a15c16fe28a9b9f4ca3949ab6eb2e53c3g = 5assert m &lt; (p - 1)c = pow(g, m, p)with open(&#x27;out.txt&#x27;, &#x27;w&#x27;) as f: print(f&quot;&#123;p = &#125;&quot;, file=f) print(f&quot;&#123;g = &#125;&quot;, file=f) print(f&quot;&#123;c = &#125;&quot;, file=f) 非常标准的一个dlp，并且这个p是非常安全的，\\(\\frac{p-1}{2}\\)也是一个素数，所以这题我也没想到有什么办法。但他题里给了一个假flag，还限制flag位数。。。赛后看wp就真是爆破flag打中间相遇。。。。下次这样要不暗示的明显一点，直接给个确定的位数算了。。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"2023DASCTF X 0psu3十一月挑战赛","slug":"20230psu3CTF","date":"2023-12-12T11:05:45.000Z","updated":"2023-12-19T12:01:39.688Z","comments":true,"path":"2023/12/12/20230psu3CTF/","link":"","permalink":"https://sch01ar.github.io/2023/12/12/20230psu3CTF/","excerpt":"","text":"GeneratePrime 解最多的题，但我不会做。赛后一看wp，好啊原来是原题。研究一下原理，感觉确实难度可以。 题目 1234567891011121314151617181920212223242526272829from Crypto.Util.number import getPrime, isPrime, bytes_to_longimport osdef 0psu3_The_best(sz, d): while True: p = getPrime(sz) pp = sum([p**i for i in range(d)]) if isPrime(pp): return p, ppp, q = 0psu3_The_best(512, 5)r = getPrime(512 * 5)n = p * q * re = 65537flag=open(&quot;flag.txt&quot;, &quot;rb&quot;).read().strip()flag1=flag+os.urandom(128)m=bytes_to_long(flag1)c = pow(m, e, n)print(f&quot;&#123;n = &#125;&quot;)print(f&quot;&#123;e = &#125;&quot;)print(f&quot;&#123;c = &#125;&quot;)#n=43090231453250894711427929679917165532091051269639380881822679198388872373018031295429558758883298138388596507242928145888959963579111847255588834248367032580980272245414738073179172684104908272069503607376171584936239696444309039211273376010193165083254209608051430794825261116490356392215410064858020176711199543381037420111454942356936721487016187240237683725310306748046587503625096246489043270381153251813360521583717685413070481576320194446237522118380283335294528606720928637529817170809666802598938788405154468683850385277659812316577873886708164549255359514776884765904417881419804464020855420288884972204146588152412816874161445668955639456202226751519881834234916642218078966066353317917939418964763844067220460513388433020071277477619189495465483910271310025371745344364984826481983188861624474015117761898377237745775289039922285111681410319016537270412509750339539020876501534842403407208957382830000761065368861209033791387480377889838737241326116532852335478193204425626487166234964754732945953080086117315162916374952094149599597509405176646068341218684523765974759907645226607364627690026025662221036766148813918691578120023886400197652148214238256715089883892069133754778609710846757189987335827693169644541734443763194942694587436469448973201513131503797898892822373949177030567791519349220158287318717788746060997955057747930375117780320371517616412423571775682868481089431670802944047375824503353609019686495670630728618082254293585479431369645935654024149490741245953271830453426444847467908952699660750809490650479987#e=65537#c=30862228874892553476569860337345503267926249096036551213683005116620750680365154103242717714230966827288361499342464202425467642950081816675486231250411347472976482409360391136808439034217688010072648722396312121758844966972323513456884732046270240934002095706243044210312663525491282667971502534420245427643076262414036655243117610886157895994101178663474990136516153062956803591842233732498519246731337518545018734984319536536205092573418457928952414660837594265802406473201400259189950484841504227372735345451459452313825309333631615286962304963039625162366186574440146535361888708570569938418676320446653266676364765870547213167058713058609788316647593834008151805692510044158607162858906528913516242904419457446211348504248317409844426309455978985314882123424453618672960876022996245213882467954521212481418830104602302179759479012618982228223244131619557639469872139485197176384683400796204681045965981417650462297978265085323342772310690638049411549216990505001950512428646871875659468885490055363436412364532718888124906227240501145227269727887236864060558999336443165765870556727793253297515155026234234422303238380776900105115890363548589834345888430695886678231459920101695996112312269637459823479947618045447071359886515163416153117176539752947700226596291435270282598638974889205601333097978743387412651687356072223691445472690647184292120882095587563356691450107194982597794937293154289560470269606300576216128045797481404606810315677962659136641943747123985144899464108823536597185386155005111274476874957827391438859327653936 分析 参考博客 \\[n=(p^4+p^3+p^2+p+1)\\cdot p\\cdot r\\] \\[p^5-1=(p-1)\\cdot(p^4+p^3+p^2+p+1)=(p-1)\\cdot q\\] 构造一个阶为\\(p^5-1\\)的域，利用其生成元\\(g\\)计算\\(g^n\\)的阶。 \\[order(g^n)=\\frac{p^5-1}{gcd(n,p^5-1)}=\\frac{p^5-1}{q}=p-1\\] 对于阶的定义，我们可以得到阶为\\(p-1\\)的任意元素\\(a\\)满足\\(a^{p-1}=1\\)，\\(1\\)指幺元。 参考上述博客，应用群环域的性质得到\\(g^n=ax^2+bx+c\\)，即表示成度最大为二的多项式。 结合上述两式写成如下形式： \\[(0x^2+0x+c)^{p-1}=1,c \\in (0,p)\\] 此时用到另一条性质，阶为\\(p-1\\)的元素个数为\\(\\phi(p-1)\\)个，而\\(c\\)的取值个数要大于\\(\\phi(p-1)\\)个，因此\\(g^n\\)只能由常数产生。 至此上述的分析都是在阶为\\(p^5-1\\)的环上进行的讨论，而实际当中我们并没有p，倘若构造出模\\(n\\)的环，那么在该环上计算得到的\\(g^n\\)的一次项和二次项系数应该都是\\(kp\\)，这样再与\\(n\\)求解gcd即可。 exp 12345678910111213141516171819k = 5n=e=65537c=R = Zmod(n)[&quot;x&quot;]while True: Q = R.quo(R.random_element(k)) pp1 = gcd(ZZ(list(Q.random_element() ^ n)[1]), n) if pp1 != 1: print(pp1) qq = sum([pp1**i for i in range(k)]) rr = n // (pp1 * qq) assert n == pp1 * qq * rr breakphi = (pp - 1) * (qq - 1) * (rr - 1)d = pow(e, -1, phi)m = pow(c, d, n)print(long_to_bytes(int(m)) FindPrime 没啥意思，就嗯缝，agcd+amm 1234567891011121314151617181920212223242526272829from Crypto.Util.number import *from gmpy2 import *P=getPrime(int(512))p_list=[]for i in range(30): q=getPrime(1024) r=getPrime(450) l=q*P+r p_list.append(l)path1=&quot;D:/CTF题目\\密码\\出题1/&quot;with open(&quot;output.txt&quot;,&#x27;w&#x27;)as f1: for val in p_list: f1.write(str(val)) f1.write(&quot;\\n&quot;)Q=getPrime(512)N=P*Qe=e1*e2m=bytes_to_long(flag2)c=pow(m,e,N)assert m&lt;Nprint(&quot;N=&quot;,N)print(&quot;e=&quot;,e)print(&quot;c=&quot;,c)#N=68770027076980723946939075792572969610228738501865973895618044035550466673326811210718966610231582633896160130057212343512606374318082678735227998163020559923237005947682357783487924911009663067842443440348588088325506801639924926097944176357432282915587075930988972621730524537492705984723766652062305363027#e=30899846873#c=46935517038224473812546067305866276864169387205589347201858550096671613860700878462369638807831295923952343159795466895818221029692119135003812788250010552362110290387383510093277209478665971066986914981717774698233220968427990066291572377851164878122374241804989577737820368814455456808941766309324614067608 exp 12345678910111213141516171819202122232425262728293031323334from sympy.ntheory.modular import crtfrom Crypto.Util.number import *n = 68770027076980723946939075792572969610228738501865973895618044035550466673326811210718966610231582633896160130057212343512606374318082678735227998163020559923237005947682357783487924911009663067842443440348588088325506801639924926097944176357432282915587075930988972621730524537492705984723766652062305363027c = 46935517038224473812546067305866276864169387205589347201858550096671613860700878462369638807831295923952343159795466895818221029692119135003812788250010552362110290387383510093277209478665971066986914981717774698233220968427990066291572377851164878122374241804989577737820368814455456808941766309324614067608p = 8475751295865335034925394592760419247986527875671629878727167186701425140981793707985425024055132199826439868047385642931090550239766413089832011638673209q = n//pe = [7,191,23111329]N = nd1 = inverse(e[2],(p-1)*(q-1))c = pow(c,d1,N)#pdp1 = inverse(191,p-1)cp = pow(c,dp1,p)PR.&lt;x&gt; = Zmod(p)[]f = x^7 - cpresp = f.roots()#qPR.&lt;x&gt; = Zmod(q)[]f = x^(191*7) - cresq = f.roots()for i in resp: for j in resq: ti = int(i[0]) tj = int(j[0]) n = [p,q] c = [ti,tj] m = crt(n,c)[0] if(b&quot;DASCTF&quot; in long_to_bytes(int(m))): print(long_to_bytes(int(m))) MathFactor1 题目 1234567891011121314151617181920from Crypto.Util.number import *p=getPrime(512)q=getPrime(512)n=p*qd=(p**21+q**17)d1=d&amp;(2**300-1)flag=open(&quot;flag.txt&quot;).read().strip()import osflag=flag+os.urandom(60)print(f&quot;&#123;n = &#125;&quot;)print(f&quot;&#123;e = &#125;&quot;)print(f&quot;&#123;c = &#125;&quot;)#n=89049581381915401856270440494182068395799559452947499744642830361236578373835725708887668528820916651578050248209041339369091828040992115394942524278397293747808840107939504743946806866214713225533666120894844131211241905215662457238793580469827973839976134854993162976454283311566973255659612267446150515233#e=65537#c=16305239798028293699632813396005973660370581911030264211210444559974188415332021689054795983319112132645051076901780239982290095820283651929773925636804434706351474493000010749679965744672518110692104573489299874390925347271040454693791271882869477780584606934066152476594086178041874762147934091597942667138#d1=1253867202722198232827428701701674148965306906567632781415318063046179456643047348348144258 思路一 给了\\(p^{21}+q^{17}\\)的低位，相当于给了一组剪枝条件，从低位开始爆破即可，最后得到的p_list都不算长，遍历一下通过coppersmith打一个高位就可。这是官方wp给的解法，用剪枝确实不好想，给了这样一个限制剪枝效果确实挺好。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def get_pq(n,d1): a = [0] b = [0] maskx = 1 maskn = 2 for i in range(300): nbit = n % maskn t_a = [] t_b = [] for j in range(len(a)): for aa in range(2): for bb in range(2): d=d1% maskn tmp2 = n % maskn tmp_p=(aa * maskn // 2 + a[j]) tmp_q=(bb * maskn // 2 + b[j]) tmp1 =(tmp_p**21+tmp_q**17) % maskn tmp3=(tmp_p*tmp_q)%maskn if tmp2 == tmp3: if tmp1==d: t_a.append(aa * maskn // 2 + a[j]) t_b.append(bb * maskn // 2 + b[j]) maskx *= 2 maskn *= 2 a = t_a b = t_b return a,bn=89049581381915401856270440494182068395799559452947499744642830361236578373835725708887668528820916651578050248209041339369091828040992115394942524278397293747808840107939504743946806866214713225533666120894844131211241905215662457238793580469827973839976134854993162976454283311566973255659612267446150515233e=65537c=16305239798028293699632813396005973660370581911030264211210444559974188415332021689054795983319112132645051076901780239982290095820283651929773925636804434706351474493000010749679965744672518110692104573489299874390925347271040454693791271882869477780584606934066152476594086178041874762147934091597942667138d1=1253867202722198232827428701701674148965306906567632781415318063046179456643047348348144258p_list,q_list=get_pq(n,d1)R.&lt;x&gt;=Zmod(n)[]for p_ in p_list: f=p_+pow(2,299)*x f1=f.monic() r=f1.small_roots(X=2^214,beta=0.49) if r: p=f(r[0]) p=int(p) print(p) assert isPrime(p) q=n//p phi=(p-1)*(q-1) d=invert(e,phi) m=pow(c,d,n) flag=long_to_bytes(int(m)) print(flag) break 思路二 通过解模\\(2^{300}\\)的方程来得到可能的低300位p，\\(d=p^{21}+q^{17}\\)，再遍历求高位即可。 12p = var(&#x27;p&#x27;)p0 = solve_mod([p^38 - d1*p^17 + n^17 == 0], 2^300)","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"格密码","slug":"lattice","date":"2023-11-10T13:05:45.000Z","updated":"2023-11-11T01:24:42.882Z","comments":true,"path":"2023/11/10/lattice/","link":"","permalink":"https://sch01ar.github.io/2023/11/10/lattice/","excerpt":"","text":"线性代数前置知识 先回顾一下学校线代课程讲过的几个概念 向量空间 设\\(V\\)是 n 元向量的集合，如果\\(V\\)非空，并且对于向量的线性运算封闭(即对任意 \\(\\boldsymbol{v_1} \\in V,\\boldsymbol{v_2} \\in V,k \\in \\mathbb{R}\\) ，都有 \\(\\boldsymbol{v_1+v_2} \\in V,k\\boldsymbol{v_1} \\in V\\) )，则称 \\(V\\) 是一个向量空间。 向量空间的基与维数 向量空间\\(V\\)的一个极大无关组叫做\\(V\\)的一个基，\\(V\\) 的秩叫做\\(V\\)的维数，记作\\(dim(V)\\)。若 \\(dim(V)=r\\)，则称\\(V\\)为\\(r\\)维向量空间。 若已知\\(r\\)维向量空间\\(V\\)的基为\\(\\boldsymbol{v_1,v_2,\\cdots,v_r}\\)，则向量空间\\(V\\)可以表示成 \\[ V=\\{ \\boldsymbol{v}=x_1\\boldsymbol{v_1}+x_2\\boldsymbol{v_2}+\\cdots +x_r\\boldsymbol{v_r} | x_1,x_2,\\cdots,x_r \\in \\mathbb{R}\\} \\] 向量正交与施密特(Schmidt)正交化 当\\(\\boldsymbol{a\\neq 0,b\\neq 0}\\)时，当\\((\\boldsymbol{a,b}=0)\\)，即\\(\\boldsymbol{a^Tb}=0\\)时，称向量\\(\\boldsymbol{a,b}\\)正交。 由两两正交的非零向量组成的向量组称为正交向量组，由单位向量组成的正交向量组称为标准正交向量组。 \\(n\\)维欧氏空间求解正交基,一组基底为\\((\\alpha_1,\\alpha_2,\\cdots,\\alpha_n)\\) Step1:令 \\(\\beta_1=\\alpha_1\\) Step2:计算\\(\\alpha_2\\)在\\(\\beta_1\\)方向上的投影，并做差得到 \\[\\beta_2=\\alpha-\\frac{(\\beta_1,\\alpha_2)}{(\\beta_1,\\beta_1)}\\beta_1\\] Step3:计算\\(\\alpha_3\\)在向量\\(\\beta_1,\\beta_2\\)方向的投影，继续做差得到\\(\\beta_3\\) 格 \\(n\\)元向量的集合 \\(v_1,\\cdots,v_n \\in \\mathbb{R}^n\\)，格（Lattices）就是这些向量的线性组合 \\[L=\\{a_1v_1+a_2v_2+\\cdots+a_nv_n \\mid a_1,a_2,\\cdots,a_n \\in \\mathbb{Z}\\}\\] 对比向量空间的定义，可以发现系数是整数，因此定义出来的格空间是一些格点，而非连续的向量空间。 下图是一个二维格，平行四边形的一组邻边是格的基底。通过对这两个向量不断进行线性组合，那么就产生了很多格点，就形成了一个格。 基本域 假定 \\(v_1,v_2,\\cdots,v_n\\) 是格 \\(L\\) 的基，\\(F\\{v_1,v_2,\\cdots,v_n\\}=\\{a_1v_1+a_2v_2+\\cdots+a_nv_n \\mid a_1,a_2,\\cdots,a_n \\in [0,1]\\}\\) 上图中的平行四边形，就是二维格中一组基底构成的基本域。 格基本域的体积等于格的行列式的值，基本域的体积就是积分，而这也正是行列式的几何意义，\\(Volume(F\\{v_1,v_2,\\cdots,v_n\\})=det(L)\\) 矩阵表示 假定 \\(v_1,v_2,\\cdots,v_n\\) 是格 \\(L\\) 的基，\\(w_1,w_2,\\cdots,w_n \\in L\\)，则必然存在整系数 \\(a_{ij}\\) 使得： \\[ \\begin{cases} w_1=a_{11}v_1+a_{12}v_2+\\cdots+a_{1n}v_n \\\\ w_2=a_{21}v_1+a_{22}v_2+\\cdots+a_{2n}v_n \\\\ \\vdots \\\\ w_n=a_{n1}v_1+a_{n2}v_2+\\cdots+a_{nn}v_n \\end{cases} \\] 可以提取出一个系数矩阵 \\[ A= \\begin{bmatrix} a_{1,1} &amp; a_{1,2} &amp; \\ldots &amp; a_{1,n}\\\\ a_{2,1} &amp; a_{2,2} &amp; \\ldots &amp; a_{2,n}\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{n,1} &amp; a_{n,2} &amp; \\ldots &amp; a_{n,n} \\end{bmatrix} \\] 进而将上述方程组转换为矩阵表示\\(\\boldsymbol{w}=A * \\boldsymbol{v}\\) LLL/BKZ 算法 之前打国际赛看到 discord 里一直有人赞美 flatter，应该是加速 LLL 用的，我还没配好环境。 一种格基约简算法，可以找到格上的一组最短的正交基。 在Sagemath中可以直接调用函数。 但对于函数的实现以及算法的原理没必要深究，在具体题目当中会使用即可。 1234M = matrix(ZZ,[[],[]])L = M.LLL()L = M.BKZ(block_size=2)x = L[0] 下图是高斯启发式，为我们展示了格上最短向量的欧几里得范数的大致范围。 这样我们就知道构造出来的格，是否可以规约出我们的目标向量，也为我们调整格的平衡提供了思路。接下来我们在以下几个问题当中具体看一下LLL算法的应用。 lattice 应用 下面将首先介绍两个最基本问题SVP和CVP，这是格上的两个困难问题，都属于 NP 完全问题。因此在这两个困难问题上也将延伸出很多格密码体系。 SVP 最短向量问题(Shortest Vector Problem，SVP) 这是最基本的一个问题，后续很多格问题最终都转换成了SVP问题，从LLL算法中我们也可以看出，最终得到的是格上的最短正交向量组。 下面从一个例子来介绍格的构造和 LLL 的应用。 1234567p = getPrime(1023)q = getPrime(1023)f = getPrime(2048)g = getPrime(2048)f =g =assert (p * f - 58 * f + q) % g == 44 \\[(p*f - 58 * f + q) \\% g = 44\\] \\[k\\cdot g+44=(p-58)\\cdot f+q\\] 我们目的是通过\\(f,g\\)求出\\(p,q\\)，从代码的定义可以看到，\\(p,q\\)的位数相比于\\(f,g\\)来说很小，因此可以应用格的思路，构造一个合适的格，规约出\\((p,q)\\) 写出如下方程组 \\[k\\cdot g-(p-58)\\cdot f=q-44\\] \\[k\\cdot 0-(p-58)\\cdot (-1)=p-58\\] 可以看到第二个式子是一个恒等式，在构造格时我们通常需要加入这样的恒等式。 下面将方程组转换为矩阵。 \\[(k, p-58) \\begin{bmatrix}0&amp;g\\\\1&amp;-f \\end{bmatrix}=(p-58,q-44)\\] 得到了\\(v*B=w\\)的形式。在这个式子中我们关心的是\\(w\\)向量是否是格\\(B\\)上的最短向量，\\(v\\)这是线性组合的系数并不用过多关注。 在介绍高斯启发式的时候，提到了格上最短向量的欧几里得范数的大致范围，我们现在验证一下，看看\\(w\\)是否是格\\(B\\)上的最短向量，即比较长度\\(||w||\\)和高斯期望值\\(\\sigma(det(B))\\) \\[||w|| = \\sqrt{(p-58)^2+(q-44)^2}\\approx 2^{1024}\\] \\[\\sigma(det(B))\\approx det(B)^{1/2}=\\sqrt{g}\\approx 2^{1024}\\] 于是\\(w\\)大概率为格\\(B\\)上的最短向量，构造格\\(B\\)进行LLL算法即可。 还有个例子可以看背包加密 CVP 最近向量问题(Closest Vector Problem)，格上另一个最常见的问题。 给定格\\(L\\)的一组基与向量\\(v\\)，找到在\\(L\\)上离\\(v\\)最近的一个向量。 方便理解还是看一下几何意义，在连续空间中任找一点\\(p\\)（注意：不一定在格上），要找到格上距离点\\(p\\)最近的一个点。 LWE LWE 问题(Learn With Error) ACD ACD 问题(Approximate Common Divisor)，近似公约数(应该也可以叫 AGCD) 给定\\(t\\)组\\(x_i\\)满足：\\(x_i=pq_i+r_i\\) \\(x_i\\) 已知，\\(p\\) 为 \\(\\alpha\\) 位，\\(q_i\\) 为 \\(\\beta\\) 位 ，\\(r_i\\) 为 \\(\\rho\\) 位（\\(\\rho \\lt\\lt \\alpha\\)），求 \\(p\\)。 \\(p\\)相当于\\(t\\)组\\(x\\)的近似公约数，因此要求了\\(r_i \\lt\\lt p\\) 构造 \\[(q_0,q_1,\\cdots,q_t)\\begin{bmatrix} 2^{\\rho} &amp; x_1 &amp; x_2 &amp; \\cdots &amp; x_t \\newline 0 &amp; -x_0 &amp; 0 &amp; \\cdots &amp; 0 \\newline 0 &amp; 0 &amp; -x_0 &amp; \\cdots &amp; 0 \\newline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; -x_0\\end{bmatrix}=(q_02^{\\rho},q_0x_1-q_1x_0,\\cdots,q_0x_t-q_tx_0)=(q_02^{\\rho},q_0r_1-q_1r_0,\\cdots,q_0r_t-q_tr_0)\\] 记为 \\(v\\cdot B=w\\)。 使用LLL算法得到 \\(q_02^{\\rho}\\)后就可以求出\\(p\\)。 HNP","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"lattice","slug":"lattice","permalink":"https://sch01ar.github.io/tags/lattice/"}]},{"title":"一些关于p^q问题剪枝算法","slug":"剪枝","date":"2023-11-07T04:05:45.000Z","updated":"2023-11-07T08:16:17.464Z","comments":true,"path":"2023/11/07/剪枝/","link":"","permalink":"https://sch01ar.github.io/2023/11/07/%E5%89%AA%E6%9E%9D/","excerpt":"","text":"此篇文章针对 RSA 中 p^q 相关问题及变种做一个总结。之前做过很多 p^q 相关的问题，但是思路大差不差，周末打了鹏城杯，复现时发现要结合 copper 和 dfs 来剪枝。 参考文章 https://tangcuxiaojikuai.xyz/post/342113ee.html https://mp.weixin.qq.com/s/Bi0iQOXwM5UlntrtdRL1oA p^q 搜索方式 从低位搜索，在已知 p^q 和 p*q 的情况下，由于异或是按位进行的，对于每一位异或的结果来说，p、q 该位的组合情况有 4 种[1,0][0,1][1,1][0,0] 剪枝条件 利用p*q==n这一条件来进行筛选，由于是从低位开始爆破，因此满足\\(p_{low}*q_{low}==n_{low}\\) 1234567891011121314151617181920212223242526def get_pq(n, x): a = [0] b = [0] maskx = 1 maskn = 2 for i in range(1024): xbit = (x &amp; maskx) &gt;&gt; i nbit = n % maskn t_a = [] t_b = [] for j in range(len(a)): for aa in range(2): for bb in range(2): if aa ^ bb == xbit: tmp2 = n % maskn tmp1 = (aa * maskn // 2 + a[j]) * (bb * maskn // 2 + b[j]) % maskn if tmp1 == tmp2: t_a.append(aa * maskn // 2 + a[j]) t_b.append(bb * maskn // 2 + b[j]) maskx *= 2 maskn *= 2 a = t_a b = t_b for a1, b1 in zip(a, b): if a1 * b1 == n1: return a1, b1 p^q_rev 12345p = getPrime(256)q = getPrime(256)_q = int(bin(q)[2:][::-1] , 2)n = p * qgift = p ^ q_ 搜索方式 从两端爆破 每一次搜索，需利用当前 gift 两端的 bit 位。这是因为，gift 的当前最高位对应 p 的最高位及 q 的最低位，gift 的当前最低位对应 p 的最低位及 q 的最高位 剪枝条件 将 p、q 未搜索到的位全填 0，乘积应小于 n 将 p、q 未搜索到的位全填 1，乘积应大于 n p、q 低 k 位乘积再取低 k 位，应与 n 的低 k 位相同 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from Crypto.Util.number import *import syssys.setrecursionlimit(1500)pxorq = 47761879279815109356923025519387920397647575481870870315845640832106405230526n = 10310021142875344535823132048350287610122830618624222175188882916320750885684668357543070611134424902255744858233485983896082731376191044874283981089774677c = 999963120986258459742830847940927620860107164857685447047839375819380831715400110131705491405902374029088041611909274341590559275004502111124764419485191e = 65537pxorq = str(bin(pxorq)[2:]).zfill(256)def find(ph,qh,pl,ql): l = len(ph) tmp0 = ph + (256-2*l)*&quot;0&quot; + pl tmp1 = ph + (256-2*l)*&quot;1&quot; + pl tmq0 = qh + (256-2*l)*&quot;0&quot; + ql tmq1 = qh + (256-2*l)*&quot;1&quot; + ql if(int(tmp0,2)*int(tmq0,2) &gt; n): return if(int(tmp1,2)*int(tmq1,2) &lt; n): return if(int(pl,2)*int(ql,2) % (2**(l-1)) != n % (2**(l-1))): return if(l == 128): pp0 = int(tmp0,2) if(n % pp0 == 0): pf = pp0 qf = n//pp0 phi = (pf-1)*(qf-1) d = inverse(e,phi) m1 = pow(c,d,n) print(long_to_bytes(m1)) exit() else: if(pxorq[l] == &quot;1&quot; and pxorq[255-l] == &quot;1&quot;): find(ph+&quot;1&quot;,qh+&quot;0&quot;,&quot;1&quot;+pl,&quot;0&quot;+ql) find(ph+&quot;0&quot;,qh+&quot;0&quot;,&quot;1&quot;+pl,&quot;1&quot;+ql) find(ph+&quot;1&quot;,qh+&quot;1&quot;,&quot;0&quot;+pl,&quot;0&quot;+ql) find(ph+&quot;0&quot;,qh+&quot;1&quot;,&quot;0&quot;+pl,&quot;1&quot;+ql) elif(pxorq[l] == &quot;1&quot; and pxorq[255-l] == &quot;0&quot;): find(ph+&quot;1&quot;,qh+&quot;0&quot;,&quot;0&quot;+pl,&quot;0&quot;+ql) find(ph+&quot;0&quot;,qh+&quot;0&quot;,&quot;0&quot;+pl,&quot;1&quot;+ql) find(ph+&quot;1&quot;,qh+&quot;1&quot;,&quot;1&quot;+pl,&quot;0&quot;+ql) find(ph+&quot;0&quot;,qh+&quot;1&quot;,&quot;1&quot;+pl,&quot;1&quot;+ql) elif(pxorq[l] == &quot;0&quot; and pxorq[255-l] == &quot;1&quot;): find(ph+&quot;0&quot;,qh+&quot;0&quot;,&quot;1&quot;+pl,&quot;0&quot;+ql) find(ph+&quot;0&quot;,qh+&quot;1&quot;,&quot;0&quot;+pl,&quot;0&quot;+ql) find(ph+&quot;1&quot;,qh+&quot;0&quot;,&quot;1&quot;+pl,&quot;1&quot;+ql) find(ph+&quot;1&quot;,qh+&quot;1&quot;,&quot;0&quot;+pl,&quot;1&quot;+ql) elif(pxorq[l] == &quot;0&quot; and pxorq[255-l] == &quot;0&quot;): find(ph+&quot;0&quot;,qh+&quot;0&quot;,&quot;0&quot;+pl,&quot;0&quot;+ql) find(ph+&quot;1&quot;,qh+&quot;0&quot;,&quot;0&quot;+pl,&quot;1&quot;+ql) find(ph+&quot;0&quot;,qh+&quot;1&quot;,&quot;1&quot;+pl,&quot;0&quot;+ql) find(ph+&quot;1&quot;,qh+&quot;1&quot;,&quot;1&quot;+pl,&quot;1&quot;+ql)find(&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;) p^(q&gt;&gt;nbits) 1234P = getPrime(512)Q = getPrime(512)N = P * Qgift = P ^ (Q &gt;&gt; 16) 思路 这个其实并不算剪枝了，因为 gift 的高 16 位就是 P 的高 16 位。用 N 除以 P 后得到的就是 Q 的高位，再次利用 Q 的高位和 gift，可以求出 P 的 16 ～ 32 位，以此类推来恢复 P、Q。 123456789101112131415161718pbar = gift &gt;&gt;(512-16)while True: try: qbar = (N&gt;&gt;(1024 - pbar.bit_length()*2))//pbar qbar = qbar&gt;&gt;6 gifts = gift^(qbar&lt;&lt;(512-16-qbar.bit_length())) pbar = gifts &gt;&gt; (512-16-qbar.bit_length()) except: breakfor i in range(64): if N%((pbar&lt;&lt;6)+i) == 0: p = (pbar&lt;&lt;6)+i q = N//p print(&quot;[+] p =&quot;,p) print(&quot;[+] q =&quot;,q) break (p^q)&gt;&gt;nbits 12345nbits = 512p = getPrime(nbits)q = getPrime(nbits)leakBits = 262leak = (p ^ q) &gt;&gt; (nbits - leakBits) 搜索方式 从高位搜索 p 的高位乘 q 的高位的前半部分等于 n 的高位 剪枝条件 低位全补 0，相乘结果 &lt; n 低位全补 1，相乘结果 &gt; n 123456789101112131415161718192021p=&#x27;1&#x27;q=&#x27;1&#x27;P=[p]Q=[q]for i in range(261): PP=[] QQ=[] for a in &#x27;01&#x27;: for b in &#x27;01&#x27;: for pnew,qnew in zip(P,Q): pnew = pnew+a qnew = qnew+b tmp = int(pnew,2)*int(qnew,2) if xor(pnew,qnew) == leak[:2+i] and tmp&gt;&gt;(tmp.bit_length()-i//2)== n&gt;&gt;(n.bit_length()-i//2) and (int(pnew.ljust(512,&#x27;0&#x27;),2)*int(qnew.ljust(512,&#x27;0&#x27;),2) &lt; n) and (int(pnew.ljust(512,&#x27;1&#x27;),2)*int(qnew.ljust(512,&#x27;1&#x27;),2) &gt; n) : PP.append(pnew) QQ.append(qnew) print(len(P)) P = PP.copy() Q = QQ.copy()print(P) coppersmith 上述剪枝只能求出高 262 位了，有多种组合，但仍缺少低 250 位，因此需要用到 coppersmith 来求解。 在具体应用情景中应当适当调整beta和epsilon。 123456789101112from tqdm import *R.&lt;x&gt; = Zmod(n)[]for pbar in tqdm(P[::-1]): for i in range(32): tmp = int(pbar,2)&lt;&lt;5 tmp+=i f = tmp*2**245 + x xx = f.monic().small_roots(X=2^245,beta=0.47,epsilon=0.02) if xx: p = f(xx[0]) print(p)","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"2023CBCTF","slug":"2023CBCTF","date":"2023-11-01T12:23:06.239Z","updated":"2023-11-02T11:34:49.710Z","comments":true,"path":"2023/11/01/2023CBCTF/","link":"","permalink":"https://sch01ar.github.io/2023/11/01/2023CBCTF/","excerpt":"","text":"之前和 N1CTF 撞了，但是比赛题目质量很高，当时浅看了一下，现在补一下。 CB_Curve 利用 Grobner 基解 P 点，后续复现才知道这是HUFF曲线，根据论文方法得到曲线的定义和映射方法，这样就可得到维尔斯特拉斯形式，后续通过光滑阶求解离散对数即可。 关于 Grobner 基的应用，想到暑假0x401师傅出的一道题，后续写在这道题后面，加深一下印象。 曲线形式 \\[ x(a^2y-1)≡y(bx^2-1) mod \\quad p \\] 曲线映射 \\[ (x,y)→(\\frac{bx-ay}{y-x},\\frac{b-a}{y-x}) \\] 目标曲线 \\[ y^2≡x^3+(a+b)x^2+abx \\quad mod \\quad p \\] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from Crypto.Util.number import *from random import randintclass CB_curve: def __init__(self): self.p = 1141741939958844590498346884870015122543626602665954681008204697160652371664923 self.a = 727131475903635498678013730344448225340496007388151739960305539398192321065043 self.b = 840714623434321649308065401328602364673881568379142278640950034404861312007307 def add(self, P, Q): if P == -1: return Q (x1, y1) = P (x2, y2) = Q x3 = (x1+x2)*(1+self.a*y1*y2)*inverse((1+self.b*x1*x2) * (1-self.a*y1*y2), self.p) % self.p y3 = (y1+y2)*(1+self.b*x1*x2)*inverse((1-self.b*x1*x2) * (1+self.a*y1*y2), self.p) % self.p return (x3, y3) def mul(self, x, P): Q = -1 while x &gt; 0: if x &amp; 1: Q = self.add(Q, P) P = self.add(P, P) x = x &gt;&gt; 1 return Q # def negG(self, G): # return self.mul(order-1, G)# pl = [908996880816674413953945844149350915331956247471480600840221415119794882139724, 971918808384910355828135603762747020183688585728289421786279444571287619529246, 1285550352531583269956802123237391199017403081800977678246201935580429758051904, 1551774945769448705387900437472951015954157193946719575845523359198154668857591, 676185408751480221545400062950292727848016906516506232986883519673765317932582,# 1250300209784131850574858927023046353058343552115735540789593580037130054384362, 1298409778422699298367007023890818793557023853717180295526932023194697263501748, 1332552452292482549702793642987623159617988974910321945878093492007278710993114, 1030239404875082841481045525469865919289388171602293245905162820968158543176773, 1154148024180033719999293176590867264297899817449945744942661351655533433871621]# ph = [584297112520340495757457954416165393828472756298945167299482077258411155766756, 886432149227960827335266910774569034430464592640209168563805700117347063152246, 613528590036968449893421430816319461615130635882647544978722093413694101540550, 576162106332135829961234799085370038425761945928004579456101802617485243023987, 627570890346195626159365118862437334953500165050236216404858019114288681512171,# 1015503424232985454098149884321288932492551183126601131968495641510550575005042, 1532737675157046782602115678180407262847166210963507805526455422934164759886583, 1540047002602145805476906585925538790245968214992837106009502002588479779602195, 505097517314409449404205152068185149808364887623922221197462411159844816865696, 873498218680784138428154510303205366133389839886911286745954821800632158315951]ecc = CB_curve()# G = (586066762126624229327260483658353973556531595840920560414263113786807168248797,# 66727759687879628160487324122999265926655929132333860726404158613654375336028)# # P = (ecc.mul(bytes_to_long(flag),G)[0],randint(1,ecc.p))# Q = (460843895959181097343292934009653542386784127282375019764638432240505304648101,# 739422832583403823403837831802136107593509589942947902014204968923412689379907)a = ecc.ab = ecc.bp = ecc.p# R.&lt; x1, y1, e &gt;= PolynomialRing(Zmod(p))# R = PolynomialRing(Zmod(p), [&#x27;x1&#x27;, &#x27;y1&#x27;, &#x27;e&#x27;])# F = []# r = []# for i in range(10):# r.append(ecc.mul(10-i, Q))# for i in range(10):# x2, y2 = r[i]# f = (ph[i] - e)*(1+b*x1*x2)*(1-a*y1*y2)-(x1+x2)*(1+a*y1*y2)# F.append(f)# res = Ideal(F).groebner_basis()# [x1 + 239643535167901657800210470774814532510308869595840873642845564328410464397042, y1 + 146109242247186884695587727086539555907710369392694609972293964300672819401615, e + 716700711017198421972376297958894204723153539777056104579499803899129208364755]E = EllipticCurve(GF(p), [0, a+b, 0, a*b, 0])x1 = -239643535167901657800210470774814532510308869595840873642845564328410464397042 % pG = (586066762126624229327260483658353973556531595840920560414263113786807168248797, 66727759687879628160487324122999265926655929132333860726404158613654375336028)# R.&lt;y1&gt; = PolynomialRing(GF(p))# f = x1*(a*y1^2-1)-y1*(b*x1^2-1)# y1 = int(f.roots()[1][0])y1 = 672929595307990944197873882889709005621738844588134711458648048321447534353147P = (int(x1), int(y1))G = E((b*G[0] - a*G[1]) * inverse_mod(G[1]-G[0], p) % p, (b-a)*inverse_mod(G[1]-G[0], p) % p)P = E((b*P[0] - a*P[1]) * inverse_mod(P[1]-P[0], p) % p, (b-a)*inverse_mod(P[1]-P[0], p) % p)order = G.order()order = 570870969979422295249173442435007561272085504844186092739816337605942962972880primes = [3, 5, 16, 37, 271, 4297, 6983, 9679, 52631, 139571, 84666937, 558977989]logs = []for fac in primes: t = int(order)//int(fac) log = discrete_log(t*P, t*G, operation=&#x27;+&#x27;) logs += [log]m = crt(logs, primes)print(long_to_bytes(m))# b&#x27;DASCTF&#123;goodathuff&#125;&#x27; ezAlgebra(DASCTF 2023 &amp; 0X401) 题目描述 1234567891011121314151617181920212223242526from Crypto.Util.number import getPrime, bytes_to_longdef encrypt(Wo, Xue, Hui, Le, Kai): Qi = 1997 Che = Wo+Hui if Le == 1 else Wo*Hui while (Xue): Qi += (pow(Che, Xue, Kai)) % Kai Xue -= 1 return Qil = 512m = bytes_to_long(flag)p = getPrime(l)q = getPrime(l//2)r = getPrime(l//2)n = p * q * rt = getrandbits(32)c1 = encrypt(t, 4, p, 1, n)c2 = encrypt(m, 19, t, 0, q)c3 = encrypt(m, 19, t, 1, q)print(f&quot;n = &#123;n&#125;&quot;)print(f&quot;c1 = &#123;c1&#125;&quot;)print(f&quot;c2 = &#123;c2&#125;&quot;)print(f&quot;c3 = &#123;c3&#125;&quot;) 一元 coppersimth 用 c1 求 t，从而获得 p 1234567PR.&lt;t&gt;= PolynomialRing(Zmod(n))f = t ^ 4+t ^ 3+t ^ 2+t+1997-c1root = f.small_roots(X=2^32,beta=0.4)print(root)t=2915836867kp = t ^ 4+t ^ 3+t ^ 2+t+1997-c1p = GCD(kp, n) 根据 c2、c3 建立两个多项式 1234567P.&lt;m,t&gt; = PolynomialRing(Zmod(n))f1 = 1997 - c3f2 = 1997 - c2f3 = t-2915836867for i in range(1,20): f1 += (m + t)^i f2 += (m * t)^i 虽然只有 m 未知，但使用 Grobner 基需要至少二元多项式，所以引入 t，同理引入f3 = t-2915836867，接下来采用 Grobner 获得理想基即可。 12345G = [f1,f2,f3]B = Ideal(G).groebner_basis()for x in B: print(x) 最终解 flag 12345678q = 87038069032840052005520908272237788908169043580221040711149494083975743478969m = -21158731716376226090392498841915660119151249151578293634082749989659307225047065454562556490794720241251831294269248252992828782428316834166828404876181491874871787144664849984606114249820338190252050491223066273953777506705536480844475141933848618113343415375867066617512805575869013694523034573111259114274 % qfor i in range(10000000): flag = i*q+m flag = long_to_bytes(flag) if b&#x27;dasctf&#x27; in flag: print(flag) # break CB_RSA 12345678910111213141516171819202122232425262728293031323334353637383940414243from gmpy2 import *from Crypto.Util.number import *from libnum import *import randomn1 = 65634094430927080732256164808833233563732628654160389042977689628512527168256899310662239009610512772020503283842588142453533499954947692968978190310627721338357432052800695091789711809256924541784954080619073213358228083200846540676931341013554634493581962527475555869292091755676130810562421465063412235309n2 = 103670293685965841863872863719573676572683187403862749665555450164387906552249974071743238931253290278574192713467491802940810851806104430306195931179902098180199167945649526235613636163362672777298968943319216325949503045377100235181706964846408396946496139224344270391027205106691880999410424150216806861393(e1, noise1, c1) = (1743, 44560588075773853612820227436439937514195680734214431948441190347878274184937952381785302837541202705212687700521129385632776241537669208088777729355349833215443048466316517110778502508209433792603420158786772339233397583637570006255153020675167597396958251208681121668808253767520416175569161674463861719776, 65643009354198075182587766550521107063140340983433852821580802983736094225036497335607400197479623208915379722646955329855681601551282788854644359967909570360251550766970054185510197999091645907461580987639650262519866292285164258262387411847857812391136042309550813795587776534035784065962779853621152905983)(e2, noise2, c2) = (1325, 35282006599813744140721262875292395887558561517759721467291789696459426702600397172655624765281531167221787036009507833425145071265739486735993631460189629709591456017092661028839951392247601628468621576100035700437892164435424035004463142959219067199451575338270613300215815894328788753564798153516122567683, 50327632090778183759544755226710110702046850880299488259739672542025916422119065179822210884622225945376465802069464782311211031263046593145733701591371950349735709553105217501410716570601397725812709771348772095131473415552527749452347866778401205442409443726952960806789526845194216490544108773715759733714)c = 124349762993424531697403299350944207725577290992189948388824124986066269514204313888980321088629462472088631052329128042837153718129149149661961926557818023704330462282009415874674794190206220980118413541269327644472633791532767765585035518183177197863522573410860341245613331398610013697803459403446614221369e = 0x10001f = open(&#x27;enc.txt&#x27;,&#x27;r&#x27;).read().strip().split(&#x27;n&#x27;)cipher = [i for i in f]cipher = cipher[:-1]cipher = [int(i) for i in cipher]flag = &quot;&quot;for i in cipher: if jacobi(i,n1)==-1: flag += &#x27;0&#x27; else: flag += &#x27;1&#x27;p = int(flag[::-1],2)print(&#x27;p = &#x27;+str(p))def attack(c1, c2, noise1, noise2, e1, e2 , n): PR.&lt;x&gt;=PolynomialRing(Zmod(n)) g1 = (x + noise1)^e1 - c1 g2 = (x + noise2)^e2 - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() print(gcd(g1, g2)) return -gcd(g1, g2)[0]q = int(attack(c1, c2, noise1, noise2, e1, e2 , n2))print(&#x27;q = &#x27; +str(q))n = p*qphi = (p-1)*(q-1)d = inverse_mod(e,phi)m = power_mod(c,d,n)print(long_to_bytes(m))","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"2023ACTF","slug":"2023ACTF","date":"2023-10-30T12:05:45.000Z","updated":"2023-10-31T09:16:26.024Z","comments":true,"path":"2023/10/30/2023ACTF/","link":"","permalink":"https://sch01ar.github.io/2023/10/30/2023ACTF/","excerpt":"","text":"周末打了一下 ACTF，题目质量很高。总共 6 道题目做了 3 道，有一道卡着等后续复现。最近太累了，周末比赛，周内复现。。。🐭🐭 我啊，打 CTF 打的！ MDH 手快抢了个三血 hh 看到这道题第一反应是死去的线代开始攻击我，好在还有点印象，对于矩阵的迹来说，就是对角线元素的和。 123456789101112131415161718192021222324from hashlib import sha256from secret import flagr = 128c = 96p = 308955606868885551120230861462612873078105583047156930179459717798715109629Fp = GF(p)def gen(): a1 = random_matrix(Fp, r, c) a2 = random_matrix(Fp, r, c) A = a1 * a2.T return (a1, a2), Ask_alice, pk_alice = gen()sk_bob, pk_bob = gen()shared = (sk_alice[0].T * pk_bob * sk_alice[1]).trace()ct = int(sha256(str(int(shared)).encode()).hexdigest(), 16) ^^ int.from_bytes(flag, &#x27;big&#x27;)with open(&#x27;output.txt&#x27;, &#x27;wb&#x27;) as f: f.write(str(ct).encode() + b&#x27;\\n&#x27;) f.write(str(list(pk_alice)).encode() + b&#x27;\\n&#x27;) f.write(str(list(pk_bob)).encode() + b&#x27;\\n&#x27;) 将shared的矩阵表示为\\(a_1^T\\cdot b_1\\cdot b_2^T \\cdot a_2\\) 而题目已知\\(PKA=a_1\\cdot a_2^T,PKB=b_1\\cdot b_2^T\\) 对于迹的一个性质来说，若干向量相乘所得的方阵，改变其相乘顺序，矩阵的迹都应一致。 因此只需计算\\(PKA^T\\cdot PKB\\)的迹即可。 123456789101112from hashlib import sha256from Crypto.Util.number import *p = 308955606868885551120230861462612873078105583047156930179459717798715109629Fp = GF(p)pk_alice=matrix(Fp,pk_alice)pk_bob=matrix(Fp,pk_bob)tmp2=pk_alice*pk_bob.Tprint(tmp2.trace())shared = 229215835499100713048005195047655740191791862411327976508820034350300131774ct = 8308943029741424587523612386337754255889681699670071706719724435165094611096603769021839263flag = int(sha256(str(int(shared)).encode()).hexdigest(), 16) ^ ctprint(long_to_bytes(flag)) claw crane 题如其名，真牛魔抓娃娃 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#!/usr/bin/env python3from Crypto.Util.number import ( bytes_to_long, long_to_bytes)from hashlib import md5import osimport signalimport sysimport randomBITS = 128class ClawCrane(object): def __init__(self) -&gt; None: self.seed = bytes_to_long(os.urandom(BITS//8)) self.bless = 0 self.score = 0 def get_input(self, prompt=&quot;&gt; &quot;): print(prompt, end=&quot;&quot;) sys.stdout.flush() return input() def check_pos(self, pos, moves): col, row = 0, 0 for move in moves: if move == &quot;W&quot;: if row &lt; 15: row += 1 elif move == &quot;S&quot;: if row &gt; 0: row -= 1 elif move == &quot;A&quot;: if col &gt; 0: col -= 1 elif move == &quot;D&quot;: if col &lt; 15: col += 1 else: return -1 print(col, row) return pos == [col, row] def gen_chaos(self, inp): def mapping(x): if x == &#x27;W&#x27;: return &quot;0&quot; if x == &#x27;S&#x27;: return &quot;1&quot; if x == &#x27;A&#x27;: return &quot;2&quot; if x == &#x27;D&#x27;: return &quot;3&quot; vs = int(&quot;&quot;.join(map(mapping, inp)), 4) chaos = bytes_to_long(md5( long_to_bytes((self.seed + vs) % pow(2, BITS)) ).digest()) self.seed = (self.seed + chaos + 1) % pow(2, BITS) return chaos def destiny_claw(self, delta): bits = bin(delta)[2:] if len(bits) &lt; 128+self.bless: bits += &quot;0&quot;*(128+self.bless - len(bits)) c = random.choice(bits) print(bits) if c == &#x27;0&#x27;: return True else: return False def run(self): pos = [random.randrange(1, 16), random.randrange(1, 16)] moves = self.get_input(f&quot;i am at &#123;pos&#125;, claw me.\\nYour moves: &quot;) if len(moves) &gt; 100: print(&quot;too many steps&quot;) return if not self.check_pos(pos, moves): print(&quot;sorry, clawed nothing&quot;) return r = self.gen_chaos(moves[:64]) print(f&quot;choas: &#123;r&#125;&quot;) p, q = map(int, self.get_input( f&quot;give me your claw using p,q and p,q in [0, 18446744073709551615] (e.g.: 1,1): &quot;).split(&quot;,&quot;)) if not (p &gt; 0 and p &lt; pow(2, BITS//2) and q &gt; 0 and q &lt; pow(2, BITS//2)): print(&quot;not in range&quot;) return delta = abs(r*q - p*pow(2, BITS)) if self.destiny_claw(delta): self.score += 10 self.bless = 0 print(&quot;you clawed it&quot;) else: self.bless += 16 print(&quot;sorry, clawed nothing&quot;)def main(): signal.alarm(600) cc = ClawCrane() for _ in range(256): try: cc.run() print(f&quot;your score: &#123;cc.score&#125;&quot;) except: print(f&quot;abort&quot;) break if cc.score &gt;= 2220: print(f&quot;flag: &#123;open(&#x27;/flag.txt&#x27;).read()&#125;&quot;)if __name__ == &quot;__main__&quot;: main() 总之就是要在你构造出的 128 位数当中随机选择选到 0 才会加分，256 次中需要正确 220 次，因此就想方设法让数字的 2 进制 0 多一些，delta = abs(r * q - p * pow(2, 128))，r 已知，需要我们传入 p、q，由于\\(p\\cdot 2^{128}\\)相当于左移 128 位，因此我们也要让 rq 的低位尽可能也为 0，q 不能超过 2^64 次方，因此 q 的取值可以为\\(2^{63},2^{63}+2^{62},2^{62}......\\) 对于给定的 r 和 q 计算一个 p 值，在多组当中进行 delta 中 0 个数的计算，选择 0 个数最高的一组 p、q 发送，分数可以稳定在 2000 以上，运气好一会就出了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from pwn import *# context.log_level = &#x27;debug&#x27;round1=0score=0def check(delta): nums=0 bits = str(bin(delta)[2:]) for i in range(len(bits)): if bits[i]==&#x27;0&#x27;: nums+=1 return numswhile 1: round1+=1 io = remote(&#x27;120.46.65.156&#x27;, 19991) count=0 print(round1) print(score) while 1: try: tmp=io.recvuntil(b&#x27;],&#x27;) # print(tmp) pos=eval(tmp[8:-1]) # print(pos) io.recvuntil(b&#x27;moves: &#x27;) pay=pos[0]*&#x27;D&#x27;+pos[1]*&#x27;W&#x27; io.sendline(pay.encode()) # print(io.recv()) io.recvline() r=int(io.recvline()[7:-1].decode()) # print(r) io.recvuntil(b&#x27;1,1): &#x27;) # 初始化变量 max_re = -1 best_p = -1 best_q = -1 # 循环生成 q 和 p 的组合，计算 delta 和 re for i in range(1,512): q = 0 if i &amp; 1: q += 2 ** 55 if i &amp; 2: q += 2 ** 56 if i &amp; 4: q += 2 ** 57 if i &amp; 8: q += 2 ** 58 if i &amp; 16: q += 2 ** 59 if i &amp; 32: q += 2 ** 60 if i &amp; 64: q += 2 ** 61 if i &amp; 128: q += 2 ** 62 if i &amp; 256: q += 2 ** 63 p = (r * q) // (2 ** 128) delta = abs(r * q - p * pow(2, 128)) re0 = check(delta) if re0 &gt; max_re: max_re = re0 best_p = p best_q = q io.sendline((str(best_p)+&#x27;,&#x27;+str(best_q)).encode()) io.recvline() tmp=io.recvline() score=int(tmp[12:-1]) count+=1 except: break if count&gt;=256: print(io.recv()) break Easy RSA 题目 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980from secret import flagfrom Crypto.Util.number import *def genKey(nbits, dbits): bbits = (nbits // 2 - dbits) // 2 while True: a = getRandomNBitInteger(dbits) b = getRandomNBitInteger(bbits) c = getRandomNBitInteger(bbits) p1 = a * b * c + 1 if isPrime(p1): print(a) print(&quot;p1 =&quot;, p1) break while True: d = getRandomNBitInteger(dbits) p2 = b * c * d + 1 if isPrime(p2): print(d) print(&quot;p2 =&quot;, p2) break while True: e = getRandomNBitInteger(bbits) f = getRandomNBitInteger(bbits) q1 = e * d * f + 1 p3 = a * e * f + 1 if isPrime(q1) and isPrime(p3): print(&quot;p3 =&quot;, p3) print(&quot;q1 =&quot;, q1) break while True: d_ = getRandomNBitInteger(dbits) if GCD(a * b * c * d * e * f, d_) != 1: continue e_ = inverse(d_, a * b * c * d * e * f) k1 = (e_ * d_ - 1) // (a * b * c * d * e * f) assert e_ * d_ == (a * b * c * d * e * f) * k1 + 1 q2 = k1 * e * f + 1 q3 = k1 * b * c + 1 if isPrime(q2) and isPrime(q3): print(&quot;q2 =&quot;, q2) print(&quot;q3 =&quot;, q3) print(&quot;e =&quot;, e_) print(&quot;d =&quot;, d_) break n1 = p1 * q1 n2 = p2 * q2 n3 = p3 * q3 assert pow(pow(0xdeadbeef, e_, n1), d_, n1) == 0xdeadbeef assert pow(pow(0xdeadbeef, e_, n2), d_, n2) == 0xdeadbeef assert pow(pow(0xdeadbeef, e_, n3), d_, n3) == 0xdeadbeef return (e_, n1, n2, n3)nbits = 0x600dbits = 0x210m = bytes_to_long(flag)e, n1, n2, n3 = genKey(nbits, dbits)c = pow(m, e, n1)print(&quot;c =&quot;, c)print(&quot;e =&quot;, e)print(&quot;n1 =&quot;, n1)print(&quot;n2 =&quot;, n2)print(&quot;n3 =&quot;, n3)# c = 63442255298812942222810837512019302954917822996915527697525497640413662503768308023517128481053593562877494934841788054865410798751447333551319775025362132176942795107214528962480350398519459474033659025815248579631003928932688495682277210240277909527931445899728273182691941548330126199931886748296031014210795428593631253184315074234352536885430181103986084755140024577780815130067722355861473639612699372152970688687877075365330095265612016350599320999156644# e = 272785315258275494478303901715994595013215169713087273945370833673873860340153367010424559026764907254821416435761617347240970711252213646287464416524071944646705551816941437389777294159359383356817408302841561284559712640940354294840597133394851851877857751302209309529938795265777557840238332937938235024502686737802184255165075195042860413556866222562167425361146312096189555572705076252573222261842045286782816083933952875990572937346408235562417656218440227# n1 = 473173031410877037287927970398347001343136400938581274026578368211539730987889738033351265663756061524526288423355193643110804217683860550767181983527932872361546531994961481442866335447011683462904976896894011884907968495626837219900141842587071512040734664898328709989285205714628355052565784162841441867556282849760230635164284802614010844226671736675222842060257156860013384955769045790763119616939897544697150710631300004180868397245728064351907334273953201# n2 = 327163771871802208683424470007561712270872666244394076667663345333853591836596054597471607916850284565474732679392694515656845653581599800514388800663813830528483334021178531162556250468743461443904645773493383915711571062775922446922917130005772040139744330987272549252540089872170217864935146429898458644025927741607569303966038195226388964722300472005107075179204987774627759625183739199425329481632596633992804636690274844290983438078815836605603147141262181# n3 = 442893163857502334109676162774199722362644200933618691728267162172376730137502879609506615568680508257973678725536472848428042122350184530077765734033425406055810373669798840851851090476687785235612051747082232947418290952863499263547598032467577778461061567081620676910480684540883879257518083587862219344609851852177109722186714811329766477552794034774928983660538381764930765795290189612024799300768559485810526074992569676241537503405494203262336327709010421 关键信息 123assert pow(pow(0xdeadbeef, e_, n1), d_, n1) == 0xdeadbeefassert pow(pow(0xdeadbeef, e_, n2), d_, n2) == 0xdeadbeefassert pow(pow(0xdeadbeef, e_, n3), d_, n3) == 0xdeadbeef 说明了这一组e_,d_满足三个模数 n，相当于已知三组 n、e，对于题目所限制的 d 的位数，刚好满足造格的情况 1234567891011121314151617181920import gmpy2from Crypto.Util.number import *c =e =n1 =n2 =n3 =t = 3N = [n1, n2, n3]e = [e, e, e]B = Matrix(ZZ, t+1, t+1)M = gmpy2.iroot(int(N[t-1]), int(2))[0]B[0, 0] = Mfor i in range(1, t+1): B[i, i] = -N[i-1] B[0, i] = e[i-1]Blll = B.LLL()d = int(abs(Blll[0][0]//M))print(long_to_bytes(pow(c, d, n1))) Review 此部分在阅读其余队伍 wp 后的复盘，对于上题，格的具体构造思路描述如下： \\[ \\begin{aligned} ED -k_1N_1 &amp;= 1+k_1x_1 \\\\ ED -aN_2 &amp;= 1+ax_2 \\\\ ED -dN_3 &amp;= 1+dx_3 \\end{aligned} \\] 构造格: \\[ \\begin{bmatrix} 2^{767} &amp; E &amp;E&amp;E\\\\ 0 &amp; -N_1 &amp;0&amp;0\\\\ 0 &amp; 0 &amp;-N_2&amp;0\\\\ 0 &amp; 0 &amp;0&amp;-N_3\\\\ \\end{bmatrix} \\] Mid RSA(赛后复现) 与 Easy 不同的地方在于将 d 位数提高，原本的格无法规约出来，当时调格子调吐了，但是真没想到本地生成一组数和上一题对比一下，上题的格子拿过来只是差了几位低位。。。 12nbits = 0x600dbits = 0x240 对于 \\[ \\begin{aligned} e(d_h\\times2^{16}+d_l) -1 &amp;= k_1\\phi(N_1) \\\\ e(d_h\\times2^{16}+d_l) -1 &amp;= k_2\\phi(N_2) \\\\ e(d_h\\times2^{16}+d_l) -1 &amp;= k_3\\phi(N_3) \\end{aligned} \\] 有 \\[ \\begin{aligned} e2^{16}d_h+ed_l -k_1N_1 &amp;= 1+k_1s_1 \\\\ e2^{16}d_h+ed_l -k_2N_2 &amp;= 1+k_2s_2 \\\\ e2^{16}d_h+ed_l -k_3N_3 &amp;= 1+k_3s_3 \\end{aligned} \\] 构造格: \\[ \\begin{bmatrix} 1 &amp; e2^{16} &amp;e2^{16}&amp;e2^{16}&amp;0\\\\ 0 &amp; -N_1 &amp;0&amp;0&amp;0\\\\ 0 &amp; 0 &amp;-N_2&amp;0&amp;0\\\\ 0 &amp; 0 &amp;0&amp;-N_3&amp;0\\\\ 0 &amp; ed_l&amp;ed_l&amp;ed_l&amp;1\\\\ \\end{bmatrix} \\] 构造方法参考星盟 0HB 师傅，至于为何是低位 16 位，师傅给出的解释是，本地测了一组数据，发现用上一题的格子跑出来相差了 16 位，但具体相差多少还需要具体研究，由于 16 位已足够爆破，因此公式中写为了 16 次方。 经本人测试，对于本题的 d 缺失了 7 位。 123456789101112131415161718192021222324252627282930313233from tqdm import tqdmfrom Crypto.Util.number import *c = 598823083137858565473505718525815255620672892612784824187302545127574115000325539999824374357957135208478070797113625659118825530731575573239221853507638809719397849963861367352055486212696958923800593172417262351719477530809870735637329898331854130533160020420263724619225174940214193740379571953951059401685115164634005411478583529751890781498407518739069969017597521632392997743956791839564573371955246955738575593780508817401390102856295102225132502636316844e = 334726528702628887205076146544909357751287869200972341824248480332256143541098971600873722567713812425364296038771650383962046800505086167635487091757206238206029361844181642521606953049529231154613145553220809927001722518303114599682529196697410089598230645579658906203453435640824934159645602447676974027474924465177723434855318446073578465621382859962701578350462059764095163424218813852195709023435581237538699769359084386399099644884006684995755938605201771n1 = 621786427956510577894657745225233425730501124908354697121702414978035232119311662357181409283130180887720760732555757426221953950475736078765267856308595870951635246720750862259255389006679454647170476427262240270915881126875224574474706572728931213060252787326765271752969318854360970801540289807965575654629288558728966771231501959974533484678236051025940684114262451777094234017210230731492336480895879764397821363102224085859281971513276968559080593778873231n2 = 335133378611627373902246132362791381335635839627660359611198202073307340179794138179041524058800936207811546752188713855950891460382258433727589232119735602364790267515558352318957355100518427499530387075144776790492766973547088838586041648900788325902589777445641895775357091753360428198189998860317775077739054298868885308909495601041757108114540069950359802851809227248145281594107487276003206931533768902437356652676341735882783415106786497390475670647453821n3 = 220290953009399899705676642623181513318918775662713704923101352853965768389363281894663344270979715555659079125651553079702318700200824118622766698792556506368153467944348604006011828780474050012010677204862020009069971864222175380878120025727369117819196954091417740367068284457817961773989542151049465711430065838517386380261817772422927774945414543880659243592749932727798690742051285364898081188510009069286094647222933710799481899960520270189522155672272451N = [n1, n2, n3]e = [e, e, e]t = 4lowbits = 7for dl in tqdm(range(2 ^ lowbits)): B = Matrix(ZZ, t+1, t+1) B[0, 0] = 2 ^ (767+lowbits) B[t, t] = 2 ^ (767+576) for i in range(1, t): B[i, i] = N[i-1] B[0, i] = e[i-1]*2 ^ lowbits B[t, i] = e[i-1]*dl Mat_LLL = B.LLL() for line in Mat_LLL: dh = abs(line[0])//2 ^ (lowbits+767) d = int((dh &lt;&lt; lowbits)+dl) m = int(pow(c, d, n1)) flag1 = long_to_bytes(m) if b&#x27;ACTF&#123;&#x27; in flag1: print(flag1) break","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"2023N1CTF","slug":"N1CTF2023","date":"2023-10-23T12:05:45.000Z","updated":"2023-10-30T02:44:11.760Z","comments":true,"path":"2023/10/23/N1CTF2023/","link":"","permalink":"https://sch01ar.github.io/2023/10/23/N1CTF2023/","excerpt":"","text":"周末和吉大东大的好哥哥们打了 n1，最后拿了 rank7，被 web👴 和 pwn👴 带飞 DJB 战队 wp:https://mp.weixin.qq.com/s/N03QtNsMvpux42xIAXxvrA e2W@rmup ECDSA 椭圆曲线签名，之前没用过ecdsa库，结果发现 d 就是私钥，拆分一下高低位，二元 coppersmith 梭一下，中间可能要补一位，补了 0 之后就可以了。 后面看师傅们博客还可以用格做，学到了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from Crypto.Util.number import *import itertoolsimport hashlibfrom Crypto.Cipher import AESdef small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []msg = b&#x27;welcome to n1ctf2023!&#x27;msg_hash = bytes_to_long(hashlib.sha256(msg).digest())s = 98064531907276862129345013436610988187051831712632166876574510656675679745081r = 9821122129422509893435671316433203251343263825232865092134497361752993786340p = 115792089210356248762697446949407573529996955224135760342422259061068512044369leak = int(&quot;10000111001100100010110100100000000100101000111011000001001011010100001010010000101001100011011010100000010010011011100010111001&quot;, 2)P.&lt;low,small&gt; = PolynomialRing(Zmod(p))f = r*((small*(2^128))+low)+msg_hash-(leak&lt;&lt;128)*s-small*sroots = small_roots(f, [2^129, 2^130], m=3, d=4)print(roots)low = 109657576978117277727118025094273115603high = 222660286808164019769040839717358598716d = bin(high)[2:]+&#x27;0&#x27;+bin(low)[2:]d = int(d, 2)print(d.bit_length())aes = AES.new(long_to_bytes(d), mode=AES.MODE_ECB)cipher = b&#x27;\\xf3#\\xff\\x17\\xdf\\xbb\\xc0\\xc6v\\x1bg\\xc7\\x8a6\\xf2\\xdf~\\x12\\xd8]\\xc5\\x02Ot\\x99\\x9f\\xf7\\xf3\\x98\\xbc\\x045\\x08\\xfb\\xce1@e\\xbcg[I\\xd1\\xbf\\xf8\\xea\\n-&#x27;flag = aes.decrypt(cipher)print(flag)# b&#x27;n1ctf&#123;Wow!__You_bre4k_my_s1gn_chal1enge!!___&#125;\\x03\\x03\\x03&#x27; e2d1p[赛后复现] 参考文章： https://tl2cents.github.io/2023/10/23/2023-N1CTF-Crypto-Writeups/ https://github.com/Nu1LCTF/n1ctf-2023/tree/main/crypto/e2D1p 题目 Based on N1CTF 2022 “ezdlp”. Easy dlp too, try again : ). 12345678910111213141516171819202122232425from Crypto.Util.number import *import osFLAG = os.environ.get(&#x27;FLAG&#x27;, b&#x27;n1ctf&#123;XXXXFAKE_FLAGXXXX&#125;&#x27;)assert FLAG[:6] == b&#x27;n1ctf&#123;&#x27; and FLAG[-1:] == b&#x27;&#125;&#x27;FLAG = FLAG[6:-1]def keygen(nbits): while True: q = getPrime(nbits) if isPrime(2*q+1): if pow(0x10001, q, 2*q+1) == 1: return 2*q+1def encrypt(key, message, mask): return pow(0x10001, message^mask, key)p = keygen(512)flag = bytes_to_long(FLAG)messages = [getRandomNBitInteger(flag.bit_length()) for i in range(200)]enc = [encrypt(p, message, flag) for message in messages]print(f&#x27;message = &#123;messages&#125;&#x27;)print(f&#x27;enc = &#123;enc&#125;&#x27;) 0x01 恢复模数 p 给了 200 组 m、c 满足等式\\(65537^{m_i⊕mask}=c_i (mod p)\\) 异或运算在指数上，没有什么运算性质。但异或的本质还是按位异或，以下用 m[i]表示 m 的第 i 位，对于一组 m 和 c 而言 \\[m\\oplus mask = mask+ \\sum\\limits_{j=0}\\limits^{158}(m[j]\\cdot2^i\\cdot(-1)^{s[i]})\\] 这样转换后即可把底数看作\\(c_i=65537^{mask}\\)，下一步的目的就是找到某个向量\\(e_i\\)使得\\(c_i^{e_i}≡0\\;mod\\;p\\)，这样即可恢复出模数\\(gcd(e_i,e_j)=p\\) 找到满足条件的\\(e_i\\)需要\\(m_i\\)，构造如下格： \\(m_{i,j}=m_{i,j}*2^{256}\\) \\[ \\begin{bmatrix} m_{0,0} &amp; m_{0,1} &amp; \\ldots &amp; m_{0,158} &amp; 1 &amp; 0 &amp; \\ldots &amp;0\\\\ m_{1,0} &amp; m_{1,1} &amp; \\ldots &amp; m_{1,158} &amp; 0 &amp; 1&amp; \\ldots &amp;0\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\ m_{199,0} &amp; m_{199,1} &amp; \\ldots &amp; m_{199,158} &amp; 0 &amp;0&amp; \\ldots &amp;1\\\\ \\end{bmatrix} \\] 利用LLL算法得到的\\(e_i\\)满足\\(\\sum\\limits_{i=1}\\limits^{200}e_i=0\\)，那么也就满足\\(\\sum\\limits_{i=1}\\limits^{200}e_i\\cdot m_i=\\vec{0}\\) 0x02 求解 mask x=mask \\[65537^{\\sum2^i\\cdot(x_i\\oplus m_i)}=c (mod \\;p)\\] 变换成如下形式 \\[(65537)^{\\sum\\limits_{\\{i|m_i=0\\}}2^i\\cdot x_i+\\sum\\limits_{\\{j|m_j=1\\}}2^j\\cdot(1-x_j)}=c\\;(mod \\;p)\\] \\[(65537)^{\\sum\\limits_{\\{i|m_i=0\\}}2^i\\cdot x_i+\\sum\\limits_{\\{j|m_j=1\\}}2^j\\cdot(-x_j)}=c\\cdot 65537^{-\\sum\\limits_{\\{j|m_j=1\\}}2^j} (mod \\;p)\\] 根据上式中\\(m_i\\)为 0 或 1 的情况构造对应\\(x_i\\)的系数矩阵\\(A\\)，系数只为 1 或-1 计算向量\\(u\\cdot A=(1,0,\\cdots,0)\\;(mod \\;q)\\)（模 q 是保证阶为素数，使得向量有解） 当\\(mask_i=0\\)时，便可按下式逐位恢复 mask \\[\\prod\\limits_{i=1}\\limits^{200}c_i^{u_i}=65537^0=1(mod\\;p)\\] \\[c_i=c_i\\cdot 65537^{-\\sum\\limits_{\\{j|m_j=1\\}}2^j}(mod\\;p)\\] exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from tqdm import tqdmfrom Crypto.Util.number import *from ast import literal_evalfrom Crypto.Util.number import *lines = open(&quot;./output.txt&quot;, &quot;r&quot;).readlines()message = literal_eval(lines[0].strip())enc = literal_eval(lines[1].strip())m_l = 159dim = 200L = matrix(ZZ, dim, dim+m_l+1)g = 2 ^ 512for i in range(dim): L[i, i] = 1 L[i, dim+m_l] = gfor i in range(dim): line = bin(message[i])[2:].rjust(m_l, &#x27;0&#x27;) for j in range(len(line)): if int(line[j]): L[i, dim+j] = g else: L[i, dim+j] = 0basis = L.LLL()[:40]p = []for item in basis: g1 = 1 g2 = 1 vec = item[:dim] for i in range(len(vec)): if vec[i] &gt;= 0: g1 *= pow(enc[i], vec[i]) else: g2 *= pow(enc[i], -vec[i]) p.append(g1-g2)p = list(factor(reduce(GCD, p)))[-1][0]q = (p-1)//2A = matrix(Zmod(q), dim, m_l)for i in range(dim): line = bin(message[i])[2:].rjust(m_l, &#x27;0&#x27;) for j in range(len(line)): if int(line[j]): A[i, j] = -1 enc[i] = enc[i]*inverse_mod(pow(0x10001, 2 ^ (m_l-1-j), p), p) % p else: A[i, j] = 1m = &#x27;&#x27;for _ in tqdm(range(m_l)): v = vector(Zmod(q), [0]*_+[1]+[0]*(m_l-1-_)) u = A.solve_left(v) sign = 1 for i in range(len(u)): if u[i] &gt;= 0: sign = sign*pow(enc[i], int(u[i]), p) % p else: sign = sign*inverse_mod(pow(enc[i], -int(u[i]), p), p) % p if sign != 1: m += &#x27;1&#x27; else: m += &#x27;0&#x27;print(bytes.fromhex(hex(int(m, 2))[2:]))","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"LCG","slug":"LCG","date":"2023-06-19T03:05:45.000Z","updated":"2023-10-24T02:36:43.275Z","comments":true,"path":"2023/06/19/LCG/","link":"","permalink":"https://sch01ar.github.io/2023/06/19/LCG/","excerpt":"","text":"LCG 线性同余（LCG）是产生伪随机数的方法。 基本形式： \\[ X_{n+1}=(aX_n+b)\\;mod\\;m \\] 基本公式 公式一 求递归数组元素 \\[X_n=a^{-1}(X_{n+1}-b)\\;mod\\;m\\] 公式二 求参数 a 利用两个递归式消去 b 得到 a \\[a=(X_{n+2}-X_{n+1})(X_{n+1}-X_n)^{-1}\\] 公式三 求参数 b \\[b=(X_{n+1}-aX_{n})\\;mod\\;m\\] 公式四 求参数 m \\[t_n=X_{n+1}-X_n\\] \\[t_n=(aX_n+b)-(aX_{n-1}+b)\\;mod\\;m\\] \\[t_{n+1}t_{n-1}-t_nt_n=0\\;mod\\;m\\] \\[T_n=t_{n+1}t_{n-1}-t_nt_n是 m 的倍数\\] \\[m=gcd(T_n,T_{n-1})\\] 相关求解代码 123456789101112131415161718192021222324252627282930313233from Crypto.Util.number import *from functools import *def crack_unknown_increment(states, modulus, multiplier): # 求增量 increment = (states[1] - states[0]*multiplier) % modulus return modulus, multiplier, incrementdef crack_unknown_multiplier(states, modulus): # 求乘数 multiplier = (states[2] - states[1]) * \\ inverse(states[1] - states[0], modulus) % modulus return crack_unknown_increment(states, modulus, multiplier)def crack_unknown_modulus(states): # 求模数 diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(GCD, zeroes)) return crack_unknown_multiplier(states, modulus)print(crack_unknown_modulus([2818206783446335158, 3026581076925130250, 136214319011561377, 359019108775045580, 2386075359657550866, 1705259547463444505]))","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"D^3CTF","slug":"d3ctf2023","date":"2023-05-07T06:05:45.000Z","updated":"2023-05-10T12:22:25.734Z","comments":true,"path":"2023/05/07/d3ctf2023/","link":"","permalink":"https://sch01ar.github.io/2023/05/07/d3ctf2023/","excerpt":"","text":"d3noisy 1234567891011121314151617181920212223242526272829303132333435from Crypto.Util.number import *import gmpy2with open(&#x27;out.txt&#x27;) as f: n=int(f.readline()[4:]) p=eval(f.readline()[4:]) s=eval(f.readline()[4:]) c=eval(f.readline()[4:])P0=1L=[]for i in p: P0=P0*iprint(P0)for i in range(15): t=inverse(P0//p[i],p[i]) L.append(t*(P0//p[i]))B=getPrime(3211)M=matrix(ZZ,15*15+1,15*15+1)for i in range(15): for j in range(15): t=i*15+j M[t+1,t+1]=B M[t+1,0]=s[i][j]*L[i]M[0,0]=P0x=M.LLL()print(&quot;LLL done&quot;)d=0for i in range(15): d =(d ^^ int(x[i][0]))d = gmpy2.next_prime(int(d))print(d)print(long_to_bytes(pow(c,d,n)))# antd3ctf&#123;0c85f77e-bfee-da57-78f2-e961ffd4ca45&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"RSA(持续更新🫡)","slug":"RSA","date":"2023-04-20T13:05:45.000Z","updated":"2023-11-03T02:27:06.700Z","comments":true,"path":"2023/04/20/RSA/","link":"","permalink":"https://sch01ar.github.io/2023/04/20/RSA/","excerpt":"","text":"基本原理 RSA 中加、解密： 加密\\(c = m^e\\quad mod\\quad n\\) 解密\\(m = c^d\\quad mod\\quad n\\) 接下来证明一下解密过程，先引入欧拉定理。 欧拉定理 对于互为质数的 m、n 两个数，有\\(m^{\\phi(n)} = 1\\quad mod\\quad n\\)，其中\\(\\phi(n)\\)表示小于 n 的质数的个数。 解密原理 通过\\(c = m^e\\quad mod\\quad n\\)与欧拉定理\\(m^{\\phi(n)} = 1\\quad mod\\quad n\\)，我们便可进行推导。 对欧拉定理进行变形，得到\\(m^{k\\phi(n)+1} = m\\quad mod\\quad n\\) 因为我们已经知道\\(c = m^e\\quad mod\\quad n\\)，所以寻找一个 d，使得\\(ed = k\\phi(n)+1\\),则可以得到\\(m^{ed}=m\\quad mod \\quad n\\) 则得到了\\(c^d =m\\quad mod\\quad n\\) 共模攻击 所谓共模，就是 n 相同，会对应多组 c，e。 例：给定 n、c1、c2、e1、e2 m = c1e1 mod n m = c2e2 mod n 扩展欧几里得算法 给定两个整数 a、b，必定存在 x、y，使得 gcd(a,b)=ax+by 运用该算法推导过程 m = m % n m = ms1e1+s2e2 % n m = (me1s1 * me2s2)% n m = (me1s1 % n) * (me2s2 % n) % n m = (c1s1 % n) * (c2s2 % n) % n EXP 123456789101112import gmpy2from Crypto.Util.number import long_to_bytesc1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801e1=11187289c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397e2=9647291r,s1,s2=gmpy2.gcdext(e1,e2)m=(pow(c1,s1,n) * pow(c2,s2,n)) %nprint(long_to_bytes(m))#flag&#123;49d91077a1abcb14f1a9d546c80be9ef&#125; Wiener's Attack 适用于已知 N、e，且 e 过大或过小。 Wiener 表示如果\\(d&lt;\\frac{1}{3}n^{\\frac{1}{4}}\\),那么一种基于连分数的攻击就可危及 RSA 安全。 那么什么是连分数以及如何利用呢？ 连分数 当 \\(a_0, a_1, a_2, \\dots, a_n\\) 都是正整数时，一个连分数可以表示为： \\[x\\;=\\;a_0 + \\cfrac{1}{a_1 + \\cfrac{1}{a_2 + \\cfrac{1}{\\ddots + \\cfrac{1}{a_n}}}}\\] 例如我们可以求解\\(\\pi\\)的近似值 \\[\\pi = 3 + \\cfrac{1}{7 + \\cfrac{1^2}{15 + \\cfrac{2^2}{1 + \\cfrac{3^2}{1 + \\cfrac{4^2}{2 + \\cdots}}}}}\\] 其中每一项可以用如下公式计算： \\[ a_k = \\begin{cases} a_0, &amp; k=0 \\\\ \\lfloor b_k \\rfloor, &amp; k &gt; 0 \\end{cases}\\\\ \\] \\[ b_k = \\begin{cases} a_0, &amp; k=0 \\\\ \\dfrac{1}{b_{k-1} - \\lfloor b_{k-1} \\rfloor}, &amp; k &gt; 0 \\end{cases} \\] 在这个例子中，\\(a_0 = 3\\)，并且按照上述公式递归计算 \\(a_k\\) 和 \\(b_k\\) 直到达到一定精度为止，就可以得到一个近似值 \\(\\pi \\approx 3.14159265\\)。 至此也就明白了连分数的作用，常用于无理数的逼近。 当然，也可以逼近一个任意数，得到最接近精确值的近似值。 Legendre's theorem \\[\\left | \\frac{e}{N}-\\frac{k}{d} \\right |\\leq \\frac{1}{2d^2}\\] 当满足这一点时，\\(\\frac{k}{d}\\)就是\\(\\frac{e}{N}\\)的连分数收敛。 攻击 RSA 原理 \\[\\phi(n)=(p-1)(q-1)\\] \\[\\because p,q很大,\\therefore \\phi(n) \\approx N\\] \\[ed - 1=k\\phi(n)\\] 同除 \\(d\\phi(n)\\) 得 \\[\\frac{e}{\\phi(n)}-\\frac{k}{d}=\\frac{1}{d\\phi(n)}\\] \\[\\therefore \\frac{e}{N}-\\frac{k}{d}=\\frac{1}{d\\phi(n)}\\] 到这里发现，等式右边的\\(\\frac{1}{d\\phi(n)}\\)很小，因此\\(\\frac{k}{d}\\)就是一个对于已知量\\(\\frac{e}{N}\\)的一个连分数逼近。 因此可以通过将\\(\\frac{e}{N}\\)的连分数展开，依次计算每一个渐进分数。Wiener 证明了可以精准覆盖\\(\\frac{k}{d}\\)。 exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import gmpy2def transform(x,y): #使用辗转相处将分数 x/y 转为连分数的形式 res=[] while y: res.append(x//y) x,y=y,x%y return resdef continued_fraction(sub_res): numerator,denominator=1,0 for i in sub_res[::-1]: #从sublist的后面往前循环 denominator,numerator=numerator,i*numerator+denominator return denominator,numerator #得到渐进分数的分母和分子，并返回#求解每个渐进分数def sub_fraction(x,y): res=transform(x,y) res=list(map(continued_fraction,(res[0:i] for i in range(1,len(res))))) #将连分数的结果逐一截取以求渐进分数 return resdef get_pq(a,b,c): #由p+q和pq的值通过维达定理来求解p和q par=gmpy2.isqrt(b*b-4*a*c) #由上述可得，开根号一定是整数，因为有解 x1,x2=(-b+par)//(2*a),(-b-par)//(2*a) return x1,x2def wienerAttack(e,n): for (d,k) in sub_fraction(e,n): #用一个for循环来注意试探e/n的连续函数的渐进分数，直到找到一个满足条件的渐进分数 if k==0: #可能会出现连分数的第一个为0的情况，排除 continue if (e*d-1)%k!=0: #ed=1 (mod φ(n)) 因此如果找到了d的话，(ed-1)会整除φ(n),也就是存在k使得(e*d-1)//k=φ(n) continue phi=(e*d-1)//k #这个结果就是 φ(n) px,qy=get_pq(1,n-phi+1,n) if px*qy==n: p,q=abs(int(px)),abs(int(qy)) #可能会得到两个负数，负负得正未尝不会出现 d=gmpy2.invert(e,(p-1)*(q-1)) #求ed=1 (mod φ(n))的结果，也就是e关于 φ(n)的乘法逆元d return d print(&quot;该方法不适用&quot;)e = 14058695417015334071588010346586749790539913287499707802938898719199384604316115908373997739604466972535533733290829894940306314501336291780396644520926473n = 33608051123287760315508423639768587307044110783252538766412788814888567164438282747809126528707329215122915093543085008547092423658991866313471837522758159d=wienerAttack(e,n)print(&quot;d=&quot;,d) Extending Wiener's Attack 扩展维纳攻击是为了扩展到\\(n\\)个加密指数\\(e_i\\),且\\(d_i\\)都较小的情况。 由\\(e*d-k*\\lambda(N)=1\\)得 \\[d_ige_i-k_iN=g+k_is\\] 记为维纳等式\\(W_i\\)。 利用 Guo 的方法可得到关系式: \\[k_id_je_j-k_jd_ie_i=k_i-k_j\\] 记为郭等式\\(G_{i,j}\\)。注意到两种等式的右侧都非常小。 参考论文和 wiki 中的做法，后续的思路是使用这两个式子的不同关系去构造格，进而格基约化求得\\(\\phi(N)\\)来实现\\(N\\)的分解。 两个小解密指数 三个小解密指数 低加密指数攻击 e=3 123456789101112131415161718import gmpy2from Crypto.Util.number import *def dec(c, e, n): k = 0 while True: mm = c + n*k result, flag = gmpy2.iroot(mm, e) if True == flag: return result k += 1n= 14067473525623615859223663589118945198091192669401088734569589535726733244095067264729942915265175903139441309376381225701454902095234966599914234681888481774607095853830772571665038109641511499155604914228117882196188074964226780922239011682486198651997912713999544628177959592818928976240251790858062449396082494272361535640237914373270152455829541596341184902017633404494979208958080467979235974182507427501682492000572071306960595992848840147393057648929439822116261337091431441205378542080755128597543738922210525692259529009107645032171097155449558362749512243918901171631681472217935131865121871798425854707759e= 3c= 2217344750798294937344050117513831761010547351781457575945714176628679412650463329423466955026804439931765627111856888102133234836914006818023839994342283023142702993182665344445325734299047409223354338948863171846780674244925724334091153701697864918695050507247415283070309m=dec(c,e,n)print(long_to_bytes(m)) 低加密指数广播攻击 特点是 e 小，有多组 n，对应了多组 c me = c1 mod n1 me = c2 mod n2 me = c3 mod n3 中国剩余定理(CRT) 定理内容如下 针对上述方程组，若 n1、n2、n3 互质，对于任意的 c1、c2、c3，方程组都有解 m。 使用条件是 m^e &lt; n1、n2、n3。通解推导如下： 设\\(N=n_1 \\times n_2 \\times n_3, N_1=N/n_1, N_2=N/n_2, N_3=N/n_3\\) 设\\(t_i=N_i^{-1}\\),这里表示\\(t_i\\)是\\(N_i\\)在模\\(n_i\\)的逆元。 有了以上几个数，我们可以给出通解形式： \\[m=c_1t_1N_1+c_2t_2N_2+c_3t_3N_3+kN=kN+\\sum_{i=1}^3c_it_iN_i\\] 在模 N 后，只剩唯一解\\(m=\\sum_{i=1}^3c_it_iN_i\\) EXP 123456789101112131415161718192021222324252627import gmpy2from sympy.ntheory.modular import crtfrom Crypto.Util.number import long_to_bytese = 3n1 = &#x27;331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004&#x27;c1 = &#x27;310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243&#x27;n2 = &#x27;302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114&#x27;c2 = &#x27;112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344&#x27;n3 = &#x27;332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323&#x27;c3 = &#x27;10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242&#x27;c1=int(c1,5)n1=int(n1,5)c2=int(c2,5)n2=int(n2,5)c3=int(c3,5)n3=int(n3,5)e=3n=[n1,n2,n3]c=[c1,c2,c3]resultant,mod= crt(n, c)# 有现成的库函数可以调用print(gmpy2.iroot(resultant, e))m=259362307225540148883586283191025214233097658309244310540770399135748418469298031742173624766441014006294782333print(long_to_bytes(m))#noxCTF&#123;D4mn_y0u_h4s74d_wh47_4_b100dy_b4s74rd!&#125; dp、dq 相关 给定 dp、dq 类型 dp ≡ d mod (p-1) dq ≡ d mod (q-1) m ≡ cd mod n m = cd + k * n m = cd +k _ p _ q 对上式两端同时对 p、q 分别取余，得：（中国剩余定理） m1 ≡ cd mod p m2 ≡ cd mod q 同理，可得到 cd = m1 +k * p 代入到 m2 ≡ cd mod q 中： m2 ≡ (m1 + k * p)mod q ，两端减去 m1 得 m2 - m1 ≡ k * p mod q ，两端乘 p 的逆元得 (m2 - m1)p-1 ≡ k mod q 将 k 代入到 cd = m1 +k * p 中得： cd = m1 + ((m2 - m1)p-1 mod q) * p m=cd mod n 得到 m ≡ (((m2 - m1) _ p-1 mod q) _ p + m1) mod n 接下来就是求解 m1，m2 m1 ≡ cdp+k(p-1) mod p m2 ≡ cdq+k(q-1) mod q 根据费马小定理 若 p 是素数，则 a(p-1) ≡ 1 mod p 因此 m1 ≡ cdp mod p，m2 ≡ cdq mod q 最终可求得 m EXP 1234567891011121314import gmpy2from Crypto.Util.number import long_to_bytesp = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852m1=pow(c,dp,p)m2=pow(c,dq,q)n=p*qp0=gmpy2.invert(p,q)m=(((m2-m1)*p0 % q)* p +m1)%nprint(long_to_bytes(m))#noxCTF&#123;W31c0m3_70_Ch1n470wn&#125; 只给定 dp dp ≡ d mod (p-1) ed ≡ 1 mod (p-1) * (q-1) ed = 1 + k2(p-1)(q-1) 对 1 式两端同乘 e，得 e * dp ≡ ed mod (p-1) e * dp = k1(p-1) + ed 代入 ed 得 e * dp = k1(p-1) + 1 + k2(p-1)(q-1) 由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余 p-1，即可消掉 n e * dp ≡ 1 mod (p-1) e * dp =k(p-1) + 1 得到这个式子后，其实真正意义上的未知数只有我们要求的 p，但是还存在一个 k。 针对 k，我们判断一下他的范围，看看能否采用爆破的方式。 k = (e * dp - 1)/(p-1) 因为 dp &lt; p-1 所以 k &lt; e 通过遍历 k 然后找到(e * dp - 1)可以整除 k 的情况即可。 (跑了一下发现限制条件还不够) 因此再加一个 n 能否整除 p 即可。 EXP 1234567891011121314151617181920import gmpy2from Crypto.Util.number import long_to_bytese = 65537n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751# p = 13468634736343473907717969603434376212206335187555458742257940406618189481177835992217885676243155145465521141546915941147336786447889325606555333350540003# q = 18432009829596386103558375461387837845170621179295293289126504231317130550979989727125205467379713835047300158256398009229511746203459540859429194971855371for k in range(1,e): if (e*dp-1)%k == 0: p=(e*dp-1)//k + 1 if n%p == 0: print(p) breakq=n//pphi= (p-1)*(q-1)d= gmpy2.invert(e,phi)m=pow(c,d,n)print(long_to_bytes(m))#flag&#123;wow_leaking_dp_breaks_rsa?_98924743502&#125; DLP magic(hitcon2021) 1234567891011121314151617181920212223242526import osfrom Crypto.Util.number import *from hashlib import *magic=b&#x27;e0204eeaf14d72ab90e1f7ac69559dd182&#x27;LEN = 17magic = os.urandom(LEN)print(&quot;Magic:&quot;, magic.hex())print(&#x27;Coud you use it to do encryption as hash?&#x27;)magic_num = bytes_to_long(magic)try: N = int(input(&#x27;N:&gt;&#x27;)) e = int(input(&#x27;E:&gt;&#x27;)) data = long_to_bytes(int(input(&#x27;data:&gt;&#x27;), 16)) if N &gt;&gt; (248) == magic_num: data2 = sha384(data).digest() num1 = bytes_to_long(data) num2 = bytes_to_long(data2) if pow(num1, e, N) == num2: print(os.getenv(&#x27;FLAG&#x27;)) else: print(&#x27;try harder!!!&#x27;) else: print(&#x27;try harder!&#x27;)except Exception as e: print(&#x27;invalid&#x27;) EXP rabin 适用于 RSA 中 e=2 的情况 pqpq(seccon2022) 12345678910111213141516171819202122232425262728293031323334353637from Crypto.Util.number import *from Crypto.Random import *from flag import flagp = getPrime(512)q = getPrime(512)r = getPrime(512)n = p * q * re = 2 * 65537assert n.bit_length() // 8 - len(flag) &gt; 0padding = get_random_bytes(n.bit_length() // 8 - len(flag))m = bytes_to_long(padding + flag)assert m &lt; nc1p = pow(p, e, n)c1q = pow(q, e, n)cm = pow(m, e, n)c1 = (c1p - c1q) % nc2 = pow(p - q, e, n)print(f&quot;e = &#123;e&#125;&quot;)print(f&quot;n = &#123;n&#125;&quot;)# p^e - q^e mod nprint(f&quot;c1 = &#123;c1&#125;&quot;)# (p-q)^e mod nprint(f&quot;c2 = &#123;c2&#125;&quot;)# m^e mod nprint(f&quot;cm = &#123;cm&#125;&quot;)# e = 131074# n = 587926815910957928506680558951380405698765957736660571041732511939308424899531125274073420353104933723578377320050609109973567093301465914201779673281463229043539776071848986139657349676692718889679333084650490543298408820393827884588301690661795023628407437321580294262453190086595632660415087049509707898690300735866307908684649384093580089579066927072306239235691848372795522705863097316041992762430583002647242874432616919707048872023450089003861892443175057# c1 = 92883677608593259107779614675340187389627152895287502713709168556367680044547229499881430201334665342299031232736527233576918819872441595012586353493994687554993850861284698771856524058389658082754805340430113793873484033099148690745409478343585721548477862484321261504696340989152768048722100452380071775092776100545951118812510485258151625980480449364841902275382168289834835592610827304151460005023283820809211181376463308232832041617730995269229706500778999# c2 = 46236476834113109832988500718245623668321130659753618396968458085371710919173095425312826538494027621684566936459628333712619089451210986870323342712049966508077935506288610960911880157875515961210931283604254773154117519276154872411593688579702575956948337592659599321668773003355325067112181265438366718228446448254354388848428310614023369655106639341893255469632846938342940907002778575355566044700049191772800859575284398246115317686284789740336401764665472# cm = 357982930129036534232652210898740711702843117900101310390536835935714799577440705618646343456679847613022604725158389766496649223820165598357113877892553200702943562674928769780834623569501835458020870291541041964954580145140283927441757571859062193670500697241155641475887438532923910772758985332976303801843564388289302751743334888885607686066607804176327367188812325636165858751339661015759861175537925741744142766298156196248822715533235458083173713289585866 大致思路 根据题目，可先通过计算 c1、c2 表达式，合并找出公因子，即可求出 p、q，从而 r 也可求得。 发现 e=65537 * 2，因此是无逆元存在的，索性就将 e 拆分为 65537 与 2，e2=2 时便可通过 Rabin 算法解密。 求 p、q、r \\(c2 = (p - q)^e \\mod n \\\\\\) 左右同乘 r \\(c2 * r = rp^e + rq^e + X*pqr = rp^e + rq^e \\mod n\\\\\\) \\(c2 = p^e + q^e \\mod n\\\\\\) 同理得到\\(c1 = p^e - q^e \\mod n \\\\\\) 从而求得 p、q \\(p=gcd(c1+c2,n)\\\\\\) \\(q=gcd(c1-c2,n)\\\\\\) 求解 m^2 \\(\\phi(n)=(p-1)*(q-1)*(r-1)\\\\\\) 通过 e1(e/2)和\\(\\phi(n)\\)求出 d，得到\\(cm^d=m^{2*e1*d}=m^2 \\mod n\\) Rabin 解密 接下来就是传统 Rabin 解密，找了两种脚本，exp 中的sqrtPrime(n,p)和Tonelli_Shanks(n,p)任选其一即可，都是基于二次剩余定理所实现的解密算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import gmpy2from Crypto.Util.number import *import randomfrom itertools import productdef sqrtPrime(n, p): q = p - 1 m = 0 while q &amp; 1 == 0: q &gt;&gt;= 1 m += 1 z = 1 while pow(z, (p - 1) &gt;&gt; 1, p) == 1: z = random.randint(1, p - 1) c = pow(z, q, p) t = pow(n, q, p) r = pow(n, (q + 1) &gt;&gt; 1, p) if t == 0: return 0 m -= 2 while t != 1: while pow(t, 2**m, p) == 1: c = c * c % p m -= 1 r = r * c % p c = c * c % p t = t * c % p m -= 1 return rdef Legendre(n,p): # 这里用勒让德符号来表示判断二次（非）剩余的过程 return pow(n,(p - 1) // 2,p)def Tonelli_Shanks(n,p): assert Legendre(n,p) == 1 if p % 4 == 3: print(&quot;1&quot;) return pow(n,(p + 1) // 4,p) q = p - 1 s = 0 while q % 2 == 0: q = q // 2 s += 1 for z in range(2,p): if Legendre(z,p) == p - 1: c = pow(z,q,p) break r = pow(n,(q + 1) // 2,p) t = pow(n,q,p) m = s if t % p == 1: return r else: i = 0 while t % p != 1: # 外层循环的判断条件 temp = pow(t,2**(i+1),p) # 这里写作i+1是为了确保之后内层循环用到i值是与这里的i+1的值是相等的 i += 1 if temp % p == 1: # 内层循环的判断条件 b = pow(c,2**(m - i - 1),p) r = r * b % p c = b * b % p t = t * c % p m = i i = 0 # 注意每次内层循环结束后i值要更新为0 return re = 131074e = 65537*2n = 587926815910957928506680558951380405698765957736660571041732511939308424899531125274073420353104933723578377320050609109973567093301465914201779673281463229043539776071848986139657349676692718889679333084650490543298408820393827884588301690661795023628407437321580294262453190086595632660415087049509707898690300735866307908684649384093580089579066927072306239235691848372795522705863097316041992762430583002647242874432616919707048872023450089003861892443175057c1 = 92883677608593259107779614675340187389627152895287502713709168556367680044547229499881430201334665342299031232736527233576918819872441595012586353493994687554993850861284698771856524058389658082754805340430113793873484033099148690745409478343585721548477862484321261504696340989152768048722100452380071775092776100545951118812510485258151625980480449364841902275382168289834835592610827304151460005023283820809211181376463308232832041617730995269229706500778999c2 = 46236476834113109832988500718245623668321130659753618396968458085371710919173095425312826538494027621684566936459628333712619089451210986870323342712049966508077935506288610960911880157875515961210931283604254773154117519276154872411593688579702575956948337592659599321668773003355325067112181265438366718228446448254354388848428310614023369655106639341893255469632846938342940907002778575355566044700049191772800859575284398246115317686284789740336401764665472cm = 357982930129036534232652210898740711702843117900101310390536835935714799577440705618646343456679847613022604725158389766496649223820165598357113877892553200702943562674928769780834623569501835458020870291541041964954580145140283927441757571859062193670500697241155641475887438532923910772758985332976303801843564388289302751743334888885607686066607804176327367188812325636165858751339661015759861175537925741744142766298156196248822715533235458083173713289585866p = GCD(c1+c2,n)q = GCD(c1-c2,n)r = n//(p*q)phi=(p-1)*(q-1)*(r-1)d0=gmpy2.invert(65537,phi)m2=pow(cm,d0,n)cp=m2%pcq=m2%qcr=m2%rmp=sqrtPrime(cp,p)mq=sqrtPrime(cq,q)mr=sqrtPrime(cr,r)mp=Tonelli_Shanks(cp,p)mq=Tonelli_Shanks(cq,q)mr=Tonelli_Shanks(cr,r)for mp1,mq1,mr1 in product([mp,p-mp],[mq,q-mq],[mr,r-mr]): x=[mp1,mq1,mr1] y=[p,q,r] print(long_to_bytes(crt(y,x)[0]))#SECCON&#123;being_able_to_s0lve_this_1s_great!&#125; e 与 phi 不互素 GCD(p-1,e)!=1 GCD(q-1,e)!=1 1234567891011121314151617181920212223242526272829303132333435363738394041424344import libnumfrom Crypto.Util.number import *import itertoolsn = 3326716005321175474866311915397401254111950808705576293932345690533263108414883877530294339294274914837424580618375346509555627578734883357652996005817766370804842161603027636393776079113035745495508839749006773483720698066943577445977551268093247748313691392265332970992500440422951173889419377779135952537088733c = 2709336316075650177079376244796188132561250459751152184677022745551914544884517324887652368450635995644019212878543745475885906864265559139379903049221765159852922264140740839538366147411533242116915892792672736321879694956051586399594206293685750573633107354109784921229088063124404073840557026747056910514218246p = 11104262127139631006017377403513327506789883414594983803879501935187577746510780983414313264114974863256190649020310407750155332724309172387489473534782137699q=n//pe=196608enc=cN=p*qdef get_oneroot(p, e): while True: Zp = Zmod(p) g = Zp.random_element() g = g^((p-1) // e) for mult in divisors(e): if (mult != e): g2 = g^mult if (g2 == 1): break else: return gdef decrypt(p, c, e): w = gcd(e, p-1) e1, p1 = e // w, (p-1) // w d = inverse_mod(e1, p1) c1 = pow(c, d, p) g, a, b = xgcd(p1, w) g = get_oneroot(p, w) m = pow(c1, b, p) return [ZZ(m * g^i) for i in range(w)]mp_list = decrypt(p, enc, e)print(&#x27;Find root p OK&#x27;)mq_list = decrypt(q, enc, e)print(&#x27;Find root q OK&#x27;)for mp, mq in itertools.product(mp_list, mq_list): m = crt([mp, mq], [p, q]) msg = long_to_bytes(int(m)) if (b&#x27;flag&#x27; in msg): print(msg) m^GCD &lt; n 求出\\(d*t\\)后，对\\(m\\)开\\(t\\)次方根。 12345678910111213141516171819202122232425import gmpy2from Crypto.Util.number import *import randomflag=b&#x27;flag&#123;dsajhkdhsajkdh&#125;&#x27;m=bytes_to_long(flag)while 1: e = random.getrandbits(128) p=getPrime(1024) q=getPrime(1024) n=p*q phi_n=(p-1)*(q-1) t=gmpy2.gcd(e,phi_n) if gmpy2.invert(e // t, phi_n) and t!=1 and m^t &lt; n: breakc=pow(m,e,n)# decryptphi=(p-1)*(q-1)t=GCD(e,phi)n=p*qd=gmpy2.invert(e//t,phi)m0=pow(c,d,n)m=gmpy2.iroot(m0,t)print(long_to_bytes(m[0])) m^GCD &gt; n \\[t=GCD(e,phi)\\] \\[d=inverse(e//t,phi)\\] \\[c=pow(c,d,n)\\] 使用 CRT 进行有限域开根 \\[x^t\\;=c\\;mod\\;p\\] \\[x^t\\;=c\\;mod\\;q\\] 12345678910111213141516171819def decrypt(p, q, e, c): R.&lt; x &gt; = Zmod(p)[] f = x ^ e - c f = f.monic() res1 = f.roots() R.&lt; x &gt; = Zmod(q)[] f = x ^ e - c f = f.monic() res2 = f.roots() for i in res1: for j in res2: m = CRT(int(i[0]), int(j[0]), p, q) flag = long_to_bytes(m) if b&#x27;flag&#x27; in flag: print(flag) print(bytes_to_long(flag)) AMM 适用于\\(e\\)可整除\\(\\phi\\)的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#Sageimport randomimport timefrom Crypto.Util.number import *# About 3 seconds to rundef AMM(o, r, q): start = time.time() print(&#x27;\\n----------------------------------------------------------------------------------&#x27;) print(&#x27;Start to run Adleman-Manders-Miller Root Extraction Method&#x27;) print(&#x27;Try to find one &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;&#x27;.format(r, o, q)) g = GF(q) o = g(o) p = g(random.randint(1, q)) while p ^ ((q-1) // r) == 1: p = g(random.randint(1, q)) print(&#x27;[+] Find p:&#123;&#125;&#x27;.format(p)) t = 0 s = q - 1 while s % r == 0: t += 1 s = s // r print(&#x27;[+] Find s:&#123;&#125;, t:&#123;&#125;&#x27;.format(s, t)) k = 1 while (k * s + 1) % r != 0: k += 1 alp = (k * s + 1) // r print(&#x27;[+] Find alp:&#123;&#125;&#x27;.format(alp)) a = p ^ (r**(t-1) * s) b = o ^ (r*alp - 1) c = p ^ s h = 1 for i in range(1, t): d = b ^ (r^(t-1-i)) if d == 1: j = 0 else: print(&#x27;[+] Calculating DLP...&#x27;) j = - discrete_log(a, d) print(&#x27;[+] Finish DLP...&#x27;) b = b * (c^r)^j h = h * c^j c = c ^ r result = o^alp * h end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) print(&#x27;Find one solution: &#123;&#125;&#x27;.format(result)) return resultdef findAllPRoot(p, e): print(&quot;Start to find all the Primitive &#123;:#x&#125;th root of 1 modulo &#123;&#125;.&quot;.format(e, p)) start = time.time() proot = set() while len(proot) &lt; e: proot.add(pow(random.randint(2, p-1), (p-1)//e, p)) end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) return prootdef findAllSolutions(mp, proot, cp, p): print(&quot;Start to find all the &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;.&quot;.format(e, cp, p)) start = time.time() all_mp = set() for root in proot: mp2 = mp * root % p assert(pow(mp2, e, p) == cp) all_mp.add(mp2) end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) return all_mpe = 0x1337p = 199138677823743837339927520157607820029746574557746549094921488292877226509198315016018919385259781238148402833316033634968163276198999279327827901879426429664674358844084491830543271625147280950273934405879341438429171453002453838897458102128836690385604150324972907981960626767679153125735677417397078196059q = 112213695905472142415221444515326532320352429478341683352811183503269676555434601229013679319423878238944956830244386653674413411658696751173844443394608246716053086226910581400528167848306119179879115809778793093611381764939789057524575349501163689452810148280625226541609383166347879832134495444706697124741n = p * qc=10562302690541901187975815594605242014385201583329309191736952454310803387032252007244962585846519762051885640856082157060593829013572592812958261432327975138581784360302599265408134332094134880789013207382277849503344042487389850373487656200657856862096900860792273206447552132458430989534820256156021128891296387414689693952047302604774923411425863612316726417214819110981605912408620996068520823370069362751149060142640529571400977787330956486849449005402750224992048562898004309319577192693315658275912449198365737965570035264841782399978307388920681068646219895287752359564029778568376881425070363592696751183359cp = c % pcq = c % qmp = AMM(cp, e, p)mq = AMM(cq, e, q)p_proot = findAllPRoot(p, e)q_proot = findAllPRoot(q, e)mps = findAllSolutions(mp, p_proot, cp, p)mqs = findAllSolutions(mq, q_proot, cq, q)print(mps, mqs)def check(m): h = m.hex() if len(h) &amp; 1: return False if bytes.fromhex(h).startswith(b&#x27;flag&#x27;): print(bytes.fromhex(h)) return True else: return False# About 16 mins to run 0x1337^2 == 24196561 times CRTstart = time.time()print(&#x27;Start CRT...&#x27;)for mpp in mps: for mqq in mqs: solution = CRT_list([int(mpp), int(mqq)], [p, q]) if check(solution): print(solution) print(time.time() - start)end = time.time()print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) 已知 p^q 和 p*q 1234567891011121314151617181920212223242526def get_pq(n, x): a = [0] b = [0] maskx = 1 maskn = 2 for i in range(1024): xbit = (x &amp; maskx) &gt;&gt; i nbit = n % maskn t_a = [] t_b = [] for j in range(len(a)): for aa in range(2): for bb in range(2): if aa ^ bb == xbit: tmp2 = n % maskn tmp1 = (aa * maskn // 2 + a[j]) * (bb * maskn // 2 + b[j]) % maskn if tmp1 == tmp2: t_a.append(aa * maskn // 2 + a[j]) t_b.append(bb * maskn // 2 + b[j]) maskx *= 2 maskn *= 2 a = t_a b = t_b for a1, b1 in zip(a, b): if a1 * b1 == n1: return a1, b1 明文相关攻击 123assert flag == b&quot;dasctf&#123;&quot; + secret + b&quot;&#125;&quot;print(rsaencrypt(bytes_to_long(secret)))print(rsaencrypt(bytes_to_long(flag))) 适用于 $$ C_1=M^e ; mod; n \\ C_2=(aM+b)^e ; mod ; n $$ 1234567891011121314151617181920def related_message_attack(c1, c2, diff, e, n): PRx.&lt;x&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x*256+diff)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]for i in range(5,200): sl = i*8 diff = bytes_to_long(b&quot;dasctf&#123;&quot;)*2^(sl+8) + bytes_to_long(b&quot;&#125;&quot;) #print(long_to_bytes(diff)) v = related_message_attack(C1, C2, diff, e, n) v = long_to_bytes(int(v)) if all(0x20&lt;=k&lt;=0x7f for k in v): print(v)","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"ECC(持续更新🥱)","slug":"ECC","date":"2023-04-19T06:05:45.000Z","updated":"2023-05-01T14:49:32.679Z","comments":true,"path":"2023/04/19/ECC/","link":"","permalink":"https://sch01ar.github.io/2023/04/19/ECC/","excerpt":"","text":"ECC 椭圆曲线密码学(Elliptic Curve Cryptography)，是一种基于椭圆曲线数学的公钥密码。 基于 ECC 的三大问题：密钥交换、数字签名、离散对数 椭圆曲线 椭圆曲线定义式：\\(y^2\\;=x^3+ax+b\\)，（维尔斯特拉斯标准形式） 曲线的一般形式：\\(y^2+a_1xy+a_3y\\;=x^3+a_2x^2+a_4x+a_6\\) 判别式\\(\\Delta=-16(4a^3+27b^2)\\;mod\\;p=0\\) 曲线性质 椭圆曲线上的困难问题:\\(Q=nP\\)，给定椭圆曲线上\\(P、Q\\)两点，求\\(n\\)十分困难 point addition 点加法 沿曲线的 P + Q 两点画一条通过两点的直线。现在继续这条线，直到它第三次与你的曲线相交。最后在该点沿 y 轴的方向取反射。 \\(P+Q+R&#39;=0,R=P+Q,R&#39;(x,-y)=R(x,y)\\) 有限域 定义在有限域\\(F_p\\)上，零元是\\(O\\) 点的阶:对于椭圆曲线上一点\\(P\\)，若存在一个最小的正整数\\(n\\)，使得\\(nP=O\\)，则称\\(n\\)是点\\(P\\)的阶。 椭圆曲线的阶:每个在有限域上的椭圆曲线都由有限个点组成，有多少个点椭圆曲线的阶就是多少。 Sage 环境 在线环境https://sagecell.sagemath.org/ 本地环境https://doc.sagemath.org/html/en/installation/index.html (推荐在 Linux 环境搭建) 基本语法https://www.osgeo.cn/sagemath/tutorial/index.html 简单运算 123456789a = 497b = 1768p = 9739E = EllipticCurve(GF(p), [a, b])Q = E(1539, 4742)R = E(4403,5202)P = E(2339, 2213)print(P+Q)print(4*R) ECDH（密钥交换） ECDH 是椭圆曲线迪菲-赫尔曼秘钥交换（Elliptic Curve Diffie–Hellman key Exchange），主要是用来在一个不安全的通道中建立起安全的共有加密资料，一般来说交换的都是私钥。 算法交换过程 公有参数：\\(p,g\\) Alice 私钥：大整数\\(a\\) 生成 Alice 公钥：\\(A=g^a\\;\\mod\\;p\\) Alice 将\\(A,p,g\\)传递给 Bob Bob 私钥：大整数\\(b\\) 生成 Bob 公钥：\\(B=g^b\\;\\mod\\;p\\) Bob 计算公共密钥：\\(K=A^b\\;\\mod\\;p\\) Bob 将\\(B,p,g\\)传递给 Alice Alice 计算公共密钥：\\(K=B^a\\;\\mod\\;p\\) 交换完成，二者协商出K公共密钥，并且未在传输过程中暴露 K。 An_der_schonen_Elliptische_Kurve 12345678910111213141516171819202122232425262728293031323334from secret import FLAG, ECDH_KEY_EXCHANGEfrom Crypto.Cipher import AESfrom hashlib import md5import binasciiiv = urandom(16)a = 14489b = 10289p = 7486573182795736771889604737751889118967735916352298289975055815020934891723453392369540853603360270847848895677903334441530052977221688450741083448029661F = GF(p)E = EllipticCurve(F, [a, b])G = E.random_point()my_private_key = random_prime(2^256)shared, sender_public_key = ECDH_KEY_EXCHANGE(G, my_private_key)key = md5(str(int(shared.xy()[0])).encode()).digest()cipher = AES.new(key, AES.MODE_CBC, iv)ciphretext = cipher.encrypt(FLAG)print(a)print(b)print(p)print(sender_public_key)print(my_private_key)print(ciphretext.hex())print(iv.hex()) exp 1234567891011121314151617181920212223# sagea=14489b=10289p=7486573182795736771889604737751889118967735916352298289975055815020934891723453392369540853603360270847848895677903334441530052977221688450741083448029661F=GF(p)E=EllipticCurve(F,[a,b])sender_public_key=E([1285788649714386836892440333012889444698233333809489364474616947934542770724999997145538088456652601147045234490019282952264340541239682982255115303711207,1081635450946385063319483423983665253792071829707039194609541132041775615770167048603029155228167113450196436786905820356216200242445665942628721193713459])my_private_key=2549545681219766023689977461986014915946503806253877534915175093306317852773cipher=&quot;2f65ff4a97e0e05c06eab06b58ea38a3d5b6d2a65ea4907bc46493b30081a211d7cffc872a23dbd565ef307f9492bb23&quot;iv=&quot;d151c04c645c3e2a8d3f1ae44589ef20&quot;iv=bytes.fromhex(iv)c=bytes.fromhex(cipher)F = GF(p)E = EllipticCurve(F, [a, b])shared=sender_public_key*my_private_keykey = md5(str(int(shared.xy()[0])).encode()).digest()cipher = AES.new(key, AES.MODE_CBC, iv)m=cipher.decrypt(c)print(m) ECDSA（数字签名） 基于椭圆曲线的 DSA 场景 Alice 想要使用她的私钥\\(d_A\\)来签名，Bob 想用 Alice 的公钥 \\(H_A\\)要验证签名\\(H_A=d_AG\\)。 只有 Alice 才能提供正确的签名，而每个人都可以验证签名。 签名 1.选定一条椭圆曲线\\(E_p(a,b)\\)。 2.选取一个随机数\\(k,1&lt;k&lt;n-1\\)，\\(n\\)为椭圆曲线的阶。 3.选取椭圆曲线的基点\\(G(a,b)\\),计算 \\(K=k * G(a,b)\\)，令\\(r=K[0]\\mod n\\)，即 r 是 K 点的横坐标（若 r 为 0，重新选 k 进行计算）。 4.计算明文 M 的哈希，令\\(e=hash(M)\\)，计算\\(s=k^{-1}(z+rd_A)\\mod n\\)。 5.给出签名\\((r,s)\\) 验证 1.计算 \\(u_1=s^{-1}z\\mod n\\) 2.计算 \\(u_2=s^{-1}r\\mod n\\) 3.计算点\\(P=u_1G+u_2H_A\\) 当\\(r=x_P\\mod n\\)时，签名验证成功。 DSA-LCG 试试这个 1234567891011121314151617181920212223242526272829303132333435363738from hashlib import sha384, sha256from Crypto.Util.number import inversefrom secret import k,privkey,flagdef sign(msg, privkey,k,order): e = int(sha384(msg).hexdigest(), 16) K = k*G r = int(K[0]) k_ = inverse(k, order) s = k_ * (e + privkey * r) % order return r, sq = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffffa = -3b = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aefM = 8368031831458217786350512159882992957012870179737136526893923006288695827959478962195704930743648877201823593529339381563729143350454126812624495126388843x = 0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7y = 0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5fE = EllipticCurve(GF(q), [0,0,0,a, b])G = E([x,y])msg1=b&#x27;hello&#x27;r1,s1=sign(msg1,privkey,k,q)print(&quot;r1 =&quot;,r1)print(&quot;s1 =&quot;,s1)k2=(a*k+b) % Mmsg2=b&#x27;world&#x27;r2,s2=sign(msg2,privkey,k2,q)print(&quot;r2 =&quot;,r2)print(&quot;s2 =&quot;,s2)key = sha256(str(privkey).encode()).digest()aes = AES.new(key, AES.MODE_ECB)ct = base64.b64encode(aes.encrypt(pad(flag, 16))).decode()# r1 = 34007466611771601516061414360911609922088882193344157567527189819210008217689485940426747623610209785764754548617752# s1 = 371900949338744788274672150932790711380367554085093925552194085487875492160150324907657343202698707270323127656622# r2 = 38135753943982836042572890793143465851493833988864701898930580343563479696256688655279135669457443358334628248476702# s2 = 31206970698882787218208833552853920421221998187963884172949797755468379329952479963343252649210115334349094354726288# ct = &quot;1Emwfale6VRBTlkcNZA3wiiNXrOqeifOC53/jXc+gT9Dv9r5I/q0EJKAgkt/sArW&quot; ECDLP（离散对数） 给定椭圆曲线 E，已知 P、Q 以及\\(Q=kP\\)，求 k。 1234E = EllipticCurve(GF(p), [a, b])Q = E(x1,y1)P = E(x2,y2)k=P.discrete_log(Q) PH 光滑阶分解 crypto-sign-in-1(VNCTF2023) 一道 ECDLP 题目，当时想到使用Pohlig-Hellman算法，但是一直没能找到合适的 A、B 来确定 G 的阶 n，赛后看大佬 wp，果然是用 pwntools 远程多试几组 y1、y2，找到光滑的阶，从而解密成功。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123from sympy.ntheory.residue_ntheory import nthroot_modfrom Crypto.Util.number import *from Crypto.Cipher import AESfrom random import randrange,choicefrom hashlib import *from secret import flagimport socketserverimport osimport signalimport stringtable = string.ascii_letters+string.digitsnbit = 128def pad(m,lenth): return m + bytes([i for i in range(lenth-int(len(m)%lenth))])class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b&#x27;&#x27; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) &lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b&#x27;\\n&#x27; self.request.sendall(msg) except: pass def recv(self, prompt=b&#x27;&#x27;): self.send(prompt, newline=False) return self._recvall() def proof_of_work(self): proof = (&#x27;&#x27;.join([choice(table)for _ in range(20)])).encode() sha = sha256(proof).hexdigest().encode() self.send(b&quot;[+] sha256(XXXX+&quot; + proof[4:] + b&quot;) == &quot; + sha ) XXXX = self.recv(prompt = b&#x27;[+] Plz Tell Me XXXX :&#x27;) if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest().encode() != sha: return False return True def handle(self): proof = self.proof_of_work() if not proof: self.request.close() while 1: qa = randrange(0,2**31) * 2 qb = getPrime(nbit - 32) if isPrime(qa * qb + 1): q = qa * qb + 1 break for _ in range(len(b&#x27;vnctf2023&#x27;) - 8): self.send(b&quot;Send 2 `y&#x27; elements to me: &quot;) ans = self.recv() try: y1, y2 = [int(_) % q for _ in ans.split(b&#x27;,&#x27;)] except: self.send(b&quot;Your parameters are not valid! Bye!!&quot;) break AA = (y1**2 - y2**2 - 2022**3 + 2023**3) * inverse(-1, q) % q BB = (y1**2 - 2022**3 - AA * 2022) % q def add(P,Q): if P[0] != Q[0] and P[1] != Q[1]: t = ((Q[1]-P[1]) * inverse(Q[0]-P[0],q)) %q else: t = ((3*P[0]*P[0]+AA)*inverse(2*P[1],q))%q x3 = t*t - P[0] - Q[0] y3 = t*(P[0] - x3) - P[1] return (x3%q, y3%q) def mul(t, A, B=0): if not t: return B return mul(t//2, add(A,A), B if not t&amp;1 else add(B,A) if B else A) while 1: Gx = randrange(0,q - 1) try: Gy = int(nthroot_mod((Gx**3 + AA * Gx + BB) % q,2,q)) assert (pow(Gy,2,q) == (Gx**3 + AA * Gx + BB) % q) break except: continue G = (Gx,Gy) m = randrange(0,q-1) C = mul(m,G) aes = AES.new(m.to_bytes(16, &#x27;big&#x27;), AES.MODE_CBC, bytes(16)) enc_flag = aes.encrypt(pad(flag,16)) self.send(b&#x27;The parameters and encrypted flag are:&#x27;) self.send(b&#x27;q = &#x27; + str(q).encode()) self.send(b&#x27;G = (&#x27;+ str(Gx).encode() + b&#x27;,&#x27; + str(Gy).encode() + b&#x27;)&#x27;) self.send(b&#x27;m * G = (&#x27;+ str(C[0]).encode() + b&#x27;,&#x27; + str(C[1]).encode() + b&#x27;)&#x27;) self.send(b&#x27;encrypt flag = &#x27; + enc_flag.hex().encode()) self.request.close()class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): passif __name__ == &quot;__main__&quot;: HOST, PORT = &#x27;0.0.0.0&#x27;, 10001 print(&quot;HOST:POST &quot; + HOST+&quot;:&quot; + str(PORT)) server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#sagefrom pwn import *from itertools import productimport stringfrom hashlib import sha256from random import getrandbitsfrom ast import literal_evalfrom Crypto.Util.number import *from Crypto.Cipher import AEStable = string.ascii_letters+string.digitsdef set_connect_proof(): io=remote(&#x27;node4.buuoj.cn&#x27;,&#x27;25385&#x27;) io.recvuntil(b&quot;sha256(XXXX+&quot;) alphabet = string.ascii_letters + string.digits lattar_part=io.recv(16).decode(&#x27;utf8&#x27;) io.recvuntil(b&#x27;== &#x27;) h=io.recvline().strip().decode(&#x27;utf8&#x27;) # print(h) io.recvuntil(b&#x27;[+] Plz Tell Me XXXX :&#x27;) bruteforce=[ &#x27;&#x27;.join(prefix)+lattar_part for prefix in product(alphabet,repeat=4)] for proof in bruteforce: if sha256(proof.encode()).hexdigest()==h: io.sendline(proof.encode()[:4]) print(&quot;proof done&quot;) return iowhile True: io = set_connect_proof() io.recvuntil(b&quot;Send 2 `y&#x27; elements to me: &quot;) y1,y2 = getrandbits(128),getrandbits(128) io.sendline(f&#x27;&#123;str(y1)&#125;,&#123;str(y2)&#125;&#x27;.encode()) q = int(io.recvline_contains(b&#x27;q = &#x27;).decode().strip()[4:]) G = literal_eval(io.recvline_contains(b&quot;G = &quot;).decode().strip()[4:]) mG = literal_eval(io.recvline_contains(b&quot;m * G = &quot;).decode().strip()[8:]) encflag = io.recvline_contains(b&#x27;encrypt flag = &#x27;).decode().strip()[len(b&#x27;encrypt flag = &#x27;):] AA = (y1**2 - y2**2 - 2022**3 + 2023**3) * inverse(-1, q) % q BB = (y1**2 - 2022**3 - AA * 2022) % q E = EllipticCurve(GF(q), [AA, BB]) g_order = E(G).order() order_ls = factor(g_order) print(f&quot;[+] G order &#123;order_ls&#125;&quot;) sub_group_order = 1 for p,e in order_ls: if p.nbits() &lt;= 42: sub_group_order*= (p^e) expon = g_order//sub_group_order print(f&quot;[+] &#123;sub_group_order.nbits() = &#125;&quot;) if sub_group_order.nbits() &lt; 120: io.close() continue mm = discrete_log(expon*E(mG),expon*E(G),ord = sub_group_order,operation = &quot;+&quot;) print(f&quot;[+] subgroup dlp (m mod &#123;sub_group_order&#125;) = &quot;, mm) io.close() breakaes = AES.new(int(mm).to_bytes(16, &#x27;big&#x27;), AES.MODE_CBC, bytes(16))flag = aes.decrypt(bytes.fromhex(encflag))print(flag) Singular Attack 利用曲线上的奇异点进行攻击，奇点就是该点导数不存在，或者导数为 0 但不是极值点。 若椭圆曲线的判别式\\(\\Delta=-16(4a^3+27b^2)\\;mod\\;p=0\\)，说明该曲线有奇点。 RWCTF2023 体验赛 12if u == w: m = (3*u*w + 4*u + 1) * i(v+x) 根据题目，可得到曲线关于 x 的导数，\\(3x^2+4x+1\\)，所以可得到方程为\\(y^2=x^3+2x^2+x+C\\) 题目已知点(4,10)在曲线上，代入得到 100 = 64 + 32 + 4 + C，即 C = 0，所以方程确定\\(y^2=x^3+2x^2+x\\) 方程左右求导得到\\(2y \\frac{dy}{dx}=3x^2+4x+1\\)，所以当 y=0 时导数不存在，再把 y=0 代入方程，求得 x=-1，所以找到该曲线的奇点为(-1,0)。 下一步我们把曲线平移，使得曲线以(0,0)为奇点，得到y^2 = x^3 + 193387944202565886198256260591909756040*x^2，改写为y^2 = (x + 193387944202565886198256260591909756040) * x^2 因为193387944202565886198256260591909756040 = pow(89654903351345918131227153390056628523,2,p) 我们就可把 P、Q 点映射到乘法群上，从而进行简单的对数计算。 映射法则如下: \\[(x,y)\\rightarrow\\frac{y+tx}{y-tx}\\] EXP 1234567891011121314151617p=193387944202565886198256260591909756041P.&lt;x&gt; = GF(p)[]f = x^3 + 2*x^2 + xP = (4, 10)Q = (65639504587209705872811542111125696405, 125330437930804525313353306745824609665)print(f)f_ = f.subs(x=x-1)print(f_)print (f_.factor())P_ = (P[0] +1, P[1])Q_ = (Q[0] +1, Q[1])t = GF(p)(193387944202565886198256260591909756040).square_root()u = (P_[1] + t*P_[0])/(P_[1] - t*P_[0]) % pv = (Q_[1] + t*Q_[0])/(Q_[1] - t*Q_[0]) % pprint (v.log(u))","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"Euler's Factoring to RSA","slug":"Euler","date":"2023-04-18T06:05:45.000Z","updated":"2023-04-18T10:39:11.334Z","comments":true,"path":"2023/04/18/Euler/","link":"","permalink":"https://sch01ar.github.io/2023/04/18/Euler/","excerpt":"","text":"Euler's Factoring to RSA Outline 对于 RSA 中\\(N=(ma^2+nb^2)(mc^2+nd^2)\\)的情况进行分析以及安全性评测。 Euler's factorization method 欧拉因式分解法是通过两种方式将数字写成两个平方和来分解数字的方法，对于一个合数\\(N\\)来说，若\\(N=a^2+b^2\\)，则可以将\\(N\\)进行因式分解，例如\\(1000009=1000^2+3^2=972^2+235^2=293\\cdot3413\\) Theoretical basis Brahmagupta-Fibonacci 恒等式 \\[(a^2+b^2)(c^2+d^2)=(ac-bd)^2+(ad+bc)^2=(ac+bd)^2+(ad-bc)^2\\] Proof \\[a-c=kl\\] \\[d-b=km\\] \\[a+c=hm\\] \\[d+b=hl\\] 运用Brahmagupta-Fibonacci 恒等式 \\[(k^2+h^2)(l^2+m^2)=(kl+hm)^2+(km-hl)^2=((a-c)+(a+c))^2+((d-b)-(d+b))^2=4a^2+4b^2=4n\\] 所以得到 \\[n=((\\frac{k}{2})^2+(\\frac{h}{2})^2)(l^2+m^2)\\] 后续求解如下： \\[khl^2+khm^2=(a-c)(d+b)+(a+c)(d-b)\\] \\[kh(l^2+m^2)=2ad-2bc\\] \\[l^2+m^2=GCD(ad-bc,n)\\] Generally 对于更一般的\\(N\\)来说，如果\\(N=ma^2+nb^2=mc^2+nd^2\\)的情况应用欧拉分解是否可以进行？ 当然是可以的，但可惜欧拉在 1891 年失去了生命，没能继续进行他的研究。后世 Lucas 和 Mathews 先后对这样的情况进行了分析推导，证明了\\(N\\)是可分解的。 My proof 对于\\(a,b,c,d,m,n\\in \\mathbb{Z}^+,并且gcd(ma,nb)=gcd(mc,nd)=1\\) \\[N=ma^2+nb^2=mc^2+nd^2\\] \\[N=\\frac{1}{2}[m(a^2+c^2)+n(b^2+d^2)]\\] \\[N(d^2-b^2)=\\frac{1}{2}(ma^2d^2+mc^2d^2+nb^2d^2+nd^4-ma^2b^2-mc^2b^2-nb^4-nb^2d^2)\\] \\[\\because n(d^2-b^2)=m(a^2-c^2)\\] \\[\\therefore N=\\frac{1}{2}[ma^2d^2-mb^2c^2+mc^2d^2-ma^2b^2+m(a^2-c^2)(d^2+b^2)]\\] \\[N=m(ad+bc)(ad-bc)\\] 我们还需要另外一个等式，运用Brahmagupta-Fibonacci 恒等式得到 \\[N^2=(ma^2+nb^2)(mc^2+nd^2)\\] \\[N^2=(mac-nbd)^2+mn(ad+bc)^2\\] 因为\\(gcd(m,N)=1\\),由此得到 \\[N=gcd(N,ad-bc)* \\frac{N}{gcd(N,ad-bc)}\\] Apply to RSA 在 RSA 传统加密中我们知道，\\(N\\)的选取尤为重要，如果选取的\\(N\\)易于分解，那么明文将不再安全。 对于\\(N=(ma^2+nb^2)(mc^2+nd^2)\\)，即\\(p=ma^2+nb^2,q=mc^2+nd^2\\) 针对这种看似数字很大的\\(N\\),下面进行一些实际的代码生成与攻击。 P、Q_generate 1234567def genprime(m,n): while True: x = random.getrandbits(150) y = random.getrandbits(150) p = m*x ** 2 + n*y ** 2 if isPrime(p) : return p, x, y abcd_generate 123456789101112131415while True: m = getPrime(212) n = getPrime(212) p, xp, yp = genprime(m,n) q, xq, yq = genprime(m,n) N = p * q a = abs(m*xp * xq - n * yp * yq) b = abs(xp * yq + xq * yp) assert N == a ** 2 + m*n * b ** 2 c = abs(m*xp * xq + n * yp * yq) d = abs(xp * yq - xq * yp) assert N == c ** 2 + m*n * d ** 2 if a.bit_length() &lt;= 512 and b.bit_length() &lt;= 300 and c.bit_length() &lt;= 512 and d.bit_length() &lt;= 300: break Encrypt 12345flag = b&quot;you_have_already_understood_this&quot;N = p*qe=65537msg = bytes_to_long(flag)Cipher = pow(msg,e,N) Attack 1234567p=GCD(a*d-b*c,N)q=N//pd=gmpy2.invert(e,(p-1)*(q-1))msg=long_to_bytes(pow(Cipher,d,N))print(msg)# b&#x27;you_have_already_understood_this&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"NSSCTF Round11","slug":"NSSCTFRound11","date":"2023-04-08T13:05:45.000Z","updated":"2023-04-11T11:55:17.610Z","comments":true,"path":"2023/04/08/NSSCTFRound11/","link":"","permalink":"https://sch01ar.github.io/2023/04/08/NSSCTFRound11/","excerpt":"","text":"最后 rank 排第 4，差一道 AK，可惜。 ez_enc 题目描述说了不是培根加密，所以考虑 AB 为二进制情况，192 位数判断，8 位为一组，简单写个脚本跑就行。NSSCTF&#123;mS4gT1Kv9L8NjPzx&#125; MyMessage(2🩸) 题目 123456789101112131415161718192021from Crypto.Util.number import *import osflag = os.getenv(&#x27;FLAG&#x27;)e = 127def sign(): msg = input(&quot;Input message：&quot;) p = getPrime(512) q = getPrime(512) n = p*q c = pow(bytes_to_long((msg + flag).encode()), e, n) print(f&quot;n: &#123;n&#125;&quot;) print(f&quot;Token: &#123;hex(c)&#125;&quot;)def main(): while True: sign()main() 题解 分析一下发现是 CRT，e 是 127，不算很大，pwntools 远程连一下就出了，用 127 组 n、c 就能出。 1234567891011121314151617181920212223import gmpy2from sympy.ntheory.modular import crtfrom Crypto.Util.number import long_to_bytesfrom pwn import *r=remote(&quot;node1.anna.nssctf.cn&quot;,&#x27;28993&#x27;)r.recv()n=[]c=[]for i in range(127): r.send(b&#x27;\\n&#x27;) n0=int(r.recvline()[3:]) n.append(n0) c0=int(r.recvline()[7:],16) c.append(c0) r.recv() print(i)e=127resultant,mod= crt(n, c)print(gmpy2.iroot(resultant, e))print(long_to_bytes(2806865643354785603324943800380811808524058654491089619946085108629974212427336755928938684569729653368445)) MyGame(3🩸) 题目 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from Crypto.Util.number import *import osimport randomimport stringflag = os.getenv(&#x27;FLAG&#x27;)def menu(): print(&#x27;&#x27;&#x27;=---menu---=1. Guess2. Encrypt&#x27;&#x27;&#x27;)p = getPrime(512)q = getPrime(512)n = p*qdef randommsg(): return &#x27;&#x27;.join(random.choices(string.ascii_lowercase+string.digits, k=30))mymsg = randommsg()def guess(): global mymsg msg = input() if msg == mymsg: print(flag) else: print(mymsg) mymsg = randommsg()def encrypt(): e = random.getrandbits(8) c = pow(bytes_to_long(mymsg.encode()), e, n) print(f&#x27;Cipher_&#123;e&#125;: &#123;c&#125;&#x27;)def main(): print(f&#x27;n: &#123;n&#125;&#x27;) while True: opt = int(input()) if opt == 1: guess() elif opt == 2: encrypt()main() 题解 仔细读代码，发现是共模攻击，找两组 c、e 即可 12345678910111213import gmpy2from Crypto.Util.number import long_to_bytesc1=20432531576155215888154008856470023176716331725918571318249616529204088736445989550189654688043730733020564485947864747196975750100435327664656429806649525534120919148246123023379811466301511729993913961801030758822865877036889575149918981442195476030813460030620757387049663845188034750154180593983566582520e1=27c2=49343226468934676124103999715864898108289119770186347123043696311071406231664645680952259061776732950065396078048353154283241280855775618011869819311337805185923169181212309315036973967627008736733179896379120366510464553630612190775773048857991437285631208686684892260979310870861832511307571472115286628517e2=20n=120132192877694910217679507021165646332695827464809117195210649277384674795669034856718931569263574670286802451973300796012519337781757661938081109028300520380652830599013093103694871345527473374707911919217651889156901714534844579748040213772147486709217128429189246896619833922990939367369152675847389673607r,s1,s2=gmpy2.gcdext(e1,e2)m=(pow(c1,s1,n) * pow(c2,s2,n)) %nprint(long_to_bytes(m)) ez_signin(3🩸) 题目 1234567891011121314151617from Crypto.Util.number import *from secret import flagp = getPrime(512)q = getPrime(512)assert p &gt; qn = p*qe = 65536m = bytes_to_long(flag)num1 = (pow(p,e,n)-pow(q,e,n)) % nnum2 = pow(p-q,e,n)c = pow(m,e,n)print(&quot;num1=&quot;,num1)print(&quot;num2=&quot;,num2)print(&quot;n=&quot;,n)print(&quot;c=&quot;,c) 题解 从 num1 和 num2 入手进行推导，这种类似推导在seccon中的pqpq也遇到过，遇到 p 和 q 和与差的次方时要善于展开。 \\[num1=p^e - q^e \\; mod \\;n\\] \\[num2=(p-q)^e \\; mod \\;n=p^e + q^e \\;mod\\;n\\] \\[num1-num2=2q^e \\;mod\\;n\\] 与 n 求 gcd 即可得到 q。后续又发现gcd(e,phi)=4 我直接用phi//4就出了，但看别的师傅题解是使用了 16 次 rabin。App1e_Tree 123456789101112131415from Crypto.Util.number import *import gmpy2e=65536num1= 77257223159958079981390137355142080015023010733827990250504328622199243866334208454700846525239387121424870112593354883264915110401096320266418705582162604997618363889158629900108704858615247007992567853124974343579594813658250285927213124866151010168331988825030114602867745638435653619050902109851045530048num2= 8670006639226140401848502013409874417778806171787684181700490726088123676562019413771703217181880276367622310216897452417434923879832976569809207272273038152452280440576111149210141624539176252808510923727718037881253248639329799746808602221142415191253040793180318625834835539461350068653267738595818142033n= 139312918646958911643614106477250346542938203733216645101706250934506039430465265284553776989331472694107269641055499427941102923536860105801322441769366401061519774361630724222802972762597316259472094210197432833307534335146157789503227756546698356309143161714893413713163015318965716763931005983883676146349c= 117425520472164947185011060551908800156070555958546948883959815215678093994397105451763661641181472902919466937760258731806408698523865490809605237116064587181672662857632969568595375221472415619173606876351479605389472618536640276793037520925913907146004116095678083180079715242304920764573160813391671768563q=GCD(n,num1-num2)p=n//qphi=(p-1)*(q-1)print(GCD(phi,e))d=gmpy2.invert(e,phi//4)print(long_to_bytes(pow(c,d,n))) NTR(4❄️) 题目 123456789101112131415161718192021222324import gmpy2from flag import flagfrom Crypto.Util.number import *def init(): p = getPrime(2048) while True: x = getRandomNBitInteger(1024) y = getPrime(768) z = gmpy2.invert(x, p) * y % p return (p, x, y, z)def encrypt(cipher, p, z): message = bytes_to_long(cipher) r = getRandomNBitInteger(1024) c = (r * z + message) % p return cp, x, y, z = init()c = encrypt(flag, p, z)with open(&quot;cipher.txt&quot;, &quot;w&quot;) as f: f.write(&quot;binz = &quot; + str(bin(z)) + &quot;\\n&quot;) f.write(&quot;binp = &quot; + str(bin(p)) + &quot;\\n&quot;) f.write(&quot;binc = &quot; + str(bin(c)) + &quot;\\n&quot;) 题解 基础 NTRU 格密码，具体推导可看前几篇博客 DUTCTF 的 ez_RSA 1234567891011121314import gmpy2from Crypto.Util.number import *z=0b10101100101100011011110010110100101000101001111100110011110110010001000011100001001001111000111110000010010010111110001011111100111101010111001100100111100100111001011011110010100010100010110111101101011101111111110010000000010110011010011110000011000001111110001110111111001100001100101001010101100011100001101001101011011101110001000111001010111111110000010111100111011010011001111100111111101000010111111011010100110111000001011000001111010100000000101010110000100000111000000010001101110001101000111001010111111101100111110000011001110100011100011101000101111010111000111100010001101001101100000111010110100000001101100010001000011111100111110001010000010110110110010001110010100000000101111101100010000111011011101111110100001000011001101001110110011110000110011100010010011010011001110100010110001011110100100101110101001000011100100100000001001011010011001110001000111101101110110010011110000010110000110111000111100010101100010100100101101100000111100001010000101010111001000111111000111100111011111110011001000000110000000110111101000010111001100111100010010100010001111011100110110111101111001010101110001000001110101110101100101001101100100101011010000011111111110111101001100001000111010000111110000001010100100101111010110001000111010100011110100000000100100001101001000101100111001110010010011110010000101101010011101000110000001101010010011000010110111101001011010011010000001010110001100100000001111001100000000100100100010010101011110100001010010110001101001111000100100110001011111000101110011100110010111001110100010000111001110101000101110101110110100100110110111000100110011111110011100111100111100011001101010011110000101000100110010000000000111101111000001100000100110010100100111001011011011100100011110001010001111011111011000010010011101110000011101101110001111100011100101011001000101110010110011100110000100101010001010111011001000011001101000011111100010001111001100001111100011001010111010010110001110110111111010011010111011010000110110100100011010111000110011010010001100011011010100111011101011000010110000110001010p=0b10111111010111000101011100010100001001011110111101011011010110110000010011111101110011100111001101110111010101000001111111111000101100111000110010000110101001110100000000011100001111101000101110010101110011110101100011111111110000110001101101110100100111100101101100110001001101110010010100010011100011111000001000001100001110000011010000111001000000111010000001001101101100110111001111110000111000110001011111000010011101110010101011100110011000111100111100000001100101011001000110001111000010011111110010101010111001111000111011011110110100011011010110000011100101100100010001011011111100100011001101011110100100000011011110110110011111000110001000010010001111001111100101000101101011011110111010111101110000011100000100010001010100000011000110001011001000101011101011101011111010010010110101000111111110011010100000010001000011111100100110001000010011111000111010100111000101100011100111110100111000101011010101010101111111010011101001110011101101001100100010100000110011101111100000011101010001010001011000101011001111010000000000010100001101010010011011000000010000111010000001000111101001001000011000011100101100011010100111010010111110110100011101100000000110001011101110100100011011110101010010010001101100001011000001101010110110101110100110110011110011110011100001000000011101000000010011101001001001111111001010100111111110101000110011010110001101011101011111100100001011001111100010001100011011010100111100111000100010000011100100001010111100001100011001010001111001001001110011100100010111000001110001000110101110011100100000101000100010011011011001011010010101111001110101000011001111000101111011011101001101001111100111001111011100110100100011000010010100000110001010110000100111110101001111100100101001101101000100001001011011011000101100111101100011110011011101001010110101001100100100010010100011111000010110101010101011110100011000011000001111001100000110010110101110100101100010100010001001101000110110111101110100000001001001000010010001101101001011000101111101011110001101010101110111111101101100101110011011010000100110111011c=0b1100000111101010011111101100110110001100001111110010001011011110011111000011111010010111110100010001110000101100101010100010001001011110001100000101100111010010001001000011010110100100100100101010001100011010111111010101011010111000010010111101110101001010110000101101010010011100000100010110011011010001111101000111000100101011011011101100001011100101001101100000010100001100010111010110101001100110101000000101110111111001011000011100100101110010000000110010111100001000111110111011111011011111100101011000110000000011001101010111001101010100011000011100001000010000001100011100110110000010111100101011110010110011100000111001010000101010001000001101101100010000101100111111100110010100001011110101111001000101111111010100100110011011001101101000010000111110010100100100111100110100110011011000011101110010111011111110100110011010110100010101000011111001111000100001000011011000010000001010011111001111010000000110111011000110001100110010101000101110110101000001101001000001011000110011011011010111011011101100101011101010110101111100010101000010100001010011101010101001100000010000000001111111100100100011011110001001010010110001000101111011101010101100001011111101100101000100010100010100000001111101000111110101111111100001011111001010101001011000011011100001011100010100111100100110101111011001011001011100001011111110100001111011101001000001110110011101111101011000010110011111011001100011000111010101111000101001100010010001101110111011111101110111110001000111111001111010101110100111001001001000100111111111111100010100111110110001111010011001111010001000010110000000101100001000111010101010100000111110111110011010001100001101111010111110010010011001111001100111010010011010010101100111011100001011110111100001000101101000111001000001011000010111010101011110011100001010001100110011101011000000110001010011110010100011100000101111000110110110000001011010110010000001001111100001010010010001101111011010111000100001011111010111001000000011101001001111001011101010100001100010101001011010110111011010010100100100101011111100110111110111h=zM = Matrix([[1, h], [0, p]])fg = M.LLL()[0]f, g = abs(fg[0]), abs(fg[1])a = f * c % pE = a * gmpy2.invert(f, g)%gprint(f.bit_length())print(long_to_bytes(E)) ez_fac(未出) 题目 12345678910111213141516171819from Crypto.Util.number import *import randomfrom secret import flag,a0,a1,b0,b1p = getPrime(512)q = getPrime(512)e = getPrime(128)n = p*qassert pow(a0,2) + e * pow(b0,2) == nassert pow(a1,2) + e * pow(b1,2) == nm = bytes_to_long(flag)c = pow(m,e,n)print(&quot;c=&quot;,c)print(&quot;n=&quot;,n)print(&quot;a0=&quot;,a0)print(&quot;a1=&quot;,a1)print(&quot;b0=&quot;,b0)print(&quot;b1=&quot;,b1) 题解 赛后自己推了一下，欧拉公式分解 因此有 \\[a-c=kl\\] \\[d-b=km\\] \\[a+c=hm\\] \\[d+b=hl\\] 推到这步之后，运用Brahmagupta-Fibonacci恒等式，得到 \\[n=((\\frac{k}{2})^2+(\\frac{h}{2})^2)(l^2+m^2)\\] \\[khl^2+khm^2=(a-c)(d+b)+(a+c)(d-b)\\] \\[kh(l^2+m^2)=2ad-2bc\\] \\[l^2+m^2=GCD(ad-bc,n)\\] 所以对应到本题当中，p=GCD((a0*b1-a1*b0),n) 1234567891011121314151617from Crypto.Util.number import *import gmpy2c= 59318036714789752844006238692725062195097217062554867007780992204804450969142204391316045272560233388274742342095873063037352032862624199553582149985170237070779964129236530514163078045059943014170914727745788332060644178009630719416607144479458704906477608582501903047686165816474471957589874497851401996299n= 137668242641076635664648797843242668120238355343016879645699934379078238840410583671764334209483740737808707460147728851168032552228765759429988090828780489149204937220494635170377998778905602318559649339660536303852604291303891241968251882157710174648060585737047441793290567655691681568937436184102493026497a0= 11733211096757640611023179466137568647194748846209714362630723124944554158026265927220172817593295793460531810586641675319307669405413132181412592532359680a1= 11733211096757640611023178103076370448537803344455852236399317962314322115993820094669322043912570063235179770967045735659217853855020241135449964093477392b0= 16952448082892650701908860033061048276853071047612576981620233993855951344312992860690440851309510652705695741073983670611b1= 307989142448102248940629255335003301679438459116674689074678317519163453142223887826928430255723118986268767245966808235987e=(n-pow(a0,2))//pow(b0,2)assert pow(a0,2) + e * pow(b0,2) == np=GCD((a0*b1-a1*b0),n)q=n//pphi=(p-1)*(q-1)d=gmpy2.invert(e,phi)print(long_to_bytes(pow(c,d,n)))","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"NKCTF2023","slug":"2023NKCTF","date":"2023-04-04T02:05:45.000Z","updated":"2023-04-27T01:01:03.377Z","comments":true,"path":"2023/04/04/2023NKCTF/","link":"","permalink":"https://sch01ar.github.io/2023/04/04/2023NKCTF/","excerpt":"","text":"数字中国 Babysecret 题目 123456789101112131415161718192021222324252627282930from Crypto.Util.number import *from secrets import flagassert len(flag) == 38t = 30p = getPrime(512)x = getPrime(512)while x &gt; p: x = getPrime(512)rs = []cs = []ss = []for i in range(t): r = getPrime(512) s = getPrime(400) c = (r * x + s) % p rs.append(r) cs.append(c) ss.append(s)enc = pow(x,flag,p)print(f&#x27;p = &#123;p&#125;&#x27;)print(f&#x27;rs = &#123;rs&#125;&#x27;)print(f&#x27;cs = &#123;cs&#125;&#x27;)print(f&#x27;enc = &#123;enc&#125;&#x27;)# p = 6897108443075981744484758716081045417854227543713106404294789655180105457499042179717447342593790180943415014044830872925165163457476209819356694244840079# rs = [12844634549263053228759749264403637022740290008286987401585068952741935277415527678380021212624846722242500708422759563558995936977274580301379494195702461, 12251634003683452916928102291170339939586644029776192301741341674585154859358419625191986830852794085541953563738986709807899575511700135958334229151930861, 7051370666077542197248638013011793824477073777322219545882367881807130066168444134964571398112151848834032654978368255218649720738040945429837692857031957, 9773046862351952930368505593284546267554571295872377323111558071278701231472975791962979256551519533723988556870551885073742407630481198192389750289392107, 8883776497660138308720006912582738672888752344326928153810910221453595077711284302041512529457450211602787210761461172326429880594024187025419873043435877, 12056735137145460036580841038332100311160368843873164649606343042416896898793233249873902218683966283969721460087390120622254758027779960740926123005377571, 8819958747150954554494406068232243249186433676383469322817152210037563032056202909377825740775383087605647374150477096718956454225946093710691864988563109, 12246023449098354751049599873213988024512286270964608502444597112110163392131757813461977030270733012385926751192637938686124570227538910606279104888073013, 11308837998867241929817950595621831002334468993828126438599805989088017326675963100044309448653090403889186401929445861220402556074702741108929442867300279, 9184622887414209361516593101129556569811888214607556630094969763910426953786020755838094184972397480276666170685926425137063559394969166216392939257091541, 12896400069515890897430087815982545671830645201023665112429779640768899091287291452408369445919464144390726200808875066389240126909811239597092893733457339, 11227025698697471809912850435140886785315702278826761054472525227951791647003561270585720797267604996360933395122286757099101227901032364782594523739698877, 8162123490656317490361880020667919072708091053716891870691544217490126444997503404094174246087938828993696335191488583306443577208796794274099282013427247, 13366989889442670291461262313757977600095962057470863475519088648267301129719953368943419562144276679400967122727554764013132918505564677243979978807323041, 9920857455945408588203972193444437533164351309299040911469275059092031755811492460585653948481522995557801781838215407648572999358456612525812067538372579, 7139402473546047825312503780125417567716958846513076797328672521987900978293260385267945187604725349720103672258987935569856239987227455748213833342843243, 13108142660294572752252393081421368493392921884487755391460006730258159004638343897340537616297811742032405724656497443006056456690449881719305597286675631, 13276762958403786077380090195631980415297280849950287990717193547481553124160398455403123819234755237450529090601858784999113026218918277529515287668651121, 12463094640052886550696551772104539361264529587569204472038955376345085195998921095774583176899949596998985033050547755235409943131811058035802010421860899, 11307743131694864808301935844724645695851330736969875190167422024500753079857478680029193758960169072890576310607053767920339034290416580654771095674487943, 10053742503547378455068966704402695956702795408343604912294923217443553169726438945982031485796964462946592530592946335569560364464958066521486506177193131, 9703695763451799125258961776229325510814289358679213305418559381901496449849584244211834872313767844996255556721041007654625153809128987422992102292472533, 8148189465927721940294369879439913703690047528695196368949823197675716174991296513758196009346701553643721225250628151384047219921709201619262393792138023, 9114150910964237818418367840207724528917302406836157928223872622442928604249864486858755737149640683259834299165900696585038569188627682022002709058902291, 12273514376180781903469287345188404399033432117915094289694407562166649079228640510678711431664410226301556172582177240184695103942141430877677144285616059, 8355005721684425514882933910286584148305344580589623112959517428993968438533866906223777778058096962333203237111245328436600994120168924143849685728268811, 8957883838807471492147480816683526636019698464133185237668243268667169800811696770484487123560197988448434475112352005768286417529319182162245840523697001, 12168542584724814356632409768687396920143300559579648963851924568387314914334359305942685551210180448419674060219496395116081866784918059237133414041227833, 12285935007930825571672128346804313607196190465690759870758278705086034778808662886056460827935986285259185071514490942831585313190946386878622608868345563, 7719913817859572377164973343651155934060296607908537845256755472465025202751239980758950094865067751407889569369974011139801401586939119147773466111699913]# cs = [3911325901261770731066343727353093385607196883601022244426857460074338420692610012414571623512152485474248169220030587839849722757773859682519433853455847, 4198555117325325874584019691418573071733167640213933749582347442518997588452211673143722179281773602455507001395983681009769848414007206268682184816168744, 4422173666634983234895098798813962037875417568235708524339826709271381748884936178371767574064794177416615710120223914725873239836121654705208614576413533, 3540260422555697887869627546208164711550015909378340105077652177481959576550678379723450981807556863572610759824660630418670546203733170058626755080797998, 6451498467498935201092514865627931677091078787997097414208430992183264950579022373372254486595458117887305393317663712337699331503725124287017134808484874, 3439629581963524351810430910737336124616316641656190641248434504621774235943514617301857917041111617104850245148746427180069743940612560718213177903427306, 4279468191481832212496939242093486044278976937965085475567008228061184947513156012369586970486543083130565628906296600553024574099481246534878242920637212, 4102135455518061133919027670571325279976222647984452353051395864554309521223498761823084717077102213648612826513661629599971609555235760152049549057234342, 329051927890365028889097463563711966673066795688728876214731188783168691555262156515161429328581094087585127929869064685419149676592073496155898360311360, 1674347209896897571502352451063188834938904430329951752111921115230349947823188121972980025563878887201507629419811736910690965020923751424101521816057970, 4779084317811375050159574994746297486592271247137823471375199626788956576998627181220489952507937768042501203098391966702297812537463211799837921684467541, 5240331815784322792144549873873658636726233093228415489098002982220769676718681132737794994708716389174162820721646744776624413735318240597745363490427584, 2689716894922604875455207695253665212853470308341743040957367957727155614199743562225147359614514189877983156892749669804800163252617480446565479990148021, 449708769594599088851244243076921016853502252396793496349534051273454215985560340288452398756880916680293627457774430655982228613348249480600180821975835, 1584603978331289335352997151059666773277943458357161051278658090420067023680231414255557805410288144092653121568766136372728095300982743309696347031121424, 4874260053151700374809337053763032489184725334196495160358275038586824027920238733886703163018450814805937363825223459277373073591021082276610135118976834, 3524374131362906900545297291947110177298862564718451821839794960169356082042548386553363480921097452902723033854749443288682983558847052843293666815425196, 6544123591499569232021913370293570477776709315008783531720886545784773471486769240711262562401683145937715612435213816372680189321141928790509490282629891, 4873861166228118967099569086478548167127431415017791678812419676791754466935832034870862000658789609084166891933970013849850146718379819943737269970654866, 4100817874436703071716655163972145036104985973164830547825929590871920825981241934633977227547934514142660786061291026657802357404024236287955309372489516, 343238276681348130286495167739162902430650061145485619903964358840996341335935043000395056684771452815629410388891486531126938900311458948803147120186532, 2683710724350412998770392318832434885304538325033159937379489319924346689197445720734209841902612235485016866254994045969716413020197296428323832404151182, 5909464641105704179999104311562416363090166762341644691188169716182958971270396007422581429813172933930581475771306034495224054972725230757675444731953480, 105593489999747649490909471306354863316673821363863362258853043970534652401274789197677558215188249074837829003335733211890211648501689656345824858507373, 4992379366542645691375959247465888889778118153982142100956809440855745659745235576280578316185469306620017845690312554043770651058126536040173113949524396, 6533456398244789907636779407045515567135195474284185379689518387558345997627435421582437390053234675991361808532278264077968540197407743744279106871716267, 5169360398767270275853790242315213671633880428212603766301308853363063092609582572957561138022806887895634140899640025570759919257615537375706008159680239, 203310740924699994885931266978520636166917734618272844754878785050509801614513144739164450834936178065792112797202959106365282699245578309060905297742706, 3143563289239398127009575193211845399079310618985464994769603542400451633289266080869317336163844517539211542909055869608349639432145332113320465388067087, 4016252180207572047405081190649590978593306403200098541033213590567723751195926093369984531729148621419589009515870336049849542537363832071754623330736088]# enc = 1315637864146686255246675143589215932218700984880749264689270214639479160648747323586062096067740047809798944996253169402675772469028914904598116394230426 \\(enc=pow(x,flag,p)\\),离散对数问题，p 是光滑的，后续可通过 PH 求解，但 x 未知 \\(c=(rx+s)\\;mod\\;p\\),c 和 r 是 30 位的向量，通过 LWE 求解 x 即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from sage.modules.free_module_integer import IntegerLatticefrom Crypto.Util.number import *import hashlibrow = 30column = 1p = 6897108443075981744484758716081045417854227543713106404294789655180105457499042179717447342593790180943415014044830872925165163457476209819356694244840079rs = [12844634549263053228759749264403637022740290008286987401585068952741935277415527678380021212624846722242500708422759563558995936977274580301379494195702461, 12251634003683452916928102291170339939586644029776192301741341674585154859358419625191986830852794085541953563738986709807899575511700135958334229151930861, 7051370666077542197248638013011793824477073777322219545882367881807130066168444134964571398112151848834032654978368255218649720738040945429837692857031957, 9773046862351952930368505593284546267554571295872377323111558071278701231472975791962979256551519533723988556870551885073742407630481198192389750289392107, 8883776497660138308720006912582738672888752344326928153810910221453595077711284302041512529457450211602787210761461172326429880594024187025419873043435877, 12056735137145460036580841038332100311160368843873164649606343042416896898793233249873902218683966283969721460087390120622254758027779960740926123005377571, 8819958747150954554494406068232243249186433676383469322817152210037563032056202909377825740775383087605647374150477096718956454225946093710691864988563109, 12246023449098354751049599873213988024512286270964608502444597112110163392131757813461977030270733012385926751192637938686124570227538910606279104888073013, 11308837998867241929817950595621831002334468993828126438599805989088017326675963100044309448653090403889186401929445861220402556074702741108929442867300279, 9184622887414209361516593101129556569811888214607556630094969763910426953786020755838094184972397480276666170685926425137063559394969166216392939257091541, 12896400069515890897430087815982545671830645201023665112429779640768899091287291452408369445919464144390726200808875066389240126909811239597092893733457339, 11227025698697471809912850435140886785315702278826761054472525227951791647003561270585720797267604996360933395122286757099101227901032364782594523739698877, 8162123490656317490361880020667919072708091053716891870691544217490126444997503404094174246087938828993696335191488583306443577208796794274099282013427247, 13366989889442670291461262313757977600095962057470863475519088648267301129719953368943419562144276679400967122727554764013132918505564677243979978807323041, 9920857455945408588203972193444437533164351309299040911469275059092031755811492460585653948481522995557801781838215407648572999358456612525812067538372579, 7139402473546047825312503780125417567716958846513076797328672521987900978293260385267945187604725349720103672258987935569856239987227455748213833342843243, 13108142660294572752252393081421368493392921884487755391460006730258159004638343897340537616297811742032405724656497443006056456690449881719305597286675631, 13276762958403786077380090195631980415297280849950287990717193547481553124160398455403123819234755237450529090601858784999113026218918277529515287668651121, 12463094640052886550696551772104539361264529587569204472038955376345085195998921095774583176899949596998985033050547755235409943131811058035802010421860899, 11307743131694864808301935844724645695851330736969875190167422024500753079857478680029193758960169072890576310607053767920339034290416580654771095674487943, 10053742503547378455068966704402695956702795408343604912294923217443553169726438945982031485796964462946592530592946335569560364464958066521486506177193131, 9703695763451799125258961776229325510814289358679213305418559381901496449849584244211834872313767844996255556721041007654625153809128987422992102292472533, 8148189465927721940294369879439913703690047528695196368949823197675716174991296513758196009346701553643721225250628151384047219921709201619262393792138023, 9114150910964237818418367840207724528917302406836157928223872622442928604249864486858755737149640683259834299165900696585038569188627682022002709058902291, 12273514376180781903469287345188404399033432117915094289694407562166649079228640510678711431664410226301556172582177240184695103942141430877677144285616059, 8355005721684425514882933910286584148305344580589623112959517428993968438533866906223777778058096962333203237111245328436600994120168924143849685728268811, 8957883838807471492147480816683526636019698464133185237668243268667169800811696770484487123560197988448434475112352005768286417529319182162245840523697001, 12168542584724814356632409768687396920143300559579648963851924568387314914334359305942685551210180448419674060219496395116081866784918059237133414041227833, 12285935007930825571672128346804313607196190465690759870758278705086034778808662886056460827935986285259185071514490942831585313190946386878622608868345563, 7719913817859572377164973343651155934060296607908537845256755472465025202751239980758950094865067751407889569369974011139801401586939119147773466111699913]cs = [3911325901261770731066343727353093385607196883601022244426857460074338420692610012414571623512152485474248169220030587839849722757773859682519433853455847, 4198555117325325874584019691418573071733167640213933749582347442518997588452211673143722179281773602455507001395983681009769848414007206268682184816168744, 4422173666634983234895098798813962037875417568235708524339826709271381748884936178371767574064794177416615710120223914725873239836121654705208614576413533, 3540260422555697887869627546208164711550015909378340105077652177481959576550678379723450981807556863572610759824660630418670546203733170058626755080797998, 6451498467498935201092514865627931677091078787997097414208430992183264950579022373372254486595458117887305393317663712337699331503725124287017134808484874, 3439629581963524351810430910737336124616316641656190641248434504621774235943514617301857917041111617104850245148746427180069743940612560718213177903427306, 4279468191481832212496939242093486044278976937965085475567008228061184947513156012369586970486543083130565628906296600553024574099481246534878242920637212, 4102135455518061133919027670571325279976222647984452353051395864554309521223498761823084717077102213648612826513661629599971609555235760152049549057234342, 329051927890365028889097463563711966673066795688728876214731188783168691555262156515161429328581094087585127929869064685419149676592073496155898360311360, 1674347209896897571502352451063188834938904430329951752111921115230349947823188121972980025563878887201507629419811736910690965020923751424101521816057970, 4779084317811375050159574994746297486592271247137823471375199626788956576998627181220489952507937768042501203098391966702297812537463211799837921684467541, 5240331815784322792144549873873658636726233093228415489098002982220769676718681132737794994708716389174162820721646744776624413735318240597745363490427584, 2689716894922604875455207695253665212853470308341743040957367957727155614199743562225147359614514189877983156892749669804800163252617480446565479990148021, 449708769594599088851244243076921016853502252396793496349534051273454215985560340288452398756880916680293627457774430655982228613348249480600180821975835, 1584603978331289335352997151059666773277943458357161051278658090420067023680231414255557805410288144092653121568766136372728095300982743309696347031121424, 4874260053151700374809337053763032489184725334196495160358275038586824027920238733886703163018450814805937363825223459277373073591021082276610135118976834, 3524374131362906900545297291947110177298862564718451821839794960169356082042548386553363480921097452902723033854749443288682983558847052843293666815425196, 6544123591499569232021913370293570477776709315008783531720886545784773471486769240711262562401683145937715612435213816372680189321141928790509490282629891, 4873861166228118967099569086478548167127431415017791678812419676791754466935832034870862000658789609084166891933970013849850146718379819943737269970654866, 4100817874436703071716655163972145036104985973164830547825929590871920825981241934633977227547934514142660786061291026657802357404024236287955309372489516, 343238276681348130286495167739162902430650061145485619903964358840996341335935043000395056684771452815629410388891486531126938900311458948803147120186532, 2683710724350412998770392318832434885304538325033159937379489319924346689197445720734209841902612235485016866254994045969716413020197296428323832404151182, 5909464641105704179999104311562416363090166762341644691188169716182958971270396007422581429813172933930581475771306034495224054972725230757675444731953480, 105593489999747649490909471306354863316673821363863362258853043970534652401274789197677558215188249074837829003335733211890211648501689656345824858507373, 4992379366542645691375959247465888889778118153982142100956809440855745659745235576280578316185469306620017845690312554043770651058126536040173113949524396, 6533456398244789907636779407045515567135195474284185379689518387558345997627435421582437390053234675991361808532278264077968540197407743744279106871716267, 5169360398767270275853790242315213671633880428212603766301308853363063092609582572957561138022806887895634140899640025570759919257615537375706008159680239, 203310740924699994885931266978520636166917734618272844754878785050509801614513144739164450834936178065792112797202959106365282699245578309060905297742706, 3143563289239398127009575193211845399079310618985464994769603542400451633289266080869317336163844517539211542909055869608349639432145332113320465388067087, 4016252180207572047405081190649590978593306403200098541033213590567723751195926093369984531729148621419589009515870336049849542537363832071754623330736088]enc = 1315637864146686255246675143589215932218700984880749264689270214639479160648747323586062096067740047809798944996253169402675772469028914904598116394230426ss=[1444695997149492190325503358748907180896428744501435959012446197804471238996228693169795874437240656170107638535797004901, 1710106002173551002425444054140394178956124023376657957303230765508377089074717746465653815466763654648249527857825569029, 2055313300434754785614061534661234769322543457763273072311107482412288908659564309179643251560799446038081677516598963457, 2529893752644237783483797815212946495982855556933204694011832676840091910035653685416019963608166318536749345810876453771, 2529138628117798443470937234045077945473928204906198619005287365776711527156367496383631463561676109741862230251586143377, 2262110335813452474430699656412885234503426852605393691899881796634211611052330735315181940758828054398894455017113733227, 2121889637450522029350552877626679809458662297228865521642554573119772081854990312156453774280770474194162502389497160327, 2529142548180563996394639773713532833480273727306125086719935756161917184911736806616267916075735106590544780324467585621, 1305329295536404276170448056500700469825272137020946460143963140200353157377196505556280067991447170875038122866415550101, 1552852098086060808737139123645915631099187828325664479373402352780546739207516108015428990851489119938061929818491926611, 1791104999803661806603955436215385390826508049741363470424060526111730352962999232609779584743853648363257676913487057757, 1899442479566327507595284152198923816070020299280413329026247522765072323119884753949208875377108001657197781777679291871, 1453541167592343188338822229691660044736912312708428492831729087255748263545506909467533920598337452593734393704376978807, 1839970255647517988033776502403781838348352314214922889121617450060735210741294955388142534936822274443404021805803333703, 1912160881436961130805854105580691921433605240682869508192604979038043884642959974735162453664737011078276186132003267537, 2543565462805293682479626661848772865479251641709980622442153819428251437133653745822570184749929330644293218076375940297, 2483083156651635774502843350477278413827965814754343098791424022880695703529884053363101276861390834327295178464586090169, 2003169101542395781256109850378099343661620656525906226012777618825679882882750121108967747380040440812305500025030472703, 1495306582962644344763635303973344887376634002664321023099433581011613385215984473933899539552759121449556619118213926953, 1475475640507405435263556560927151140961838107291429033550823738085598452588645697451453622811307836240178487270066202731, 1585296258758653869729779396633477768935787077644413518874111953612262499991020378795132976171831363612740565577673589949, 1751870981277054153889475362865184270808672777814739187606382420502953249942908536146994775691865449715881103437411562697, 2229385019858443633247567841668512226312552028112872103049568509800432132563139223600501334488455486995847787457023057543, 2509522757833822636876029295601980862244548996153272433687613093337042904569711801805004013230589715380175225102878772429, 1378538686540733061307578409608662896663843431656273949667551098986968433993734090533525999772678987014720821134447883279, 1615745464810222578868113006917238415594773977456189037245148298498578637163332628299020222221658719347173123797381998597, 2064151464294100789516756482456818746190321203565732371731029967136921201410297069827915522687620140104021460523804416353, 1711545496198775131056637405659683132417828376528113270088200929297233962942202546621239829931304134031695960814215807973, 1455761879282217336477189039622363054351048993520687962567785409775020556422692091664440576775863933336882803763246548923, 1880891423536411979565374334582143474888275578342367502429189125513290153271930355071969557105539679922217905887177950249]prime=pma=rsres = csW = matrix(ZZ, ma)cc = vector(ZZ, res)#LWE求解x# Babai&#x27;s Nearest Plane algorithmdef Babai_closest_vector(M, G, target): small = target for _ in range(5): for i in reversed(range(M.nrows())): c = ((small * G[i]) / (G[i] * G[i])).round() small -= M[i] * c return target - smallA1 = matrix.identity(column)Ap = matrix.identity(row) * primeB = block_matrix([[Ap], [W]])lattice = IntegerLattice(B, lll_reduce=True)print(&quot;LLL done&quot;)gram = lattice.reduced_basis.gram_schmidt()[0]target = vector(ZZ, res)re = Babai_closest_vector(lattice.reduced_basis, gram, target)# print(&quot;Closest Vector: &#123;&#125;&quot;.format(re))R = IntegerModRing(prime)M = Matrix(R, ma)M = M.transpose()ingredients = M.solve_right(re)#求出x后利用PH算法对flag进行还原，因为发现p-1可以分解，p是光滑阶# x=6789891305297779556556571922812978922375073901749764215969003309869718878076269545304055843125301553103531252334876560433405451108895206969904268456786139x=int(ingredients[0])print(x)m=xc=encn=pdef r(h, g, N, p, qi): Zp = Zmod(p) h = pow(h, N//qi, p) g = pow(g, N//qi, p) ri = discrete_log(Zp(h), Zp(g)) return int(ri)m=xc=encn=ptmp_list=[2,3,193,877,2663,662056037,812430763,814584769,830092927,849943517,969016409,1000954193,1022090869,1048277339]r_list = []for qi in tmp_list: tmp = r(c,m,n-1,n,qi) print(tmp) r_list.append(tmp)x = crt(r_list, tmp_list)module = 1for i in tmp_list: module *= iwhile True: if int(x).bit_length()&gt;304: print(&#x27;fail&#x27;) break if int(pow(m, x, n))==c: print(&#x27;x =&#x27;, x) print(long_to_bytes(x)) break x += module#b&#x27;flag&#123;70b1b709ce431682addb581596320007&#125;&#x27; NKCTF2023 babyRSA 题目 1234567891011121314151617181920212223nbit = 512flag=&#x27;****************************&#x27;p=getPrime(nbit)q=getPrime(nbit)e=65537n=p*qm= bytes_to_long(bytes(flag.encode()))P = pow(m,p,n)Q = pow(m,q,n)N=P*Qphi_N=(P-1)*(Q-1)d=inverse(e,phi_N)dP=d%(P-1)print(&#x27;n = &#x27;,n)print(&#x27;N = &#x27;,N)print(&#x27;dP = &#x27;,dP)n = 114101396033690088275999670914803472451228154227614098210572767821433470213124900655723605426526569384342101959232900145334500170690603208327913698128445002527020347955300595384752458477749198178791196660625870659540794807018881780680683388008090434114437818447523471527878292741702348454486217652394664664641N = 1159977299277711167607914893426674454199208605107323826176606074354449015203832606569051328721360397610665453513201486235549374869954501563523028914285006850687275382822302821825953121223999268058107278346499657597050468069712686559045712946025472616754027552629008516489090871415609098178522863027127254404804829735621706042266140637592206366042515190385496909533329383212542170504864473944657824502882014292528444918055958758310544435120502872883857209880723535754528096143707324179005292445100655695427777453144657819474805882956064292780031599790769618615908501966912635232746588639924772530057835864082951499028dP = 33967356791272818610254738927769774016289590226681637441101504040121743937150259930712897925893431093938385216227201268238374281750681609796883676743311872905933219290266120756315613501614208779063819499785817502677885240656957036398336462000771885589364702443157120609506628895933862241269347200444629283263 题目分析 题目后半部分是 dp 泄露，通过 N、e、dP 可求出 P、Q 1234567for k in range(1,e): if (e*dP-1)%k == 0: P=(e*dP-1)//k + 1 if N%P == 0: print(P) breakQ=N//P 法一 之后要通过\\(P = m^p\\;mod\\;n\\)与\\(Q=m^q\\; mod \\;n\\)来求解 m，下面进行一些数学推导 \\[c_1^q=m^{pq}\\;mod\\;n\\] \\[c_1^{pq}=c_2^{p^2}\\;mod\\;n\\] \\[c_1^{pq}=c_2^{p^2}\\;mod\\;p\\] 根据费马小定理转换可得 \\[c_1^n=c_2^p\\;mod\\;p\\] \\[gcd(c_1^n-c_2,n)\\;=\\;p\\] 求出 p 和 q 后，使用 crt 即可求得 m 12345678c1=(pow(P,n,n)-Q)%np=GCD(c1,n)q=n//pmp=P%pmq=Q%qm=CRT([mp,mq],[p,q])print(long_to_bytes(m))# NKCTF&#123;Th1S_a_babyRSA_y0u_are_tql!!!&#125; 法二 通过推导将原式转换为 \\[PQ=(k_1p+m)(k_2q+m)\\] \\[m(P+Q)=2m^2+(k_1p+k_2q)m\\] \\[PQ-m(P+Q)+m^2=k_1k_2n\\] \\[PQ-m(c_1+c_2)+m^2=0\\;mod\\;n\\] 12345PR.&lt;m&gt; = PolynomialRing(Zmod(n))f = P*Q-m^2-m*(P-m+Q-m)f = f.monic()m = f.small_roots(X=2^400, beta=0.4)print(long_to_bytes(int(m[0]))) ezRSA 已知 phi 分解 n,后续同 babyRSA 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from math import gcdfrom math import isqrtfrom random import randrangedef factorize_multi_prime(N, phi): &quot;&quot;&quot; Recovers the prime factors from a modulus if Euler&#x27;s totient is known. This method works for a modulus consisting of any number of primes, but is considerably be slower than factorize. More information: Hinek M. J., Low M. K., Teske E., &quot;On Some Attacks on Multi-prime RSA&quot; (Section 3) :param N: the modulus :param phi: Euler&#x27;s totient, the order of the multiplicative group modulo N :return: a tuple containing the prime factors &quot;&quot;&quot; prime_factors = set() factors = [N] while len(factors) &gt; 0: # Element to factorize. N = factors[0] w = randrange(2, N - 1) i = 1 while phi % (2 ** i) == 0: sqrt_1 = pow(w, phi // (2 ** i), N) if sqrt_1 &gt; 1 and sqrt_1 != N - 1: # We can remove the element to factorize now, because we have a factorization. factors = factors[1:] p = gcd(N, sqrt_1 + 1) q = N // p if is_prime(p): prime_factors.add(p) elif p &gt; 1: factors.append(p) if is_prime(q): prime_factors.add(q) elif q &gt; 1: factors.append(q) # Continue in the outer loop break i += 1 return tuple(prime_factors)e=65537n = 8836130216343708623415307573630337110573363595188748983290313549413242332143945452914800845282478216810685733227137911630239808895196748125078747600505626165666334675100147790578546682128517668100858766784733351894480181877144793496927464058323582165412552970999921215333509253052644024478417393146000490808639363681195799826541558906527985336104761974023394438549055804234997654701266967731137282297623426318212701157416397999108259257077847307874122736921265599854976855949680133804464839768470200425669609996841568545945133611190979810786943246285103031363790663362165522662820344917056587244701635831061853354597phi = 8836130216343708623415307573630337110573363595188748983290313549413242332143945452914800845282478216810685733227137911630239808895196748125078747600505622503351461565956106005118029537938273153581675065762015952483687057805462728186901563990429998916382820576211887477098611684072561849314986341226981300596338314989867731725668312057134075244816223120038573374383949718714549930261073576391501671722900294331289082826058292599838631513746370889828026039555245672195833927609280773258978856664434349221972568651378808050580665443131001632395175205804045958846124475183825589672204752895252723130454951830966138888560a=factorize_multi_prime(n,phi) ez_math 题目 12345678910111213141516171819202122232425262728293031323334353637383940414243from Crypto.Util.number import getPrime, bytes_to_longfrom secret import BITS, hints, flagp = getPrime(BITS)q = getPrime(BITS)n = p * qprint(f&#x27;n = &#123;n&#125;&#x27;)e = 0x10001c = pow(bytes_to_long(flag), e, n)print(f&#x27;c = &#123;c&#125;&#x27;)print(&#x27;Give you some boring pows:&#x27;)for i in range(len(hints)): print(hints[i])&quot;&quot;&quot;n = 369520637995317866367336688225182965061898803879373674073832046072914710171302486913303917853881549637806426191970292829598855375370563396182543413674021955181862907847280705741114636854238746612618069619482248639049407507041667720977392421249242597197448360531895206645794505182208390084734779667749657408715621c = 324131338592233305486487416176106472248153652884280898177125443926549710357763331715045582842045967830200123100144721322509500306940560917086108978796500145618443920020112366546853892387011738997522207752873944151628204886591075864677988865335625452099668804529484866900390927644093597772065285222172136374562043Give you some boring pows:pow(6, 42762902032363446334121451790132830028099011269558028556333775251728898854654431095595000922138958455510196735338223430882428451914478079186797153527810555787441234842366353864053114538165236037883914332840687123514412294276743506313011532002136735343280737244020115917460801848337792582496228600926958548903290, n) = 4pow(6, 141997416965295486849546892322458652502850390670128808480582247784728456230996812361056958004801816363393016360646922983916999235770803618904474553309200419301820603229504955218189709387942156848904968053547462302189568831762401075340100029630332409419313772378068180267756675141584884876543484516408660699471038, n) = 9pow(6, 163378867981477210016607618217525067516899896304907822758749135410592905658324027908854458465871295591148114728316034699358213461728042658497873130073105697195541220650688132150216266657024774867846925219967805863946774978900772828496605795631400777090954141000078238226487076065753781167791598816872139973922682, n) = 3pow(5, 101651508435846472131121026992982127175369332865677196032272241712711171024515826370577416844824734811581351106736224929238579734879671732717639124571916168742336862493284572465162318403582113621582374924091725060981390318743531229548188092491836655143124663368239422819562367919547196053790207486164506763679128, n) = 4pow(8, 7202269322818255506843028035725052687541091567764933235328308385449791332345247877549905289072216053144576876979686287212194040101112899704499548530779540409356827298148385589812450437990490353926475147376495772639210184768544932563432306664067058309318707174880146258394471096033723193568453520897758319446472, n) = 3pow(6, 64144353048545169501182177685199245042148516904337042834500662877593348281981646643392501383208437683265295103007335146323642677871717118780195730291715833681161852263549530796079671807247854056825871499261030685271618441415115259469517298003205103014921105866030173876191202772506688873744342901390437823354935, n) = 8pow(6, 21381451016181723167060725895066415014049505634779014278166887625864449427327215547797500461069479227755098367669111715441214225957239039593398576763905277893720617421183176932026557269082618018941957166420343561757206147138371753156505766001068367671640368622010057958730400924168896291248114300463479274451645, n) = 2pow(4, 21606807968454766520529084107175158062623274703294799705984925156349373997035743632649715867216648159433730630939058861636582120303338699113498645592338621228070481894445156769437351313971471061779425442129487317917630554305634797690296919992201174927956121524640438775183413288101169580705360562693274958339416, n) = 9pow(2, 21606807968454766520529084107175158062623274703294799705984925156349373997035743632649715867216648159433730630939058861636582120303338699113498645592338621228070481894445156769437351313971471061779425442129487317917630554305634797690296919992201174927956121524640438775183413288101169580705360562693274958339417, n) = 6pow(4, 10803403984227383260264542053587579031311637351647399852992462578174686998517871816324857933608324079716865315469529430818291060151669349556749322796169310614035240947222578384718675656985735530889712721064743658958815277152817398845148459996100587463978060762320219387591706644050584790352680281346637479169708, n) = 3pow(9, 3293982057350410278459882519024200329089724149803879577174733206141551016681048848343176690789446255513117465644006032807116613436995145441651711865811812905401261777042165657533800465011922458688696664211216129846590488003282750224539553623014598025837108471148806368738631086225250952573439068109703953523338, n) = 4pow(2, 43213615936909533041058168214350316125246549406589599411969850312698747994071487265299431734433296318867461261878117723273164240606677398226997291184677242456140963788890313538874702627942942123558850884258974635835261108611269595380593839984402349855912243049280877550366826576202339161410721125386549916678832, n) = 9pow(7, 156359509651684605051402965560382969488421316701585527115005130492947292379802933549188085059602557600903593831240316597311439285149968787780538126741092612405335349622445040578126369183536683733294143156965518222696624206221060030916594302284630706642066420353822195108928341123726471513256217857861184609387726, n) = 9pow(7, 170559914324671769117535654836487226009685359320636182075960576764702323732727088502920021993271666209903403463612731506055433486417625242935904916789051793747298593847158174830184596554822038310041512771676833824200302666130102306284852931958549925702330464987955245647072909056824574486147965487598401928881026, n) = 3pow(8, 123173545998439288789112229408394321687299601293124558024610682024304903390434162304434639284627183212602142063990097609866285125123521132060847804558007316726174558714580872721495215950738261924525921590925432950469320750692763054435407707754979429841729673081392197456811651326615118306026475411557079498916218, n) = 4pow(2, 21606807968454766520529084107175158062623274703294799705984925156349373997035743632649715867216648159433730630939058861636582120303338699113498645592338621228070481894445156769437351313971471061779425442129487317917630554305634797690296919992201174927956121524640438775183413288101169580705360562693274958339416, n) = 3pow(3, 6587964114700820556919765038048400658179448299607759154349466412283102033362097696686353381578892511026234931288012065614233226873990290883303423731623625810802523554084331315067600930023844917377393328422432259693180976006565500449079107246029196051674216942297612737477262172450501905146878136219407907046676, n) = 4pow(7, 146900004342901005519726059203387905743111231159623333298786259340649199259667124880775175860427705602975071010583553281005991812801779033020769274211420710213704563866848310994325033574484679477677016014418321661821714582236428708141287327064859146436371562752616380650770729341741997594308364878898526065859626, n) = 4pow(5, 172192380036714150788905270808196199818277334366508682218739812159577144024191963252552116624193235000074634457087111471641800814071769221933018962135503876997163938949365614056098717522475180216291316295788774044033481065993544994610614082708563841846852650913646728169671510827052772868386414581035580266356334, n) = 3pow(8, 68789042322037899901399142739922213531190892214327212247633649397602243027562329029767224931385807659445647908974735092145336602662873465734923450809783198772444106655438821950560058413359621316189435942839212247873870560114926459781136160541556773230183543715576244986800296759341282346581691226676298068904581, n) = 6pow(5, 159624441075769368394142197503800917105605266793330527400563601282696932962732683048452274321445695181246055818189076528484173940458256745774766217433996778905066039826859919029954611118842967545793750205189398662362981005947945407568116603784658538931110792205205160154125544664182868277733116044735541284338342, n) = 9pow(8, 14404538645636511013686056071450105375082183135529866470656616770899582664690495755099810578144432106289153753959372574424388080202225799408999097061559080818713654596296771179624900875980980707852950294752991545278420369537089865126864613328134116618637414349760292516788942192067446387136907041795516638892944, n) = 9&quot;&quot;&quot; 根据一个 hint 得到 \\[8^x\\;mod\\;n=4\\] \\[2^{3x-2}=1\\;mod\\;n\\] 由费马小定理得，3x-2=phi 123456789from Crypto.Util.number import *import gmpy2n = 369520637995317866367336688225182965061898803879373674073832046072914710171302486913303917853881549637806426191970292829598855375370563396182543413674021955181862907847280705741114636854238746612618069619482248639049407507041667720977392421249242597197448360531895206645794505182208390084734779667749657408715621c = 324131338592233305486487416176106472248153652884280898177125443926549710357763331715045582842045967830200123100144721322509500306940560917086108978796500145618443920020112366546853892387011738997522207752873944151628204886591075864677988865335625452099668804529484866900390927644093597772065285222172136374562043e=65537x=123173545998439288789112229408394321687299601293124558024610682024304903390434162304434639284627183212602142063990097609866285125123521132060847804558007316726174558714580872721495215950738261924525921590925432950469320750692763054435407707754979429841729673081392197456811651326615118306026475411557079498916218phi=3*x-2print(long_to_bytes(pow(c,gmpy2.invert(e,phi),n)))# b&#x27;NKCTF&#123;d15cr373_L0g_15_R3DuC710n_f0R_f4C70r1nG&#125;&#x27; ez_polynomial 题目 1234567891011121314151617181920212223#sagefrom Crypto.Util.number import *flag = list(bytearray(&#x27;&#x27;))p = getPrime(16)R.&lt;y&gt; = PolynomialRing(GF(p))while True: P1 = R.random_element(degree=(ZZ.random_element(len(flag), 2*len(flag)))) Q1 = R.random_element(degree=(ZZ.random_element(len(flag), 2*len(flag)))) if P1.is_irreducible() and Q1.is_irreducible(): P = P1 Q = Q1 breake = 65537N = P*QS.&lt;x&gt; = R.quotient(N)c = S(flag) ^ eprint(&quot;P:&quot; + str(p) + &quot;\\n&quot;)print(&quot;N:&quot; + str(N) + &quot;\\n&quot;)print(&quot;C:&quot; + str(c))#P:40031#N:24096*y^93 + 38785*y^92 + 17489*y^91 + 9067*y^90 + 1034*y^89 + 6534*y^88 + 35818*y^87 + 22046*y^86 + 12887*y^85 + 445*y^84 + 26322*y^83 + 37045*y^82 + 4486*y^81 + 3503*y^80 + 1184*y^79 + 38471*y^78 + 8012*y^77 + 36561*y^76 + 19429*y^75 + 35227*y^74 + 10813*y^73 + 26341*y^72 + 29474*y^71 + 2059*y^70 + 16068*y^69 + 31597*y^68 + 14685*y^67 + 9266*y^66 + 31019*y^65 + 6171*y^64 + 385*y^63 + 28986*y^62 + 9912*y^61 + 10632*y^60 + 33741*y^59 + 12634*y^58 + 21179*y^57 + 35548*y^56 + 17894*y^55 + 7152*y^54 + 9440*y^53 + 4004*y^52 + 2600*y^51 + 12281*y^50 + 22*y^49 + 17314*y^48 + 32694*y^47 + 7693*y^46 + 6567*y^45 + 19897*y^44 + 27329*y^43 + 8799*y^42 + 36348*y^41 + 33963*y^40 + 23730*y^39 + 27685*y^38 + 29037*y^37 + 14622*y^36 + 29608*y^35 + 39588*y^34 + 23294*y^33 + 757*y^32 + 20140*y^31 + 19511*y^30 + 1469*y^29 + 3898*y^28 + 6630*y^27 + 19610*y^26 + 11631*y^25 + 7188*y^24 + 11683*y^23 + 35611*y^22 + 37286*y^21 + 32139*y^20 + 20296*y^19 + 36426*y^18 + 25340*y^17 + 36204*y^16 + 37787*y^15 + 31256*y^14 + 505*y^13 + 27508*y^12 + 20885*y^11 + 32037*y^10 + 31236*y^9 + 7929*y^8 + 27195*y^7 + 28980*y^6 + 11863*y^5 + 16025*y^4 + 16389*y^3 + 570*y^2 + 36547*y + 10451#C:3552*x^92 + 6082*x^91 + 25295*x^90 + 35988*x^89 + 26052*x^88 + 16987*x^87 + 12854*x^86 + 25117*x^85 + 25800*x^84 + 30297*x^83 + 5589*x^82 + 23233*x^81 + 14449*x^80 + 4712*x^79 + 35719*x^78 + 1696*x^77 + 35653*x^76 + 13995*x^75 + 13715*x^74 + 4578*x^73 + 37366*x^72 + 25260*x^71 + 28865*x^70 + 36120*x^69 + 7047*x^68 + 10497*x^67 + 19160*x^66 + 17939*x^65 + 14850*x^64 + 6705*x^63 + 17805*x^62 + 30083*x^61 + 2400*x^60 + 10685*x^59 + 15272*x^58 + 2225*x^57 + 13194*x^56 + 14251*x^55 + 31016*x^54 + 10189*x^53 + 35040*x^52 + 7042*x^51 + 29206*x^50 + 39363*x^49 + 32608*x^48 + 38614*x^47 + 5528*x^46 + 20119*x^45 + 13439*x^44 + 25468*x^43 + 30056*x^42 + 19720*x^41 + 21808*x^40 + 3712*x^39 + 25243*x^38 + 10606*x^37 + 16247*x^36 + 36106*x^35 + 17287*x^34 + 36276*x^33 + 1407*x^32 + 28839*x^31 + 8459*x^30 + 38863*x^29 + 435*x^28 + 913*x^27 + 36619*x^26 + 15572*x^25 + 9363*x^24 + 36837*x^23 + 17925*x^22 + 38567*x^21 + 38709*x^20 + 13582*x^19 + 35038*x^18 + 31121*x^17 + 8933*x^16 + 1666*x^15 + 21940*x^14 + 25585*x^13 + 840*x^12 + 21938*x^11 + 20143*x^10 + 28507*x^9 + 5947*x^8 + 20289*x^7 + 32196*x^6 + 924*x^5 + 370*x^4 + 14849*x^3 + 10780*x^2 + 14035*x + 15327 题解 多项式 RSA，给定 n、e、c 1234567891011121314151617181920import gmpy2p=40031P.&lt;y&gt;=PolynomialRing(Zmod(p))x=yN=24096*y^93 + 38785*y^92 + 17489*y^91 + 9067*y^90 + 1034*y^89 + 6534*y^88 + 35818*y^87 + 22046*y^86 + 12887*y^85 + 445*y^84 + 26322*y^83 + 37045*y^82 + 4486*y^81 + 3503*y^80 + 1184*y^79 + 38471*y^78 + 8012*y^77 + 36561*y^76 + 19429*y^75 + 35227*y^74 + 10813*y^73 + 26341*y^72 + 29474*y^71 + 2059*y^70 + 16068*y^69 + 31597*y^68 + 14685*y^67 + 9266*y^66 + 31019*y^65 + 6171*y^64 + 385*y^63 + 28986*y^62 + 9912*y^61 + 10632*y^60 + 33741*y^59 + 12634*y^58 + 21179*y^57 + 35548*y^56 + 17894*y^55 + 7152*y^54 + 9440*y^53 + 4004*y^52 + 2600*y^51 + 12281*y^50 + 22*y^49 + 17314*y^48 + 32694*y^47 + 7693*y^46 + 6567*y^45 + 19897*y^44 + 27329*y^43 + 8799*y^42 + 36348*y^41 + 33963*y^40 + 23730*y^39 + 27685*y^38 + 29037*y^37 + 14622*y^36 + 29608*y^35 + 39588*y^34 + 23294*y^33 + 757*y^32 + 20140*y^31 + 19511*y^30 + 1469*y^29 + 3898*y^28 + 6630*y^27 + 19610*y^26 + 11631*y^25 + 7188*y^24 + 11683*y^23 + 35611*y^22 + 37286*y^21 + 32139*y^20 + 20296*y^19 + 36426*y^18 + 25340*y^17 + 36204*y^16 + 37787*y^15 + 31256*y^14 + 505*y^13 + 27508*y^12 + 20885*y^11 + 32037*y^10 + 31236*y^9 + 7929*y^8 + 27195*y^7 + 28980*y^6 + 11863*y^5 + 16025*y^4 + 16389*y^3 + 570*y^2 + 36547*y + 10451C=3552*x^92 + 6082*x^91 + 25295*x^90 + 35988*x^89 + 26052*x^88 + 16987*x^87 + 12854*x^86 + 25117*x^85 + 25800*x^84 + 30297*x^83 + 5589*x^82 + 23233*x^81 + 14449*x^80 + 4712*x^79 + 35719*x^78 + 1696*x^77 + 35653*x^76 + 13995*x^75 + 13715*x^74 + 4578*x^73 + 37366*x^72 + 25260*x^71 + 28865*x^70 + 36120*x^69 + 7047*x^68 + 10497*x^67 + 19160*x^66 + 17939*x^65 + 14850*x^64 + 6705*x^63 + 17805*x^62 + 30083*x^61 + 2400*x^60 + 10685*x^59 + 15272*x^58 + 2225*x^57 + 13194*x^56 + 14251*x^55 + 31016*x^54 + 10189*x^53 + 35040*x^52 + 7042*x^51 + 29206*x^50 + 39363*x^49 + 32608*x^48 + 38614*x^47 + 5528*x^46 + 20119*x^45 + 13439*x^44 + 25468*x^43 + 30056*x^42 + 19720*x^41 + 21808*x^40 + 3712*x^39 + 25243*x^38 + 10606*x^37 + 16247*x^36 + 36106*x^35 + 17287*x^34 + 36276*x^33 + 1407*x^32 + 28839*x^31 + 8459*x^30 + 38863*x^29 + 435*x^28 + 913*x^27 + 36619*x^26 + 15572*x^25 + 9363*x^24 + 36837*x^23 + 17925*x^22 + 38567*x^21 + 38709*x^20 + 13582*x^19 + 35038*x^18 + 31121*x^17 + 8933*x^16 + 1666*x^15 + 21940*x^14 + 25585*x^13 + 840*x^12 + 21938*x^11 + 20143*x^10 + 28507*x^9 + 5947*x^8 + 20289*x^7 + 32196*x^6 + 924*x^5 + 370*x^4 + 14849*x^3 + 10780*x^2 + 14035*x + 15327e=65537q1=N.factor()[0][0]q2=N.factor()[1][0]phi = (p**q1.degree() - 1) * (p**q2.degree() - 1)assert gcd(e, phi) == 1d = gmpy2.invert(e, phi)m=pow(C,d,N)print(m)flag = &#x27;&#x27;.join([chr(i) for i in m])print(flag)# NKCTF&#123;We_HaV3_n0th1ng_But_dr3amS&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"DUTCTF2023","slug":"DUTCTF2023","date":"2023-03-28T02:05:45.000Z","updated":"2023-03-28T09:29:06.114Z","comments":true,"path":"2023/03/28/DUTCTF2023/","link":"","permalink":"https://sch01ar.github.io/2023/03/28/DUTCTF2023/","excerpt":"","text":"DUTCTF2023wp 写在前面 仔细一想自己学 CTF 也一年了，纪念一下最后一次参加校赛 🥹，明年可就是出题人了 🤓。但是感觉一年以来荒废了很多时间，在很多方面对题目不熟悉，总跑偏，甚至是自己复现过的一些方法都没意识到（hint 太到位了 😭）。 Crypto 第一次 ak，好爽 😭 *老滚五 百度搜龙语，耐心对着找就出了DUTCTF&#123;YOU_ARE_A_REAL_DRAGONBORN&#125; *神奇的短信 诺基亚手机，9 键，第一位代表哪个键，第二个代表第几个字母，DUTCTF&#123;SCREW&#125; 随机数的力量 可先了解一下 MT19937 伪随机数原理，然后看一下破解方法，对于梅森旋转算法之前博客也详细推导过。这里针对题目分析一下，首先 ban 掉了 32 位的预测方法，通过了解到，randcrack库实际上是通过收取特定位数来实现预测，例如 32 位数，就需要 624 个，那么如果使用 64 位数，应该就需要 312 个。后续只要对收取的数字进行一下处理，转成 624 个 32 位数即可。 这里还有一个疑问就是，最大的 64 位数是\\(2^{64}-1\\)，但是如果传\\(name=2^{64}-1\\)就无法预测，而改成其余略小一点的 64 位数即可。 exp 12345678910111213141516171819202122232425262728293031323334353637from pwn import *from Crypto.Util.number import *from randcrack import RandCrackr=remote(&quot;210.30.97.133&quot;,&#x27;28032&#x27;)r.recvuntil(b&#x27;:&#x27;)name=2**64-2name=long_to_bytes(name)print(name)r.send(name)r.recv()count=0file = open(&quot;random.txt&quot;,&quot;w&quot;)while count&lt;312: r.send(b&#x27;1&#x27;) r.recvuntil(b&#x27;:&#x27;) num=int(r.recvuntil(b&#x27;\\n&#x27;)[:-1]) count+=1 file.write(str(num)+&quot;\\n&quot;)file.close()print(&quot;finish&quot;)with open(r&#x27;random.txt&#x27;, &#x27;r&#x27;) as f: l = f.readlines()l = [int(i.strip()) for i in l]t = []for i in range(len(l)): t.append(l[i] &amp; (2 ** 32 - 1)) t.append(l[i] &gt;&gt; 32)rc = RandCrack()print(len(t))for i in t: rc.submit(i)guess=rc.predict_getrandbits(64)r.send(str(guess).encode())print(r.recvline())# DUTCTF&#123;61cdf3eb-e4d9-4613-b533-ff4f7fb6c80a&#125; shamir 直接找脚本跑，具体如何恢复 a0 系数就不细说了。之前 hitcon 有个也是 shamir 的题，也挺有意思的。babysss 12345678910111213141516171819202122from Crypto.Util.number import *P = PolynomialRing(GF(p), &#x27;x&#x27;)ret = P(0)for x, y in shares: r = P(1) * y for xx, yy in shares: if x != xx: r = r * P((0 - xx) / (x - xx)) ret = ret + rprint(ret)P = PolynomialRing(GF(p), &#x27;x&#x27;)ret = P(0)for x, y in shares: r = P(1) * y for xx, yy in shares: if x != xx: r = r * P(&#x27;(x - %d) / (%d - %d)&#x27; % (xx, x, xx)) ret = ret + rprint(long_to_bytes(int(ret[0])))# b&#x27;DUTCTF&#123;23935a6d-a94d-4905-845a-aec9c8646e4d&#125;&#x27; ECC1 发现是 ECDSA 类型，于是现学。。。下面写一下 ECDSA 的签名与验证过程。 场景 Alice 想要使用她的私钥\\(d_A\\)来签名，Bob 想用 Alice 的公钥 \\(H_A\\)要验证签名\\(H_A=d_AG\\)。 只有 Alice 才能提供正确的签名，而每个人都可以验证签名。 签名 1.选定一条椭圆曲线\\(E_p(a,b)\\)。 2.选取一个随机数\\(k,1&lt;k&lt;n-1\\)，\\(n\\)为椭圆曲线的阶。 3.选取椭圆曲线的基点\\(G(a,b)\\),计算 \\(K=k * G(a,b)\\)，令\\(r=K[0]\\mod n\\)，即 r 是 K 点的横坐标（若 r 为 0，重新选 k 进行计算）。 4.计算明文 M 的哈希，令\\(e=hash(M)\\)，计算\\(s=k^{-1}(z+rd_A)\\mod n\\)。 5.给出签名\\((r,s)\\) 验证 1.计算 \\(u_1=s^{-1}z\\mod n\\) 2.计算 \\(u_2=s^{-1}r\\mod n\\) 3.计算点\\(P=u_1G+u_2H_A\\) 当\\(r=x_P\\mod n\\)时，签名验证成功。 解题过程 通过对题目的初步阅读，发现关键是求出私钥d=privkey，而想要求出\\(d\\)就要求出\\(k\\)，虽然\\(k\\) 是以随机数的形式出现，但发现本题中每次签名过程的 k 并不是完全随机，而是线性伪随机\\(k = (a * k + b)\\mod n\\)。这里我很想把\\(k\\)求出来，然后再去求私钥\\(d\\)。所以有没有一种可能，不用求\\(k\\)，如果把\\(k\\)消掉，方程里只剩一个未知数\\(d\\)，即可。细心一点进行数学推导，就会发现答案。 \\[k_1s_1=e+r_1d\\mod n\\] \\[k_2s_2=e+r_2d\\mod n\\] \\[k_2=ak_1+b\\mod n\\] \\[k_2=ak_1+b+xn\\] \\[s_1s_2k_2=s_1s_2ak_1+s_1s_2b+s_1s_2xn\\] \\[s_1(e+r_2d)=s_2a(e+r_1d)+s_1s_2b \\mod n\\] \\[d=(s_1r_2-s_2ar_1)^{-1}(s_2ae-s_1e+s_1s_2b)\\mod n\\] 这里两次的使用的\\(e\\)一样，是因为传的明文一样，\\(n\\)对应的是题目里给的\\(order\\)。这里还想说一下自己因为不细致走过的弯路，题目里通过\\(p\\)定义的曲线，所以误以为\\(curve.order\\)是\\(p\\)，这样就会导致前两个式子和第三个算式的模数不同。有趣的是，找到了一篇论文和文章进行了实现。 论文 但其实\\(curve.order=order\\)所以上述所有都是在模\\(order的条件下\\)，所以进行一下推导就出了。 exp 1234567891011121314151617181920212223242526from hashlib import sha384, sha256import gmpy2from random import randintfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padimport base64r1=3279878223466283028618950233302638071226405889025719666069973709805626015547691183378582347284741486262757601498554s1=17384499590667625694725422408289434727888355224304513038330377593191514147527427495591599008735913255202229321517643r2=35791573017068929691265773591779771913506228775796561985255300322790112181066670265127516180574601131688667017030763s2=10828760915074235995526547174613537265169576586247069263719047150071416454765113291660131007073071569964390274403778order = 0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973a = -3b = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aefm=b&#x27;12&#x27;e= int(sha384(m).hexdigest(), 16)d=((s2*a*e-s1*e+s1*s2*b)*gmpy2.invert(s1*r2-s2*a*r1,order))%orderprivkey=dct=&quot;Iq2XtaYU4TrhdPN6Icyy4r5FQQRn4u/QY7Rv/GTMeo8mNESW7UMcHO969aP28owj&quot;key = sha256(str(privkey).encode()).digest()aes = AES.new(key, AES.MODE_ECB)flag = aes.decrypt(base64.b64decode(ct))print(flag)# b&#x27;DUTCTF&#123;03c77266-981a-49c7-985c-427dea8c3018&#125;\\n\\x03\\x03\\x03&#x27; ECC2 hint:二元 copper 看到 hint 瞬间知道怎么做了，前段时间刚学了一下多元 copper，感慨一下还是运用不熟练，没有一眼发现。 解题思路 同样是 ECDSA，相比于上题来说，k 是随机的，但是每次签名的时候会泄露 k 的高位。此题另外一个关键是，\\(r\\)是由私钥\\(d\\)生成的，所以不管传什么明文，所得到的\\(r\\)是一样的，利用这一点，我们可以构造一个二元方程。 \\[s_1k_1=z_1+dr \\mod n\\] \\[s_2k_2=z_2+dr \\mod n\\] \\[k=kh+kl\\] \\[s_1(k_1h+k_1l)-z_1=s_2(k_2h+k_2l)-z_2 \\mod n\\] \\[f(k_1l,k_2l)=s_1(k_1h+k_1l)-z_1-s_2(k_2h+k_2l)+z_2\\] 随后使用多元 copper 进行求解。具体可看上篇博客。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from Crypto.Util.number import *import itertoolsimport gmpy2import hashlibdef small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []p=0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973z1=48635463943209834798109814161294753926839975257569795305637098542720658922315s1=28960557153977955124105855928246892459194129539041010907864680412903817675556585052129118747753883286132889323816650r1=10262329650789864528165246046678664604936098138502587549051188712903293032192883286179241289544424703403302125420513kh1=30054462723734257949377771041701920514235184485792075736773676269952584122368z2=96094161643976066833367867971426158458230048495430276217795328666133331159861s2=32768223277193629352710157834142251230132284853883889815139295450898873765110205447982974111022207901310306828066654kh2=72175458450676302934456504495778373001580390042980746283386923644015828008960P.&lt;l1,l2&gt; = PolynomialRing(Zmod(p))f = s1*(kh1+l1)-z1+z2-s2*(kh2+l2)roots=small_roots(f,[2^123,2^123],m=4,d=4)k1=kh1+roots[0][0]print(k1)d=(s1*k1-z1)*gmpy2.invert(r1,p) %pprint(d) ez_RSA hint 1:论文 hint 2: 123_P = getPrime(512)_Q = getPrime(512)_E = getPrime(128) 解题思路 通过论文，前半部分白给，按照论文造格，即可规约出\\(_P\\)。 接下来的问题就是如何求\\(_E\\) \\[c=rh+m \\mod p\\] \\[h=f^{-1}g \\mod p\\] 将一式带入二式 \\[c=r(f^{-1}g)+m \\mod p\\] \\[cf=rg+mf \\mod p\\] 因为 r 是 1024 位，g 是 768 位，f 是 1024 位，m 是 128 位，p 是 2048 位，所以 \\[rg+mf \\mod p=rg+mf\\] \\[cf \\mod p=rg+mf\\] 两边同时对\\(g\\)取模，即可消去未知数\\(r\\)，得到 \\[m=(f*c \\mod p)*f^{-1} \\mod g\\] exp 12345678910111213141516171819202122232425262728293031323334import gmpy2from Crypto.Util.number import *N = [24488505552230772703898405057744092798020197662887100045928566607461798879415998969433911671592867423691193007893212171790448148496033832249754470467035859576039972852765027824033483902812925380301406741140813221150182954931965513380139064574526788102105668393014229432860117219535402978106934989998539012187109667064745849634399649647736413364618806713226228056106971513481416594701372170640645464293015870036724187258748076791656956875094445695553182473517994436554776090668857119474259698867998753960189992604478465847990459188823363076285013562416943842050784320042575258091833845135161380009815903587838764844701, 21942338208435084182385640211704681707801054068614769447992577290797559734360545040045515934790906815025864580810713391648536011436866691247019862082665443291278436035391244597094754164488282306715119916684441028200752060845757620891120126278315497677949907573669523197492597821720339218427123565023326747131520068041684678463047030113730829126604863370010551660281077018828022548643645226108297487424616446107497927195470395775786882432946367941603909313849788734757826143420030667354373800077810995031850751976273876305078673953634214542034076821701690757305733970718313282246021719246282428899044959387451493813721, 23497668455233023777086339110715316747963597549643382192342253292465976405928871970112373689839058903850148485020472785615984665835691940413204367982444656171214501783518611386935865837214185153287455312882873758597381603828243325547041133407750654379328638375958886679826484549746013150412316456105776249088635607093923492322952956766124054779608085768835524352691098655090967034048099181640575487096512809322011207592050807314037459121218823863349190706610153922549826130316241130228507499742267531513164868277365453995102439631325485240239658064278370772323955597197097645462559462696920075736717500412375072176467, 24602752336390525414690399431651054304570268658699514976379562458281671118195956305892712759109048179159883455858696847532969723511866788216663843505906403537667342180926673360088955074821393941870156428046985578754285100772721826939367053016610705219388473954106242835781778652607226825374256068393417345461655468867721352760378170127520095819323941371368236422448970366651248269187025683922130051664854342633071652748279316861774478515760339148013907026473066156906456471149913011825141372049833977982484234333570458678135686171332929999460166919896376717386857118613691507888393949301977627819777979592178896966623, 18953499185208189736030572848209776079906463657279533180726462147347299551041367061731767581264798291046925335336327748600462387056921448905471076513661226975709082926810559345546174299411679334921753473024289680372398629669189901701373013365576241051181536865537903618404021542712933154242921449622232452683929678888579145745315642541459705378712865701616368909067164933131032658834080355333776051792137130753989546439723368685913285626433094254606871447681788888268092549602747826573836417735293177348298419537651913321751942895245511550484631808345929882169885236619551016828298778897908525366562962685667912389997, 26058997074784206404795420975966370332956308684314157918342868748891408356160719486198464051733976893317939197082091977103538589213919661919071445422553112631329635223235217838410237178255375880503961177672498539855597740321555211143834639913980706595866117350864736716804583363460558182596815041999893879570562385793992073242663001875888252374638338786999498583269912809638941228890064879230976750529250265485928246165002061153079962922548580197649819298400367411220374463545622395097310522274479190791404838638086998257879095579646234740048206108128561416400963440017838636610491341835198236244222159900729586179917, 20129288490597244863994508524683286916543923374256909422701726115895380145135775471811451623704583730973416890276995662068307971557772661682030720361327963488534216410626882836351191572216702896255347307172468393873617456534444076131643183095198850704362841759392439604384236671314273401344802110069810756951497132798868529183844409689240676486910668076940982100512452093237882154916463456686838284295430539114311525041035893514486445447797574059480052756975515999613849122461978469862438350168200833428502345669466715840072957576654100577765563579448919948971960189182499058054213819157835509700663218459190524786481, 25772226888628216378889012105665796465806282302724456587869873910973423334812434127373733072599928022616753628676669330475503814215217145564188824369324420571202597054472716155179526532355187639821238629970447579319002750207485409261447903974934743921421644358692562332522542087034591326117205324672579857803562028718153429724027759486210144857662620406921986137992325725929734137942692560079628569267164743942853035640478323806095958927790086262013882385080985080476481526342090748836288133196655325636773255199453976910823102554721967925125346896277653138394770159352125883696418264884829676269343523006494765489493, 28180917678264096364213130554312518769321694756137354982942466799600070334989648086800577578199737775401103316802639534494851192425673873971245152762518574367704605203711578476934662035721848792226778740807648983742493303616228706844886115523257289936262329494196476301758716578131772761063410479805704963231509036888772912085068364409900628643478825960092268089737383336074494922924828657292311276635453573546156537729462748165148899289836500996916977979364330535388109166791384761518107152445520068189599143970118706438070727813977600299673995541318641712212956428068655583090081599129833822672148472274657395494311, 24096520981594733135540041445045293573841960767599910205052334165000928248824939510537161616790497646941116274229120870236655788506537976075387985908332620383393482411221069123523398118152293411915859727395926627459816089411701261045912226055104998834013378345004735522524517047738956815571358744380828133660488637141981661993087692525146337627421105058036188111847939723347406549254328070707781083013868559585263821261988100254326668273025331949480627178076069223680391626817412433551120273746233452706538363782378142581856137151539947066350167731639115192474458725211790700741814914076862192417315078235105797677087]e = [14990816743505654628622165338185393514788304851681933876648378016378133833004552588239572072513331166211546424386679543805403883223923897158291656742820659945559107645757683415181516223375888892537454654274671604670730747216886153077537316948532577370868893079392334339867710645123984583810773407647889550347449753485123831550537129872419324613572762662943117457398292227733753412373200584443331215704089181076331725835197653425535473266783470265927502335277809501441179341787793626320140280547900249747914540629687582748709954430668955769537357213201938032236484707582662514737019038265736833188979186130912521585863, 13980763827627068753802142437506147756961327147120384846585792065753477874831749262150192356232427534646403824833533108774540560060637613211774874146149413276494249299817871570564680188453788941137026336224153892313514846782554574856039742426326880334039809963027869250565380677631559930557470002669597495218354140744423266568608599391371104543521898824208746495592540223292285013253969918044073047052609539584913355840849256854717119937629706258126113370733925178495605830457126093047938416483351881694926018583377081560677662700573997147306413923358544678275002331286891558769920350415867546838176106256496063304591, 14780579063990891009355254665451991842503160008305503704320535457678300669711337036613671205753152064334928698447349080369975612980241221790534610771459317421130389318122536272425617948089698175341164528907013863717279614308846442304043798865582825561326523712699604113706443659794242165306104800524140375312705427738731082746546483455937494834598516633798602613773983973082013405488005834441952593810114149056842051193479897318422863626404580404473988124447913889995503058357464905293074956766641790136082627384940112558905750637675896060873962861100183982056080416496196938621664845449511253953693501170360085128903, 16711214191457281887756669342902780733937448803879374453283083153045867559930627177819085640533933761065820583745596344138637603092032409736562935244419493366400643159102093212367352079844413274114447848612728357893278528717959336656627368619208606671105396151558788997816807664937857266355753831602315622410363783260969617861338922264348857939060068689390352416811884902181820721198554329654234974727685100909871157125199506067300247610609375498829939581959252431781213219581899029244337677995603856416381628617372391009770342970567780661612096558829742694823690274654577788829371605600329173594776863959477520982103, 18594117439975066482790234032790248484174823520961644528083330915871018572967431566501699139228578176001011256220804587663135499149059407383901633734350030924262764120967872313971006208598335484653360543538290425602814914998281169215776238281191659744867774608489555339417931965559389905685260689276642846548237827078605788634420231309087514322505420366400886676286045230690585373663959941903912684043605972772430437021974723246305737570908098822722309519738296040046616628592027960453261069541838924103183139583780034839530714165332756110278585636399031079295623434558699098474195076126900986950380911451241239011623, 19559194708926966384760572911017873704390901879016615709461235634857479293981826218552827124678431912373841237544670086117088143163449428902590870488332804443126943800454719812933352578428975217906573009588458046733219592409163112257629384965561668227155289274870789279692570923323341070702638493390067659325308762774741975186341363197445143155212450927975486461028431348416961669886795040925540481784741277337652763782276077736249466953316651582151597935395446083479237519148263818662252163299112568786641111937462894974201544836218414635476953190320368111973284227681772063712004605784879340270632621230933987836403, 5824897109429461861038559948506819313355946138347155891819686064252333158962143819073087399430296860592162523314581575301694562287944866650117694395235555843552189332034264692080727548447621159473572891967606750661558342895087758387175261905746359083324985663989695094130538863365332293493187900142223849133010181832891103712795299278734353222329578233927239011173519663168582557337156776620015916288674042041517496559833923719141125286924436626406982998776488087846464518298748666520211469343659082499491328257233064132961965360640582912978294198510457897250297734712016272553820127075579291175789492076788909484903, 20093930684870093704403628731447520798260787667650361930073915794127380334852577783044260869395685576326078666945720832081037254077260101666695730827561930288288626012593987518548527306424423460475649408280260551546890648986667166140359311359169025356693571920643668500080642858683961398169608007993750190342851289303457474260980188486985907096713430933611341247919058812281901199513792393764217087020138671598226265365230063697174126442928938906561077393855304164795051437164668523033528227661541499372034727485518105697908307910643724070408695313764548498315363035914104961938999577929197200252814942475110976180871, 13869037204167094886192017467762072572783689922376209408114704992930196660451733740128770089390429756385424487822227154417591526218831614700313009517560442765341004656007062383066045588028985918307953894476640133705870038747226187376945281065288052642888278440278584213451675290377535235274143342509678251099489519546607275875817452579354452528872170870264159683907581449035523356408903151369434094661409904630205371744727229020444462773195914556915394012165505241756167908324547409015797008797997989972788159358702567092724994056441270029746996952711879409266397452428164494981358551995284408128900801847197898197703, 16428914441257851380586127106058764321964408189162357989041855273182059205104249998708456730725826756916884625752948925439260021807286451208792938938383227370712775700520945386124870496736574155128284017251496087747219850551258429445192925803640362009834613809916245072076167924064602020863892399904864291654032814159981274305358311150518930746678429624443100376055916453000181475668378167017592583982166064823738703442241236483326956657714675862739661758651886000087664689028808007926485550765412244122793538316265219584816933243708850098752213795555147857155308284006310944783836011777029728050734557927695090450463]h = 17057560302480534379234311167711354032439973325482676122782839023838935814408613403284668375931576462858905421541683065236603421317254300086508655626651873266040666001440382609416143327328595694650892654181322169131419137499521806171136667190680286550054757614439176120722968245637537762536027151112462471175128228332115872386914009028917282712969864162014534349894097630435981616397927996659304774192119923204194457170407620951605854984132096323757248091094843032025335275329879498464954795905069479922445973408638012299137799439137333602346053104379692214857680138658746271359584207903024337671041791120368370062433p = 23179145952004786572757983799234920430633779535677420935312084200876619976669209523097965011942953301009181896712798356246795541216866485028100154585670368454638903095414689361363165856795506643767180784134469175448265110332780161626935638201727064861000660550974538859215360585812084437914540257823591140036538883159605868368631634046489596162666365138195416471349119538264390305637634631928131927917205635961354890675410476331906772088716752701051345455548022086136550213407689965095213596763864324407875037568058288772731307077778493908925797859779443512010698291195779124551476846827399730849219310626324177039013c = 15328778973393120290854691400883441405718565831853248832402785901824594060217263898505045095423915117607252735027062529235271181273369158106663012261516839968695274180392897131714116184427167484636074174222379080262947055141246928560805523812182030937490501937675882728123658706241797231583047415776685427205848679710458819937970889433693918217229443853850611378434132748815873718734347796950384002864988580300986131985895380275684001917985319042538513477446695790524025775222264595925792957208966818239868486709939779314546467392281422991680454815958889806132331710070011646205598326181711484973483426663596859525513ct = 92211459133895146158316008050625159602789832393085884570037939094818571988249290759248366005098334922507923902443804233324386547155962452204674766600765935956870916648760769384276856753284267120760668354671997896119514989451662121408491558308921051289732075282614190244970934960030795710538169872218350493341# 求EM = Matrix([[1, h], [0, p]])fg = M.LLL()[0]f, g = abs(fg[0]), abs(fg[1])a = f * c % pE = a * gmpy2.invert(f, g)%gprint(E.bit_length())# 求Pt=10B=Matrix(ZZ,t+1,t+1)M=gmpy2.iroot(int(N[t-1]),int(2))[0]B[0,0]=Mfor i in range(1,t+1): B[i,i]=-N[i-1] B[0,i]=e[i-1]Blll=B.LLL()P=int(abs(Blll[0][0]//M))phi=P-1D=gmpy2.invert(E,phi)print(long_to_bytes((pow(ct,D,P))))# DUTCTF&#123;RsA_1s_rS@_aNd_1att1ce&#125; misc *签到 b 站 21 级 pwn 例会评论区 我在哪 放大图片看到十八中，搜索临江十八中，发现是重庆十八中，地图上搜一下附近地铁站，挨着桥的就是，曾家岩。 不要更新 流量分析题，wireshark 里过滤一下 http，找到 github 网页 根据 hint 查看历史提交记录，发现假 flag，对于密码手来说一眼凯撒，移位 13。 web *Trenja F12 打开开发者工具，搜索 flag 字段即可。 pwn *中间人 太好玩了，原理是汽车滚动码。bob 来开车门，截断，开门失败。bob 再开车门，截断，发送第一次截断信号，bob 开门成功。bob 离开，我们发送第二次截断的信号，打开车门！ reverse *贪吃蛇 拖入 IDA，alt+t 搜索 DUT 即可 *GAME 下棋赢了就出了","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"Coppersmith相关攻击","slug":"Coppersmith攻击","date":"2023-03-07T02:05:45.000Z","updated":"2023-06-30T02:10:55.040Z","comments":true,"path":"2023/03/07/Coppersmith攻击/","link":"","permalink":"https://sch01ar.github.io/2023/03/07/Coppersmith%E6%94%BB%E5%87%BB/","excerpt":"","text":"原理 Coppersmith 定理是在一个 e 阶模 n 的多项式\\(f(x)\\)中，若有根小于\\(n^{\\frac{1}{e}}\\)，则可以用 O(log n)的算法求出根。 直接求解\\(f(x)\\)的根可能比较困难，在此利用LLL算法求得多项式\\(g(x)\\)，求得的多项式与\\(f(x)\\)具有相同的根\\(x_0\\)，\\(g(x)\\)具有更小的系数，且定义域为整数域。 本质思想就是把有限域上的方程转化到整数域。 理论基础 \\[f(x,y) = \\sum_{i=0}^{d}\\sum_{j=0}^{e} a_{i,j}x^iy^j\\] Howgrave-Graham 需要构造一个系数更小的多项式，\\(||g(x)||\\)代表范数，即最大的系数。构造方法如下 LLL 算法 格基约化算法，通过对构造出的格，从而约化产生符合约束的多项式。 p 高位攻击 1234567891011121314151617import gmpy2from Crypto.Util.number import *from flag import flagm=bytes_to_long(flag)n = 25348605574630284342864323710011622959543974652863854537355760576386763162531478272446867731299572532294812374775121121761898206639041068156270466457595336452690367719842145233764550634280981441631262047763246059814963741143303914063537003244814908763379320576260885158458898112416692583017869283284022878603506583499699525249773663841642694427307104140944360804367072787670581252816486834658346431010523135392357008103555699542414687172408709153334263858639251735462278292703380745537045458408951791720967957274781161667526873251066303708008043058246747534357368350540174588670636827470901518225473676343782182718627e = 65537high_p = p&gt;&gt;462c=pow(m,e,n)print(high_p)print(c)#c = 2838585968727601235811102000208810377763570403442263788723014651093563843294336508586280687833863346617299165812054489406097873361940320732653656106836742334351707641172590772691775696065643337783752853707871271348294775407491819788305857447836923575366699374649494685209530440846553788854498950165868767060103944397665695513568787251626526985821169261973233666633938348865538364532419767347878581021598781082997830762785442482278387265054844200419966175619215512361010529309496176507520460375493466772893213031156341155066854128910227539653777680017545678773463877481232404008355330164324877400343396249494527269803#high_p = 14719840533805965441436310401180369285271789871612468412671201109363519708733266615333097147637913934699335461421648585440665652199846830713164628016025539243988107497052 exp 12345678910111213141516from sage.all import *n = 13139369168613206469808493070119137888363636548621629780897948879328793540933675072448361493321304924953815474270401406259487525517560528123707016104942485164559271692275987380567766009184969340122208041180122234792566147648471202470677782205185423853314467362074540818483729953544353584322270414479260852672948012862257167187569701381652931473637503302338392147780573148724508117699531886205586281824118899931516823621049590863613262210219765105389989391065557707559113268724368695051264276619633555407916385088611885715568165460641318205321508100969473959719364829756492542217470309748646183210141490634293731384313p4=0xce2f93251a3a97404a11c1fe88cf15c7aaf26ffd508ff006933bff2e9ea0c6197a98f1188f03b74b16d564e958a84c877fc0e21faf00f0ae42f26bde226ebf7c9732f17d860b81d139799832d510b91001967fc33ff2d9fbd4c4767fa2438e48e = 0x10001pbits = 1024kbits = pbits - p4.nbits()print(p4.nbits())p4 = p4 &lt;&lt; kbitsPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)if roots: p = p4+int(roots[0]) print (&quot;n: &quot;, n) print (&quot;p: &quot;, p) print (&quot;q: &quot;, n/p) p 高位部分泄露 123456789101112131415161718192021222324from sage.all import *from Crypto.Util.number import *n = 25348605574630284342864323710011622959543974652863854537355760576386763162531478272446867731299572532294812374775121121761898206639041068156270466457595336452690367719842145233764550634280981441631262047763246059814963741143303914063537003244814908763379320576260885158458898112416692583017869283284022878603506583499699525249773663841642694427307104140944360804367072787670581252816486834658346431010523135392357008103555699542414687172408709153334263858639251735462278292703380745537045458408951791720967957274781161667526873251066303708008043058246747534357368350540174588670636827470901518225473676343782182718627p4 =0x3e67e7cacd2584224fb2026b40afbcc4281bd59f72f7801239d95c61c48ded7649924f794592fce806e032f16c2f4a90466905fc30037317074a6424d8bf078e959a1ed2d8e5c000e = 0x10001pbits = 1024for i in range(0,4096): p4=0x3e67e7cacd2584224fb2026b40afbcc4281bd59f72f7801239d95c61c48ded7649924f794592fce806e032f16c2f4a90466905fc30037317074a6424d8bf078e959a1ed2d8e5c000 p4=p4+int(hex(i),16) kbits = pbits - p4.nbits() p4 = p4 &lt;&lt; kbits PR.&lt;x&gt; = PolynomialRing(Zmod(n)) f = x + p4 f = f.monic() roots = f.small_roots(X=2^kbits, beta=0.4) if roots: p = p4+int(roots[0]) print( &quot;n: &quot;, n) print(&quot;p: &quot;, p) print (&quot;q: &quot;, n//p) breakphi = (p - 1) * (q - 1)d = gmpy2.invert(e, phi)print(long_to_bytes(pow(c, d, n))) q 低位和 p 高位 123456789101112131415161718192021222324252627from Crypto.Util.number import *import gmpy2p_high = 1514296530850131082973956029074258536069144071110652176122006763622293335057110441067910479q_low = 40812438243894343296354573724131194431453023461572200856406939246297219541329623n = 21815431662065695412834116602474344081782093119269423403335882867255834302242945742413692949886248581138784199165404321893594820375775454774521554409598568793217997859258282700084148322905405227238617443766062207618899209593375881728671746850745598576485323702483634599597393910908142659231071532803602701147251570567032402848145462183405098097523810358199597631612616833723150146418889589492395974359466777040500971885443881359700735149623177757865032984744576285054725506299888069904106805731600019058631951255795316571242969336763938805465676269140733371287244624066632153110685509892188900004952700111937292221969enc = 19073695285772829730103928222962723784199491145730661021332365516942301513989932980896145664842527253998170902799883262567366661277268801440634319694884564820420852947935710798269700777126717746701065483129644585829522353341718916661536894041337878440111845645200627940640539279744348235772441988748977191513786620459922039153862250137904894008551515928486867493608757307981955335488977402307933930592035163126858060189156114410872337004784951228340994743202032248681976932591575016798640429231399974090325134545852080425047146251781339862753527319093938929691759486362536986249207187765947926921267520150073408188188e = 65537mod = pow(2,265)p0 = n * inverse_mod(q_low,mod) % modPR.&lt;x&gt; = PolynomialRing(Zmod(n))for i in range(2**5): f = p_high * (2^724) + p0 + (x * 32 + i) * mod f = f.monic() out_p = f.small_roots(2^454,0.4) if len(out_p) != 0: print(out_p[0]) breakp = out_p[0] * 32 + i * mod + p_high * (2^724) + p0# print(p)p = 133637329398256221348922087205912367118213472434713498908220867690672019569057789598459580146410501473689139466275052698529257254973211963162087316149628000798221014338373126500646873612341158676084318494058522014519669302359038980726479317742766438142835169562422371156257894374341629012755597863752154328407assert n % p == 0q = n // pfai_n = (p-1) * (q-1)d = inverse_mod(e,fai_n)m = pow(enc,d,n)print(bytes.decode(long_to_bytes(m))) dp 高位攻击 给定\\(e,n,c,dp_0,k,\\;dp_0=dp&gt;&gt;k\\) \\[ edp\\equiv ed\\equiv 1\\;mod\\;(p-1)\\\\ edp=k(p-1)+1\\\\ edp+k-1=kp\\\\ edp+k-1 \\equiv 0\\; mod\\; p\\\\ \\because dp&lt; p-1\\\\ \\because edp=k(p-1)+1\\\\ \\therefore e&gt;k\\\\ \\therefore e(dp_0 &lt;&lt; k+x)+k-1 \\equiv 0\\;mod\\;p \\] 123456789101112131415161718192021222324from Crypto.Util.number import *import gmpy2p = getStrongPrime(512)q = getStrongPrime(512)n = p * qphi = (p - 1) * (q - 1)e = 7621d = gmpy2.invert(e, phi)flag = b&quot;flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;&quot;c = pow(bytes_to_long(flag), e, n)dp = d % (p - 1)print(dp &gt;&gt; 200)print(c, e, n)&#x27;&#x27;&#x27;c = 46735962204857190520476434898881001530665718155698898882603422023484998388668858692912250418134186095459060506275961050676051693220280588047233628259880712415593039977585805890920089318643002597837000049626154900908543384761210358835843974072960080857150727010985827690190496793207012355214605393036388807616e = 7621n = 140376049134934822153964243403031201922239588054133319056483413311963385321279682186354948441840374124640187894619689719746347334298621083485494086361152915457458004998419817456902929318697902819798254427945343361548635794308362823239150919240307072688623000747781103375481834571274423004856276841225675241863&#x27;&#x27;&#x27; EXP 12345678910111213141516171819202122232425262728from sage.all import *n = 140376049134934822153964243403031201922239588054133319056483413311963385321279682186354948441840374124640187894619689719746347334298621083485494086361152915457458004998419817456902929318697902819798254427945343361548635794308362823239150919240307072688623000747781103375481834571274423004856276841225675241863e = 7621c = 46735962204857190520476434898881001530665718155698898882603422023484998388668858692912250418134186095459060506275961050676051693220280588047233628259880712415593039977585805890920089318643002597837000049626154900908543384761210358835843974072960080857150727010985827690190496793207012355214605393036388807616s = 1153696846823715458342658568392537778171840014923745253759529432977932183322553944430236879985def coppersmith(bits, k): F.&lt;x&gt; = PolynomialRing(Zmod(n)) invE = inverse_mod(e, n) f = (s &lt;&lt; bits) + x + (k - 1) * invE x0 = f.small_roots(X=2 ** bits, beta=0.44, epsilon=1/32) return x0for k in range(1, e): bits = 200 x0 = coppersmith(bits,k) if len(x0) != 0: x = Integer(x0[0]) dp = x + (s &lt;&lt; bits) p = (e*dp - 1) // k+1 if p != -1: q = n // p assert n == p * q phi = (p-1)*(q-1) d = inverse_mod(e,phi) m=pow(c,d,n) 多元 coppersmith 原理学习 论文学习 1、 论文学习 2 脚本来源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import itertoolsdef small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() #取得模数 f /= f.coefficients().pop(0) #最高次项系数化为0，coefficients是多项式的降次幂排列系数 f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i #收集基多项式 for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) print(G) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return [] 具体参数说明，例如 12PR.&lt;r,s,t&gt; = PolynomialRing(Zmod(prime))f = r*(s^2+2*s)-t","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"DLP中常用算法","slug":"DLP中常用算法","date":"2023-02-24T10:05:45.000Z","updated":"2023-03-04T06:03:05.157Z","comments":true,"path":"2023/02/24/DLP中常用算法/","link":"","permalink":"https://sch01ar.github.io/2023/02/24/DLP%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","excerpt":"","text":"Pohlig-Hellman 算法（光滑阶） 给定 a,b,p，p 是素数，求 x，\\(a^x \\equiv b (mod\\;p)\\) 在模 p 下，设该群的生成元为 g，则有 \\[ a \\equiv g^{a1} (mod\\;p) \\newline b \\equiv g^{b1} (mod\\;p) \\] 联立条件有 \\[ g^{a1x} \\equiv g^{b1} (mod\\;p) \\] 由欧拉定理得\\(\\phi(p)\\;=\\;p-1\\)，则有\\(a1x\\;=b1\\;(mod\\;(p-1))\\) 1.将 p-1 分解，即 \\(p-1=p_1^{k_1}p_2^{k_2}\\cdots p_m^{k_m}\\) 2.将 x 表示成\\(p_i\\) 进制, 列出方程 \\[x\\;=p_i^0a_0 + p_i^1a_1+...+p_i^{k_i-1}a*{k_i-1}\\] 3.令 r=1，求\\((a^x)^{\\frac{p-1}{p_i^r}}\\; \\equiv b^{\\frac{p-1}{p_i^r}}(mod\\; p)\\) 4.将 2 中的公式代入到 3，展开得到 \\[a^{a0*\\frac{p-1}{p_i}}* a^{(p-1)a1} * a^{(p-1)p_ia_2}...a^{(p-1)p_i^{k_i-2}a_{k_i-1}} \\equiv b^{\\frac{p-1}{p_i}}(mod\\;p)\\] 5.从第二项开始，后面每项都是 1，欧拉定理:\\(a^{(p-1)} \\equiv 1(mod\\;p)\\)，化简得到的式子为 \\[\\newline a^{a0*\\frac{p-1}{p_i}} \\equiv b^{\\frac{p-1}{p_i}}(mod \\;p)\\newline\\] 因为该方程只有 a0 未知，所以可在[0,pi-1]范围内爆破出 a0 6.再令 r = 2,3,4...ki，重复步骤 3，即可求出所有的\\(a_2,a_3....a_{k_i-1}\\)，从而得到 m 个关于 x 的方程，最后使用 CRT 进行求解即可。 总结:将 p-1 的 m 个质因子，分别求出其方程内的所有系数 a，从而构造了 m 个关于 x 的方程，最终利用 CRT 求解。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[]},{"title":"2022DASCTF_NOV-lllcccggg-wp","slug":"2022DASCTF_NOV-lllcccgggwp","date":"2022-11-30T02:05:45.000Z","updated":"2022-12-01T09:42:22.869Z","comments":true,"path":"2022/11/30/2022DASCTF_NOV-lllcccgggwp/","link":"","permalink":"https://sch01ar.github.io/2022/11/30/2022DASCTF_NOV-lllcccgggwp/","excerpt":"","text":"题目描述 如题目名字一样，有好多个lcg，当时看晕了 123456789101112131415161718192021222324252627282930313233343536373839404142434445from Crypto.Util.number import *key=b&#x27;*************&#x27;key=bytes_to_long(key)key=bin(key)[2:]n=getPrime(256)a=[getPrime(256)]for i in range(1,len(key)): a.append(a[i-1]*2)b=getPrime(256)m=[]for i in range(len(key)): m.append((a[i]*b)%n)s=0for i in range(len(key)): s+=m[i]*int(key[i])seed=sa = getPrime(300)b = getPrime(300)n = getPrime(300)output = []for i in range(10): seed = (a*seed+b)%n output.append(seed)print(&quot;output = &quot;,output)print(&#x27;m=&#x27;,m)state=int(key,2)a=getPrime(256)b=getPrime(256)c=getPrime(256)for _ in range(10**10000): state = (a * state + b) % cflag=b&#x27;****************************************&#x27;state_md5=hashlib.md5(str(state).encode()).hexdigest()xorflag=xor(flag,state_md5).hex()print(&#x27;a=&#x27;,a)print(&#x27;b=&#x27;,b)print(&#x27;c=&#x27;,c)print(&#x27;xorflag=&#x27;,xorflag) 题目分析 1.key是一个背包问题，已知公钥m，和的话目前不知道。 2.以1中的和为seed，通过LCG产生了一组序列output。 至此，已经可以根据output来求出LCG中的a、b、n，从而求出seed，从而通过背包可求得key。 3.以key为seed，称作state，再进行LCG，state = (a * state + b) % c，并且a，b，c已知。 但是想要直接正向求解出最后的state，十分困难，for循环了10^10000次，这里涉及到了矩阵快速幂的使用。 通过构造矩阵 \\[ \\mathbf{A} = \\begin{bmatrix} state &amp; 1 \\end{bmatrix} \\] \\[ \\mathbf{C} = \\begin{bmatrix} a &amp; 0\\\\ b &amp; 1\\\\ \\end{bmatrix} \\] 通过计算\\(A*C^{10*10000}\\)即可得到矩阵B，B = [ state, 1] 4.求出state后进行异或解密即可。 EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from functools import reducefrom math import gcdimport hashlibfrom Crypto.Util.number import *import gmpy2def crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return modulusoutput = [75581294523880849612962675076574164955427439308298754836702542570856707873339581806556114, 85105032146983524265511965363979041936757881362506442483720291395014453678757599185295866, 1135521205967352800446368309480529634045225881261100886117662161359310082444102071893527191, 668602662320826002160475166323016971968419541611162501120982012317608523771962990634779874, 649673553234341629614052928960182629959348742983379959653724041939165898600067312959677865, 785853955591839090537858092210736716046894245185520583713505441606094906159642640920286905, 937799570303158165818350743257433287791556030352377438071495081189542968310256239806349207, 734514754865608924980327625447363286114899547828404532253101460271494241963897226149955073, 1106313725444442262780946046218124519471559148520571880678416934586056489046936771811070897, 8768152099561586039808874499029856564696410477579827751292882367683300035228537162519939]m= [72110328606337761986452574632319920368225905906258123752738204764660440229296, 54011682421724526639264309053337133761455956763651742732220904522794415369243, 17814390052498055944887777895371560547916058478438980691186304039062365649137, 35628780104996111889775555790743121095832116956877961382372608078124731298274, 71257560209992223779551111581486242191664233913755922764745216156249462596548, 52306145629033450225461382951669777408332612778647340756234927305972460103747, 14403316467115903117281925692036847841669370508430176739214349605418455118145, 28806632934231806234563851384073695683338741016860353478428699210836910236290, 57613265868463612469127702768147391366677482033720706956857398421673820472580, 25017556945976227604614565324992075758359109018576909140459291836821175855811, 50035113891952455209229130649984151516718218037153818280918583673642351711622, 9861252992953913084817421088665596058440581025443131788581662340758238333895, 19722505985907826169634842177331192116881162050886263577163324681516476667790, 39445011971815652339269684354662384233762324101772527154326649363032953335580, 78890023943631304678539368709324768467524648203545054308653298726065906671160, 67571073096311612023437897207346829960053441358225603844051092445605348252971, 44933171401672226713234954203390952945111027667586702914846679884684231416593, 89866342803344453426469908406781905890222055335173405829693359769368462833186, 89523710815737909519298976602261104805448255621482306886131214532210460577023, 88838446840524821704957112993219502635900656194100108999006924057894456064697, 87467918890098646076273385775136298296805457339335713224758343109262447040045, 84726862989246294818905931338969889618615059629806921676261181211998428990741, 79244751187541592304171022466637072262234264210749338579266857417470392892133, 68280527584132187274701204721971437549472673372634172385278209828414320694917, 46352080377313377215761569232640168123949491696403839997300914650302176300485, 2495185963675757097882298253977629272903128343943175221346324294077887511621, 4990371927351514195764596507955258545806256687886350442692648588155775023242, 9980743854703028391529193015910517091612513375772700885385297176311550046484, 19961487709406056783058386031821034183225026751545401770770594352623100092968, 39922975418812113566116772063642068366450053503090803541541188705246200185936, 79845950837624227132233544127284136732900107006181607083082377410492400371872, 69482926884297456930826248043265566490804358963498709392909249814458335654395, 48756878977643916528011655875228426006612862878132914012562994622390206219441, 7304783164336835722382471539154145038229870707401323251870484238253947349533, 14609566328673671444764943078308290076459741414802646503740968476507894699066, 29219132657347342889529886156616580152919482829605293007481936953015789398132, 58438265314694685779059772313233160305838965659210586014963873906031578796264, 26667555838438374224478704415163613636682076269556667256672242805536692503179, 53335111676876748448957408830327227273364152539113334513344485611073385006358, 16461248562802499564273977449351747571732450029362164253433466215620304923367, 32922497125604999128547954898703495143464900058724328506866932431240609846734, 65844994251209998257095909797406990286929800117448657013733864862481219693468, 41481013711468999180550979383511273598863745186032809254212224718435974297587, 82962027422937998361101958767022547197727490372065618508424449436871948595174, 75715080054924999388563077322742387420459125695266732243593393867217432100999, 61221185318899001443485314434182067865922396341668959713931282727908399112649, 32233395846847005553329788657061428756848937634473414654607060449290333135949, 64466791693694011106659577314122857513697875268946829309214120898580666271898, 38724608596437024879678314416943008052399895489029153845172736790634867454447, 77449217192874049759356628833886016104799790978058307690345473581269734908894, 64689459594797102185072417456469325234603726907252110607435442156013004728439, 39169944398643207036503994701635943494211598765639716441615379305499544367529, 78339888797286414073007989403271886988423197531279432883230758610999088735058, 66470802803621830812375138595241067001850540013694360993206012215471712380767, 42732630816292664291109436979179427028705224978524217213156519424416959672185, 85465261632585328582218873958358854057410449957048434426313038848833919344370, 80721548474219659830796907705415001139825044865232364079370572691141373599391, 71234122157488322327952975199527295304654234681600223385485640375756282109433, 52259269524025647322265110187751883634312614314335941997715775744986099129517, 14309564257100297310889380164201060293629373579807379222176046483445733169685, 28619128514200594621778760328402120587258747159614758444352092966891466339370, 57238257028401189243557520656804241174517494319229516888704185933782932678740, 24267539265851381153474201102305775374039133589594529004152866861039400268131, 48535078531702762306948402204611550748078267179189058008305733722078800536262, 6861182272454527280255964197920394521160679309513611243355962437631135983175, 13722364544909054560511928395840789042321358619027222486711924875262271966350, 27444729089818109121023856791681578084642717238054444973423849750524543932700, 54889458179636218242047713583363156169285434476108889946847699501049087865400, 19569941568321439150454586955423605363575013903353275120439893995571710641451, 39139883136642878300909173910847210727150027806706550240879787991143421282902, 78279766273285756601818347821694421454300055613413100481759575982286842565804, 66350557755620515869995855432086135933604256177961696190263646958047220042259, 42492140720290034406350870652869564892212657307058887607271788909567974995169, 84984281440580068812701741305739129784425314614117775214543577819135949990338, 79759588090209140291762642400175552593854774179371045655831650631745434891327, 69310201389467283249884444589048398212713693309877586538407796256964404693305, 48411427987983569166128048966794089450431531570890668303560087507402344297261, 6613881185016140998615257722285471925867208092916831833864670008278223505173, 13227762370032281997230515444570943851734416185833663667729340016556447010346, 26455524740064563994461030889141887703468832371667327335458680033112894020692, 52911049480129127988922061778283775406937664743334654670917360066225788041384, 15613124169307258644203283345264843838879474437804804568579215125925110993419, 31226248338614517288406566690529687677758948875609609137158430251850221986838, 62452496677229034576813133381059375355517897751219218274316860503700443973676, 34696018563507071819985426550816043736039940453573931775378216000874422858003, 69392037127014143639970853101632087472079880907147863550756432001748845716006, 48575099463077289946300865991961467969163906765431222328257358996971226342663, 6941224135203582558960891772620228963331958481997939883259212987415987595977, 13882448270407165117921783545240457926663916963995879766518425974831975191954, 27764896540814330235843567090480915853327833927991759533036851949663950383908, 55529793081628660471687134180961831706655667855983519066073703899327900767816, 20850611372306323609733428150620956438315480663102533358891902792129336446283, 41701222744612647219466856301241912876630961326205066717783805584258672892566, 83402445489225294438933712602483825753261922652410133435567611168517345785132, 76595916187499591544226584993664944531527990255955762097879717330508226480915, 62982857584048185754812329776027182088060125463047019422503929654489987872481, 35756740377145374175983819340751657201124395877229534071752354302453510655613, 71513480754290748351967638681503314402248791754459068143504708604907021311226, 52817986717630499370294437151703921829501728460053631513753912203287577533103, 15426998644310001406948034092105136684007601871242758254252319400048689976857, 30853997288620002813896068184210273368015203742485516508504638800097379953714, 61707994577240005627792136368420546736030407484971033017009277600194759907428, 33207014363529013921943432525538386497064959921077561260763050193863054725507, 66414028727058027843886865051076772994129919842155122521526100387726109451014, 42619082663165058354132889890850839013263984635445740269796695768925753812679, 85238165326330116708265779781701678026527969270891480539593391537851507625358, 80267355861709236082890719352100649078060083492918456305931278069176550161367, 70325736932467474832140598492898591181124311936972407838607051131826635233385, 50442499073983952330640356774494475387252768825080310903958597257126805377421, 10676023357016907327639873337686243799509682601296117034661689507727145665493, 21352046714033814655279746675372487599019365202592234069323379015454291330986, 42704093428067629310559493350744975198038730405184468138646758030908582661972, 85408186856135258621118986701489950396077460810368936277293516061817165323944, 80607398921319519908597133191677193817159066571873367781331527117107865558539, 71005823051688042483553426172051680659322278094882230789407549227689266027729, 51802671312425087633466012132800654343648701140899956805559593448852066966109, 13396367833899177933291184054298601712301547232935408837863681891177668842869, 26792735667798355866582368108597203424603094465870817675727363782355337685738, 53585471335596711733164736217194406849206188931741635351454727564710675371476, 16961967880242426132688632223086106723416522814618765929653950122894885653603, 33923935760484852265377264446172213446833045629237531859307900245789771307206, 67847871520969704530754528892344426893666091258475063718615800491579542614412, 45486768250988411727868217573386146812336327468085622663976095976632620139475, 764561711025826122095594935469586649676799887306740554696686946738775189601, 1529123422051652244191189870939173299353599774613481109393373893477550379202, 3058246844103304488382379741878346598707199549226962218786747786955100758404, 6116493688206608976764759483756693197414399098453924437573495573910201516808, 12232987376413217953529518967513386394828798196907848875146991147820403033616, 24465974752826435907059037935026772789657596393815697750293982295640806067232, 48931949505652871814118075870053545579315192787631395500587964591281612134464, 7654924220354746294595311528804384183634530526398286227920424176036759179579, 15309848440709492589190623057608768367269061052796572455840848352073518359158, 30619696881418985178381246115217536734538122105593144911681696704147036718316, 61239393762837970356762492230435073469076244211186289823363393408294073436632, 32269812734724943379884144249567439963156633373508074873471281810061681783915, 64539625469449886759768288499134879926313266747016149746942563620123363567830, 38870276147948776185895736786967052877630678445167794720629622233720262046311, 77740552295897552371791473573934105755261356890335589441259244467440524092622, 65272129800844107409942106936565504535526858731806674109262983928354583095895, 40335284810737217486243373661828302096057862414748843445270462850182701102441, 80670569621474434972486747323656604192115724829497686890540925700365402204882, 71132164451997872611332654436010501409235594610130869007826346394204339320415, 52055354113044747889024468660718295843475334171397233242397187781882213551481, 13901733435138498444408097110133884711954813293929961711538870557237962013613, 27803466870276996888816194220267769423909626587859923423077741114475924027226, 55606933740553993777632388440535538847819253175719846846155482228951848054452, 21004892690156990221623936669768370720642651302575188919055459451377231019555, 42009785380313980443247873339536741441285302605150377838110918902754462039110, 84019570760627960886495746679073482882570605210300755676221837805508924078220, 77830166730304924439350653146844258790145355371737006579188170604491383067091, 65451358669658851545060466082385810605294855694609508385120836202456301044833]a2= 102146678855348749881681741830301892566150942749854546938156269348575567682569b2= 57926598868103510549704115342815226386495366694945712679089221082045615713293c= 79112540456632613121737537841885533313599936328220061653608162113976717833173xor = 0x2079677330734e7d07116d73543d03316c6501555c02403b7201080612101049n = crack_unknown_modulus(output)a=(output[2]-output[1])*inverse((output[1]-output[0]),n)%nb=(output[1]-a*output[0])%nseed = (inverse(a,n)*(output[0]-b))%n# sage# sum = seed# nbits=len(m)# A=Matrix(ZZ,nbits+1,nbits+1)# for i in range(nbits):# A[i,i]=2# A[i,-1]=m[i]# for i in range(nbits+1):# A[-1,i]=1# A[-1,-1]=sum# A[:,-1]=2**100# r=A.LLL()# for i in r:# if len(set(i[:-1])) == 2:# print(i)key=[-1, 1, 1, 1, 1, 1, -1, 1, -1, -1, -1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, 1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, 1, -1, -1, -1, 1, -1, 1, -1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, -1, 1, -1, -1, -1, -1, -1, 1, 1, -1, -1, 1, 1, 1, 1, 1, -1, -1, 1, -1, 1, -1, -1, 0]key0=[]for i in range(len(key)): if key[i]==-1: key0.append(1) if key[i]==1: key0.append(0)state = int(&#x27;&#x27;.join([str(i) for i in key0]), 2)# 矩阵快速幂# a = 102146678855348749881681741830301892566150942749854546938156269348575567682569# b = 57926598868103510549704115342815226386495366694945712679089221082045615713293# c = 79112540456632613121737537841885533313599936328220061653608162113976717833173# state = 1459518099080641908882248947391577149455413355# A=[state,1]# A = Matrix(Zmod(c),A)# C = Matrix(Zmod(c),[[a, 0], [b, 1]])# state=A*C^(10**10000)# print(state)state=5413978693489756582509930284917854732906886271552898511650182850401353715151state_md5=hashlib.md5(str(state).encode()).hexdigest()state_md5=bytes_to_long(state_md5.encode())flag=long_to_bytes(state_md5^xor)print(flag)# b&#x27;DASCTF&#123;D0u_Ge_1S_R4al1y_G00d!!!&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"背包加密算法","slug":"背包问题算法","date":"2022-11-28T16:00:00.000Z","updated":"2022-12-01T09:50:05.003Z","comments":true,"path":"2022/11/29/背包问题算法/","link":"","permalink":"https://sch01ar.github.io/2022/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/","excerpt":"","text":"前言 在一次CTF比赛中遇到了，写了10个for嵌套硬爆出来了，复现的时候发现是背包加密。 Merkle–Hellman 公钥加密算法 整体加密流程 12345678import numpyx = [1,0,0,1,0]#明文对应的2进制数a = [3,7,16,50,120]# 产生一个超递增序列，称作私钥#对私钥a进行加密，产生公钥b。m = 251#选取一个模数w = 300#选取一个乘数b = [w * x % m for x in a]#产生公钥S = numpy.dot(x,b)#加密结果 可以发现，加密十分容易，但解密十分困难，这也是非对称加密的特点。 ### 加密 生成私钥 超递增序列，也就是a中每一位元素需要大于其之前所有元素的和。 123a =[randint(20, 50)]for i in range(nbits - 1): a.append(randint(2 * a[-1], 3 * a[-1])) 生成公钥 模数m要求：m &gt; sum(a) 乘数w要求：gcd(w,m) == 1 1234567while True: m = randint(2 * a[-1] + 1, 3 * a[-1]) w = randint(2 * a[-1] + 1, 3 * a[-1]) if gcd(w, m) == 1: breakb = [w * x % m for x in a] b和m作为公钥。 加密：S = numpy.dot(x,b) 解密 拿到公钥\\(M=(m_1,m_2,\\ldots,m_n)\\)，构造如下矩阵 \\[ \\begin{bmatrix} 2 &amp; 0 &amp; \\ldots &amp; 0 &amp; m_1 \\\\ 0 &amp; 2 &amp; \\ldots &amp; 0 &amp; m_2 \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\ldots &amp; 2 &amp; m_n \\\\ 1 &amp; 1 &amp; \\ldots &amp; 1 &amp; S \\\\ \\end{bmatrix} \\] 这个矩阵的所有行向量的线性组合构成了一个格，接下来将通过明文的特点和格上的特殊解法来进行解密。 LLL 对于明文\\(X=(x_1,x_2,\\ldots,x_n)\\)这一组数来说，构造一个向量 \\[ a=\\sum_{i=1}^nx_iv_i-v_{n+1}=(2x_1-1,2x_2-1,\\ldots,2x_n-1,0) \\] 显然，a向量在格L上。因为X中的所有x只能取值0或1，因此a向量的长度很小，约为\\(\\sqrt{n}\\)，对于很大的格基来说，a向量无疑是格L上的最小向量，因此我们利用LLL算法即可求出a向量。 例题 12345678910111213sum=492226042629702nbits=32M=[19620578458228, 39616682530092, 3004204909088, 6231457508054, 3702963666023, 48859283851499, 4385984544187, 11027662187202, 18637179189873, 29985033726663, 20689315151593, 20060155940897, 46908062454518, 8848251127828, 28637097081675, 35930247189963, 20695167327567, 36659598017280, 10923228050453, 29810039803392, 4443991557077, 31801732862419, 23368424737916, 15178683835989, 34641771567914, 44824471397533, 31243260877608, 27158599500744, 2219939459559, 20255089091807, 24667494760808, 46915118179747]A=Matrix(ZZ,nbits+1,nbits+1)for i in range(nbits): A[i,i]=2 A[i,-1]=M[i]for i in range(nbits+1): A[-1,i]=1A[-1,-1]=sumr=A.LLL()print(r[0])#(-1, -1, 1, -1, 1, -1, -1, -1, -1, 1, 1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, 0) 这里注意一下，第一行向量中是有+1与-1，需要进行取反，即-1代表1，1代表0。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"非对称加密","slug":"非对称加密","permalink":"https://sch01ar.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"}]},{"title":"Hitcon 2022-㊙️BabySSS","slug":"hitcon2022-BabySSS","date":"2022-11-27T16:00:00.000Z","updated":"2022-12-01T09:37:56.735Z","comments":true,"path":"2022/11/28/hitcon2022-BabySSS/","link":"","permalink":"https://sch01ar.github.io/2022/11/28/hitcon2022-BabySSS/","excerpt":"","text":"I implemented a toy Shamir's Secret Sharing for fun. Can you help me check is there any issues with this? Shamir's Secret Sharing密钥分享算法 \\[f(x)=a_0 + a_1x + a_2x^2 + …… + a_{k-1} x^{k-1} mod p \\] 题目源码 12345678910111213141516171819202122232425262728293031from random import SystemRandomfrom Crypto.Cipher import AESfrom hashlib import sha256from secret import flagrand = SystemRandom()def polyeval(poly, x): return sum([a * x**i for i, a in enumerate(poly)])DEGREE = 128SHARES_FOR_YOU = 8 # I am really stingy :)poly = [rand.getrandbits(64) for _ in range(DEGREE + 1)]shares = []for _ in range(SHARES_FOR_YOU): x = rand.getrandbits(16) y = polyeval(poly, x) shares.append((x, y))print(shares)secret = polyeval(poly, 0x48763)key = sha256(str(secret).encode()).digest()[:16]cipher = AES.new(key, AES.MODE_CTR)print(cipher.encrypt(flag))print(cipher.nonce)#[(41458, 3015894889650529600470920314593280408459518223054415623846810748413393737686521849609926975694824777687791824408686652245102687392987299828716863372946074882798754477101786150262288970710451710086966378817944448615584285684364802621112755627795146504720812935041851556318832824799502759754100408717888912062197676588256634343721633045179136302533777168978134770315363985448879229514802330846792965525004570768212871252658334277172395338054448791891165981203069346039654617938169527772805687564575525262812469960675835101499054296722994451502140787064163668418661661374437567033971648550576296023422536253955229), (3389, 188433716494377932944071544153838579057591833387651830021721770473524507947811754295899393634645349682360212761145039355690817927625249659010181081209481357850193656763556243022791637306094953982811471415645267589939465925098159204147714779617946431727015863707468081949286110249296858079354949234074465541940264775783884708819566758872542606519408358277173683256608326688673226933790117016596834640875497643330432185114931410656582728964222203181026468387428893233826461), (20016, 100434774699078525844435127144579870564983915777345068724291926367405061427748836490810414860997895358378538088786283372231649911113841061354335739776409724471256377867811133591349442950556374825868587940833009529662869081130218551306459690738900795035660420986807973542512081415453215211908130387754214098414826747340962722685373241806099462750595976574593799013733614097923338311883793416643213898201680852118540438376386415411317989072583126108177482838299109479175882214603698768498421016054035672774286507312986602290254323930575001551875601243671354491241420409219), (50683, 444545881882748849210617532697661279371689521082184772844723908765173319859389018743414369945234307906596253496624659734919646710483514374218993496994560985318096082923429834553341897367168830049334302307406087637232329348570485341223211629167329394484624055745054495405880099706580380696671879365741197827080224977821589102425678989782880274304484630899425664722718972847034030888019348402685383311095030884356731112886316823960378572796288532824588478234949384868912708000223119984161992105752059185137674711077940232530298853451166664700609238496874366152042676602089571801873748042888046623717879084695143810047335029), (6445, 101461065764578261241074518788237888467081270902741849861528201922043223477790661159690684156056890167304291810116447916457265705130707166062372766839626095333813681671546097679623755546322833727082145873422243641505450049118758544298328784536759107951763715458884889255549767465897671061295486677353893450789955616926292534325337544782386120469581214993770910137353221116457111551538222138388416162630076391624447865248920466274175229034129561913505977209131490066291917549232913771218316393849495621818397), (1359, 301175604076484656987097022479686300460199620068959954988990822483114048418823291831080744590394713639405681060973359346474547015206086229256524657214311815578895906855833813636970640902962286472992468394831014254279137613828904924898823470285520515090889491445149243620044782726415898188702226878029241518020146726699446397961112596830223444821094650508662477147134721631935528182772284099429814417490160457082241680661), (45286, 244867719210730952183489456726726432791149629831242968845409984537752132549250274779516590253042559196452609852176114909791657154092483479876795482861784431886143414585698773882088948703730268947925790809436449512089696895048994874003651088538416399435467483409931121063976149037130454114161175715871108284419975118570732022104749321213013756795645219060997019373915339235627535694458093194617642834806820772479160496966470147893963746139947337914575231526069667124822677688977724313174612816604463495630041075005651663546036363128325535621487658461744362098985183050127661470315454320073092665472364666768205258769), (5649, 4766101906865350375503575239791521167258753430948472304582908507542293595346756303331383584550516424087839316050412570112796817549423179461056531056102741963677007097061600281918678364910813585444151640384802648969082273001142879806475184857246441212406056540028447374033197873299250076862108042582790928405869475508762352345569281589853917902601519294573327847401601789315980414998055948162169170771240383220643819333682845459742335249254576151835966500230706707674854493184181354958093926469960861)]#b&#x27;G$\\xf5\\x9e\\xa9\\xb1e\\xb5\\x86w\\xdfz\\xbeP\\xecJ\\xb8wT&lt;&lt;\\x84\\xc5v\\xb4\\x02Z\\xa4\\xed\\x8fB\\x00[\\xc0\\x02\\xf9\\xc0x\\x16\\xf9\\xa4\\x02\\xb8\\xbb&#x27;#b&#x27;\\x8f\\xa5z\\xb4mZ\\x97\\xe9&#x27; 题目分析 题目给了8组x，y的值，可通过CRT模x求出a_0 ，通过模x^2 可求出a_1 ，同理可求出所有系数，恢复出polyeval函数，从而得到正确的secret。 EXP 123456789101112131415161718192021222324from Crypto.Cipher import AESfrom hashlib import sha256from Crypto.Util.number import *from sympy.ntheory.modular import crtdef polyeval(poly, x): return sum([a * x**i for i, a in enumerate(poly)])shares = [(41458, 3015894889650529600470920314593280408459518223054415623846810748413393737686521849609926975694824777687791824408686652245102687392987299828716863372946074882798754477101786150262288970710451710086966378817944448615584285684364802621112755627795146504720812935041851556318832824799502759754100408717888912062197676588256634343721633045179136302533777168978134770315363985448879229514802330846792965525004570768212871252658334277172395338054448791891165981203069346039654617938169527772805687564575525262812469960675835101499054296722994451502140787064163668418661661374437567033971648550576296023422536253955229), (3389, 188433716494377932944071544153838579057591833387651830021721770473524507947811754295899393634645349682360212761145039355690817927625249659010181081209481357850193656763556243022791637306094953982811471415645267589939465925098159204147714779617946431727015863707468081949286110249296858079354949234074465541940264775783884708819566758872542606519408358277173683256608326688673226933790117016596834640875497643330432185114931410656582728964222203181026468387428893233826461), (20016, 100434774699078525844435127144579870564983915777345068724291926367405061427748836490810414860997895358378538088786283372231649911113841061354335739776409724471256377867811133591349442950556374825868587940833009529662869081130218551306459690738900795035660420986807973542512081415453215211908130387754214098414826747340962722685373241806099462750595976574593799013733614097923338311883793416643213898201680852118540438376386415411317989072583126108177482838299109479175882214603698768498421016054035672774286507312986602290254323930575001551875601243671354491241420409219), (50683, 444545881882748849210617532697661279371689521082184772844723908765173319859389018743414369945234307906596253496624659734919646710483514374218993496994560985318096082923429834553341897367168830049334302307406087637232329348570485341223211629167329394484624055745054495405880099706580380696671879365741197827080224977821589102425678989782880274304484630899425664722718972847034030888019348402685383311095030884356731112886316823960378572796288532824588478234949384868912708000223119984161992105752059185137674711077940232530298853451166664700609238496874366152042676602089571801873748042888046623717879084695143810047335029), (6445, 101461065764578261241074518788237888467081270902741849861528201922043223477790661159690684156056890167304291810116447916457265705130707166062372766839626095333813681671546097679623755546322833727082145873422243641505450049118758544298328784536759107951763715458884889255549767465897671061295486677353893450789955616926292534325337544782386120469581214993770910137353221116457111551538222138388416162630076391624447865248920466274175229034129561913505977209131490066291917549232913771218316393849495621818397), (1359, 301175604076484656987097022479686300460199620068959954988990822483114048418823291831080744590394713639405681060973359346474547015206086229256524657214311815578895906855833813636970640902962286472992468394831014254279137613828904924898823470285520515090889491445149243620044782726415898188702226878029241518020146726699446397961112596830223444821094650508662477147134721631935528182772284099429814417490160457082241680661), (45286, 244867719210730952183489456726726432791149629831242968845409984537752132549250274779516590253042559196452609852176114909791657154092483479876795482861784431886143414585698773882088948703730268947925790809436449512089696895048994874003651088538416399435467483409931121063976149037130454114161175715871108284419975118570732022104749321213013756795645219060997019373915339235627535694458093194617642834806820772479160496966470147893963746139947337914575231526069667124822677688977724313174612816604463495630041075005651663546036363128325535621487658461744362098985183050127661470315454320073092665472364666768205258769), (5649, 4766101906865350375503575239791521167258753430948472304582908507542293595346756303331383584550516424087839316050412570112796817549423179461056531056102741963677007097061600281918678364910813585444151640384802648969082273001142879806475184857246441212406056540028447374033197873299250076862108042582790928405869475508762352345569281589853917902601519294573327847401601789315980414998055948162169170771240383220643819333682845459742335249254576151835966500230706707674854493184181354958093926469960861)]c = b&#x27;G$\\xf5\\x9e\\xa9\\xb1e\\xb5\\x86w\\xdfz\\xbeP\\xecJ\\xb8wT&lt;&lt;\\x84\\xc5v\\xb4\\x02Z\\xa4\\xed\\x8fB\\x00[\\xc0\\x02\\xf9\\xc0x\\x16\\xf9\\xa4\\x02\\xb8\\xbb&#x27;cn = b&#x27;\\x8f\\xa5z\\xb4mZ\\x97\\xe9&#x27;poly=[]for i in range(129): x, y = zip(*shares) tmp=crt(x,y)[0] shares = [(x, (y - tmp) // x) for x, y in shares] poly.append(tmp)secret = polyeval(poly, 0x48763)key = sha256(str(secret).encode()).digest()[:16]cipher = AES.new(key, AES.MODE_CTR,nonce=cn)print(cipher.decrypt(c))#hitcon&#123;doing_SSS_in_integers_is_not_good_:(&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"Gauss格基约简算法","slug":"Gauss格基约简算法","date":"2022-11-23T16:00:00.000Z","updated":"2022-12-07T09:39:00.075Z","comments":true,"path":"2022/11/24/Gauss格基约简算法/","link":"","permalink":"https://sch01ar.github.io/2022/11/24/Gauss%E6%A0%BC%E5%9F%BA%E7%BA%A6%E7%AE%80%E7%AE%97%E6%B3%95/","excerpt":"","text":"由Gauss提出的二维格基约化算法 算法伪代码 即对给定的两个基向量进行不断的相互约化，最终求得格上的最小向量 Loop If ||v2|| &lt; ||v1||, swap v1, v2 Compute m = ⌊ v1∙v2 / v1∙v1 ⌉ If m = 0, return v1, v2 v2 = v2 - m*v1 Continue Loop 代码实现 123456789101112131415161718192021222324252627#pythonimport numpy as npdef e_norm(a): n = len(a) s = 0 for i in range(n): res = a[i] * a[i] s += res return sdef gauss_reduction(v1, v2): while True: v1_enorm = e_norm(v1) v2_enorm = e_norm(v2) if v1_enorm &gt; v2_enorm: v1, v2 = v2, v1 v1_enorm, v2_enorm = v2_enorm, v1_enorm m = np.dot(v1, v2) / v1_enorm m = int(round(m)) if m == 0: print(&quot;v1:&quot; + str(v1)) print(&quot;v2:&quot; + str(v2)) return True else: v2 = v2 - np.dot(m, v1)#最后输出的两个向量，v1即为格上最短向量 例题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import numpy as npfrom Crypto.Util.number import getPrime, inverse, bytes_to_long,long_to_bytesimport randomimport mathFLAG = b&#x27;crypto&#123;?????????????????????&#125;&#x27;def gen_key(): q = getPrime(512) upper_bound = int(math.sqrt(q // 2)) lower_bound = int(math.sqrt(q // 4)) f = random.randint(2, upper_bound) while True: g = random.randint(lower_bound, upper_bound) if math.gcd(f, g) == 1: break h = (inverse(f, q)*g) % q return (q, h), (f, g)def encrypt(q, h, m): assert m &lt; int(math.sqrt(q // 2)) r = random.randint(2, int(math.sqrt(q // 2))) e = (r*h + m) % q return edef decrypt(q, h, f, g, e): a = (f*e) % q m = (a*inverse(f, g)) % g return mpublic, private = gen_key()q, h = publicf, g = privatem = bytes_to_long(FLAG)e = encrypt(q, h, m)print(f&#x27;Public key: &#123;(q,h)&#125;&#x27;)print(f&#x27;Encrypted Flag: &#123;e&#125;&#x27;)&#x27;&#x27;&#x27;Public key: (7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257, 2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800)Encrypted Flag: 5605696495253720664142881956908624307570671858477482119657436163663663844731169035682344974286379049123733356009125671924280312532755241162267269123486523&#x27;&#x27;&#x27; 思路 给定公钥q、h，以及明文e 要求私钥f、g 他们之间有如下关系： fh ≡ g mod q 即 kq + g =fh g = fh -kq 根据这一特点即可构造格，也就是格密码中很经典的，遇到一个向量乘矩阵，即可进行构造 由于存在一组a、b，使得a（1，h）+ b（0，q）=（f，g）\\(a(1,h) + b(0,q) = (f,g)\\) a = f，b = k 选取一组基底为（1，h）和（0，q），也就是上述高斯约简算法当中的v1与v2，求出v1与v2格上最小的向量，即为（f，g） EXP 1234567891011q = 7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257h = 2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800e = 5605696495253720664142881956908624307570671858477482119657436163663663844731169035682344974286379049123733356009125671924280312532755241162267269123486523u = np.array([1,h])v = np.array([0,q])gauss_reduction(u,v)f = 47251817614431369468151088301948722761694622606220578981561236563325808178756g = 43997957885147078115851147456370880089696256470389782348293341937915504254589m = decrypt(q,h,f,g,e)print(long_to_bytes(m))#crypto&#123;Gauss_lattice_attack!&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"lattice","slug":"lattice","permalink":"https://sch01ar.github.io/tags/lattice/"}]},{"title":"二叉树建立与遍历","slug":"二叉树建立与遍历","date":"2022-11-09T16:00:00.000Z","updated":"2022-12-01T05:15:01.487Z","comments":true,"path":"2022/11/10/二叉树建立与遍历/","link":"","permalink":"https://sch01ar.github.io/2022/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/","excerpt":"","text":"网上很多算法通过直接将二叉树结点连接，从而构成二叉树，这里我构建了一个二叉树类，通过用户控制输入来建立二叉树。 有层序遍历，递归、非递归的前序遍历、中序遍历、后序遍历算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;using namespace std;class Binarytreenode&#123; public: int data; Binarytreenode *leftchild; Binarytreenode *rightchild; Binarytreenode()&#123;&#125;; Binarytreenode(const int &amp;a,Binarytreenode *l=NULL,Binarytreenode*r=NULL) &#123; this-&gt;data=a; this-&gt;leftchild=l; this-&gt;rightchild=r; &#125;&#125;;class BinaryTree&#123; private: public: Binarytreenode *root; BinaryTree()&#123;root =new Binarytreenode;&#125;; ~BinaryTree()&#123;delete[]root;&#125; void visit(Binarytreenode*t) &#123; cout&lt;&lt;t-&gt;data&lt;&lt;&quot; &quot;; &#125; Binarytreenode* creatTree(Binarytreenode* temp) &#123; int n; cout&lt;&lt;&quot;请输入2叉树结点的值,输入-1以表示停止创建某子树&quot;&lt;&lt;endl; cin&gt;&gt;n; if(n==-1) &#123; return NULL; &#125; else&#123; temp = new Binarytreenode; temp-&gt;data=n; temp-&gt;leftchild=creatTree(temp-&gt;leftchild); temp-&gt;rightchild=creatTree(temp-&gt;rightchild); &#125; root=temp; return root; &#125; void levelOrder() &#123; queue &lt;Binarytreenode *&gt; nodeQueue; Binarytreenode *p=root; if (p) nodeQueue.push(p); while(!nodeQueue.empty()) &#123; p=nodeQueue.front(); visit(p); nodeQueue.pop(); if (p-&gt;leftchild) &#123; nodeQueue.push(p-&gt;leftchild); &#125; if (p-&gt;rightchild) &#123; nodeQueue.push(p-&gt;rightchild); &#125; &#125; &#125; void preOrder0(Binarytreenode *root)//先序递归 &#123; if (root!=NULL) &#123; visit(root); preOrder0(root-&gt;leftchild); preOrder0(root-&gt;rightchild); &#125; &#125; void inOrder0(Binarytreenode *root)//中序递归 &#123; if (root!=NULL) &#123; inOrder0(root-&gt;leftchild); visit(root); inOrder0(root-&gt;rightchild); &#125; &#125; void postOrder0(Binarytreenode *root)//后序递归 &#123; if (root!=NULL) &#123; postOrder0(root-&gt;leftchild); postOrder0(root-&gt;rightchild); visit(root); &#125; &#125; void preOrder1(Binarytreenode *root) &#123; stack&lt;Binarytreenode *&gt;nodeStack; Binarytreenode *p=root; while (!nodeStack.empty()||p) &#123; if(p) &#123; visit(p);//先访问当前结点，也就是根 if (p-&gt;rightchild!=NULL)//若右子树不空，则先存到栈中 &#123; nodeStack.push(p-&gt;rightchild); &#125; p=p-&gt;leftchild;//p指向左子树，开始访问。 &#125;else//左子树遍历完毕后，进行弹栈，继续遍历 &#123; p=nodeStack.top(); nodeStack.pop(); &#125; &#125; &#125; void inOrder1(Binarytreenode *root) &#123; stack&lt;Binarytreenode *&gt;nodeStack; Binarytreenode *p=root; while (!nodeStack.empty()||p) &#123; if(p) &#123; nodeStack.push(p);//一路向左全压栈。 p=p-&gt;leftchild; &#125;else &#123; p=nodeStack.top(); visit(p); p=p-&gt;rightchild; nodeStack.pop(); &#125; &#125; &#125; void postOrder1(Binarytreenode *root) &#123; stack&lt;Binarytreenode *&gt;nodeStack; Binarytreenode *p=root; Binarytreenode *pre=root; while (p) &#123; while(p-&gt;leftchild!=NULL)//向左搜索全压栈，直到没有左子树。 &#123; nodeStack.push(p); p=p-&gt;leftchild; &#125; //读取栈顶，访问右子树 while (p!=NULL&amp;&amp; (p-&gt;rightchild==NULL || p-&gt;rightchild==pre)) &#123; visit(p); pre=p; if (nodeStack.empty()) &#123; return; &#125; p=nodeStack.top(); nodeStack.pop(); &#125; nodeStack.push(p); p=p-&gt;rightchild; &#125; &#125;&#125;;int main()&#123; BinaryTree t1; t1.creatTree(t1.root); cout&lt;&lt;&quot;层次遍历:&quot;&lt;&lt;endl; t1.levelOrder(); cout&lt;&lt;endl&lt;&lt;&quot;前序遍历(递归):&quot;&lt;&lt;endl; t1.preOrder0(t1.root); cout&lt;&lt;endl&lt;&lt;&quot;前序遍历(非递归):&quot;&lt;&lt;endl; t1.preOrder1(t1.root); cout&lt;&lt;endl&lt;&lt;&quot;中序遍历(递归):&quot;&lt;&lt;endl; t1.inOrder0(t1.root); cout&lt;&lt;endl&lt;&lt;&quot;中序遍历(非递归):&quot;&lt;&lt;endl; t1.inOrder0(t1.root); cout&lt;&lt;endl&lt;&lt;&quot;后序遍历(递归):&quot;&lt;&lt;endl; t1.postOrder0(t1.root); cout&lt;&lt;endl&lt;&lt;&quot;后序遍历(非递归):&quot;&lt;&lt;endl; t1.postOrder0(t1.root); cout&lt;&lt;endl; return 0;&#125;// 1// 2 3// 4 5 7//输入1 2 4 -1 -1 5 -1 -1 3 -1 7 -1 -1//层序: 1 2 3 4 5 7//前序: 1 2 4 5 3 7//中序: 4 2 5 1 3 7//后序: 4 5 2 7 3 1","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sch01ar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://sch01ar.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"2022祥云杯wp-crypto","slug":"2022-10-30-2022祥云杯wp-crypto","date":"2022-10-29T16:00:00.000Z","updated":"2022-12-07T09:43:16.370Z","comments":true,"path":"2022/10/30/2022-10-30-2022祥云杯wp-crypto/","link":"","permalink":"https://sch01ar.github.io/2022/10/30/2022-10-30-2022%E7%A5%A5%E4%BA%91%E6%9D%AFwp-crypto/","excerpt":"","text":"little little fermat 题目源码 1234567891011121314151617181920212223242526272829303132333435from Crypto.Util.number import *from random import *from libnum import *import gmpy2from secret import xflag = b&#x27;?????????&#x27;m = bytes_to_long(flag)def obfuscate(p, k): nbit = p.bit_length() while True: l1 = [getRandomRange(-1, 1) for _ in &#x27;_&#x27; * k] l2 = [getRandomRange(100, nbit) for _ in &#x27;_&#x27; * k] l3 = [getRandomRange(10, nbit//4) for _ in &#x27;_&#x27; * k] l4 = [getRandomRange(2, 6) for _ in &#x27;_&#x27; *k] A = sum([l1[_] * 2 ** ((l2[_]+l3[_])//l4[_]) for _ in range(0, k)]) q = p + A if isPrime(q) * A != 0: return qp = getPrime(512)q = obfuscate(p, 5)e = 65537n = p*qprint(f&#x27;n = &#123;n&#125;&#x27;)assert 114514 ** x % p == 1m = m ^ (x**2)c = pow(m, e, n)print(f&#x27;c = &#123;c&#125;&#x27;)&#x27;&#x27;&#x27;n = 141321067325716426375483506915224930097246865960474155069040176356860707435540270911081589751471783519639996589589495877214497196498978453005154272785048418715013714419926299248566038773669282170912502161620702945933984680880287757862837880474184004082619880793733517191297469980246315623924571332042031367393c = 81368762831358980348757303940178994718818656679774450300533215016117959412236853310026456227434535301960147956843664862777300751319650636299943068620007067063945453310992828498083556205352025638600643137849563080996797888503027153527315524658003251767187427382796451974118362546507788854349086917112114926883&#x27;&#x27;&#x27; 题目分析 根据题目名字来看，此题和费马小定理的使用有关，题目中有一个obfuscate函数，进行了对q的生成，q=p+A，这里可以看一下A的范围，是在2[18,319]之间，因此p、q接近，尝试一下yafu分解。 题目对m先进行了处理，再进行RSA加密，因此我们需要知道x。assert 114514 ** x % p == 1运用费马小定理，若114514与p互素，则x=p-1，即可求解m。 EXP 1234567891011121314151617from Crypto.Util.number import *import gmpy2import mathe=65537n = 141321067325716426375483506915224930097246865960474155069040176356860707435540270911081589751471783519639996589589495877214497196498978453005154272785048418715013714419926299248566038773669282170912502161620702945933984680880287757862837880474184004082619880793733517191297469980246315623924571332042031367393c = 81368762831358980348757303940178994718818656679774450300533215016117959412236853310026456227434535301960147956843664862777300751319650636299943068620007067063945453310992828498083556205352025638600643137849563080996797888503027153527315524658003251767187427382796451974118362546507788854349086917112114926883p = 11887853772894265642834649929578157180848240939084164222334476057487485972806971092902627112665734648016476153593841839977704512156756634066593725142934001q = 11887853772894265642834649929578157180848240939084164222334476057487485972806971092902627112665734646483980612727952939084061619889139517526028673988305393print(math.gcd(p,114514))#1x=p-1phi=(p-1)*(q-1)d=gmpy2.invert(e,phi)m0=pow(c,d,n)m=m0^(x**2)print(long_to_bytes(m))#flag&#123;I~ju5t_w@nt_30_te11_y0u_how_I_@m_f3ll1ng~&#125; fill 题目源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from Crypto.Util.number import *from random import *from gmpy2 import gcdfrom numpy import dotnbits = 32msg = getRandomNBitInteger(nbits)flag = b&#x27;flag&#123;sha256(msg)&#125;&#x27;tmp_m = bin(msg)[2:]f_list = []for i in range(len(tmp_m)): f_list.append(int(tmp_m[i]))r_list =[randint(20, 50)]for i in range(nbits - 1): r_list.append(randint(2 * r_list[-1], 3 * r_list[-1]))while True: A = randint(2 * r_list[-1] + 1, 3 * r_list[-1]) B = randint(2 * r_list[-1] + 1, 3 * r_list[-1]) if gcd(A, B) == 1: breakM = [A * x % B for x in r_list]S = dot(f_list, M)print(S)seed = getRandomNBitInteger(30)s = [0] * nbitss[0] = seedm = getRandomNBitInteger(20)c = getPrime(24)n = 991125622for i in range(1, nbits): s[i] = (s[i-1]*m+c)%nprint(s[0], s[1], s[2])for t in range(nbits): M[t] = M[t] + s[t]print(M)&#x27;&#x27;&#x27;492226042629702562734112 859151551 741682801M = [19621141192340, 39617541681643, 3004946591889, 6231471734951, 3703341368174, 48859912097514, 4386411556216, 11028070476391, 18637548953150, 29985057892414, 20689980879644, 20060557946852, 46908191806199, 8849137870273, 28637782510640, 35930273563752, 20695924342882, 36660291028583, 10923264012354, 29810154308143, 4444597606142, 31802472725414, 23368528779283, 15179021971456, 34642073901253, 44824809996134, 31243873675161, 27159321498211, 2220647072602, 20255746235462, 24667528459211, 46916059974372]&#x27;&#x27;&#x27; 题目分析 随机产生32位的数，sha256()加密后作为flag，并将其2进制的每一位存到了f_list数组中。 又 创建了一个r_list32位数组，里面存着随机数，先暂时不管。 双 对r_list数组中的随机数做了加密，产生了M数组。 对f_list和M数组进行了numpy.dot运算，即向量乘法，得到和为S。 叒 创建了一个s数组，这个很明显，用LCG线性同余算法进行了加密。 最后将M数组与s数组相加。 这就是这道题整体的流程，每一步并不难，只是步骤多，略显复杂。 EXP 0x01 可以先进行一下LCG的求解，把s数组求解出来，从而求出M数组。 1234567891011121314151617n = 991125622output =[562734112,859151551,741682801]MMI = lambda A, n,s=1,t=0,N=0: (n &lt; 2 and t%N or MMI(n, A%n, t, s-A//n*t, N or n),-1)[n&lt;1] #逆元计算a=(output[2]-output[1])*MMI((output[1]-output[0]),n)%nani=MMI(a,n)b=(output[1]-a*output[0])%nseed = 562734112a=55365664b= 8712091s = [0] * nbitss[0] = seedfor i in range(1, nbits): s[i] = (s[i-1]*a+b)%nM = [19621141192340, 39617541681643, 3004946591889, 6231471734951, 3703341368174, 48859912097514, 4386411556216, 11028070476391, 18637548953150, 29985057892414, 20689980879644, 20060557946852, 46908191806199, 8849137870273, 28637782510640, 35930273563752, 20695924342882, 36660291028583, 10923264012354, 29810154308143, 4444597606142, 31802472725414, 23368528779283, 15179021971456, 34642073901253, 44824809996134, 31243873675161, 27159321498211, 2220647072602, 20255746235462, 24667528459211, 46916059974372]for t in range(nbits): M[t] = M[t] - s[t] 0x02 按理来说，感觉应该根据求出来的M数组进行逆运算，求出r_list数组，但是求出来r_list有什么用呢，所以直接尝试求f_list。因为f_list中不是0就是1，与M做向量乘法，即为M数组中若干元素的和。根据题目给定和S，先大概看一下需要M中多少个元素累加。发现在M前21位和 &lt; S，前22位和 &gt; S，所以猜想应该是M当中，除10个左右元素之外的和。 这里就遍历了一下，复杂度实在太高了，也没想着能出，结果还真算出来了o.O 123456789101112131415 for a in range(nbits): for b in range(a,nbits): for c in range(b,nbits): for d in range(c,nbits): for e in range(d,nbits): for f in range(e,nbits): for g in range(f,nbits): for h in range(g,nbits): for i in range(h,nbits): for j in range(i,nbits): for k in range(j,nbits): if M[a]+M[b]+M[c]+M[d]+M[e]+M[f]+M[g] +M[h] + M[i] +M[j] +M[k] == sum-S: print(a,b,c,d,e,f,g,h,i,j,k) break#2 4 9 10 15 19 24 27 28 30 31 也就说明，f_list中下标为这些的，对应值是0，其余为1，即可得到msg的2进制数，转为十进制后进行sha256()加密即可。 12345678f = [&#x27;1&#x27;] * nbitsf[2]=f[4]=f[9]=f[10]=f[15]=f[19]=f[24]=f[27]=f[28]=f[30]=f[31]=&#x27;0&#x27;a=&quot;&quot;for i in range(nbits): a+=f[i]print(int(a,2))#3617517412#sha256加密后：8f504aee71626212f275117326722b6c0ccc94f4039ed31fbcfde08e026352c4，套上flag&#123;&#125;提交即可","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"2022NewStarCTF-flip_flop","slug":"2022NewStarCTF-flip_flop","date":"2022-10-26T16:00:00.000Z","updated":"2022-12-07T09:41:52.644Z","comments":true,"path":"2022/10/27/2022NewStarCTF-flip_flop/","link":"","permalink":"https://sch01ar.github.io/2022/10/27/2022NewStarCTF-flip_flop/","excerpt":"","text":"flip-flop AES-CBC加密模式 题目 源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import osfrom Crypto.Cipher import AESfrom secret import FLAGauth_major_key = os.urandom(16)BANNER = &quot;&quot;&quot;Login as admin to get the flag ! &quot;&quot;&quot;MENU = &quot;&quot;&quot;Enter your choice[1] Create NewStarCTF Account[2] Create Admin Account[3] Login[4] Exit&quot;&quot;&quot;print(BANNER)while True: print(MENU) option = int(input(&#x27;&gt; &#x27;)) if option == 1: auth_pt = b&#x27;NewStarCTFer____&#x27; user_key = os.urandom(16) cipher = AES.new(auth_major_key, AES.MODE_CBC, user_key) code = cipher.encrypt(auth_pt) print(f&#x27;here is your authcode: &#123;user_key.hex() + code.hex()&#125;&#x27;) elif option == 2: print(&#x27;GET OUT !!!!!!&#x27;) elif option == 3: authcode = input(&#x27;Enter your authcode &gt; &#x27;) user_key = bytes.fromhex(authcode)[:16] code = bytes.fromhex(authcode)[16:] cipher = AES.new(auth_major_key, AES.MODE_CBC, user_key) auth_pt = cipher.decrypt(code) if auth_pt == b&#x27;AdminAdmin______&#x27;: print(FLAG) elif auth_pt == b&#x27;NewStarCTFer____&#x27;: print(&#x27;Have fun!!&#x27;) else: print(&#x27;Who are you?&#x27;) elif option == 4: print(&#x27;ByeBye&#x27;) exit(0) else: print(&quot;WTF&quot;) ## 题目分析 此题是通过注册得到的用户账户的密文，然后输入管理员账户对应的密文，才能得到flag。 对用户账户和管理员账户的加密解密均采用AES-CBC模式，但是本题仅有一组明文，iv仅作为偏移量，也就是本题中的user_key。 这里先来说一下我最一开始的思路，由于user_key每次是随机产生的，但是一次程序的运行当中是不变的。由于密文由两部分组成，前半部分为user_key.hex()，后半部分为code.hex()，所以只要构造出admin对应的code即可，那么就需要AES加密当中的key，所以就需要构造一个key来产生出admin对应的code。查询了很多资料发现都难以实现。于是…… 那为什么不换一下思路？不能构造code，能不能构造iv？ 先来看一下加密方式： C = encrypt(M ^ iv) M = decrypt(C)^iv 对应一下本题当中的NewStarCTFer和admin： b'NewStarCTFer____' = decrypt(code) ^ iv1 b'AdminAdmin______' = decrypt(code) ^ iv2 因此可求出admin对应的iv2，随后拼接上普通用户的后半段code即可。 EXP 12345678910from Crypto.Util.number import *authcode= &quot;4f72b2079005a15e30efb3febea8cda266f4c3b47147e79167c3cde81ca84a4b&quot;n=bytes_to_long(b&#x27;NewStarCTFer____&#x27;)a=bytes_to_long(b&#x27;AdminAdmin______&#x27;)iv1= int(authcode[:len(authcode)//2],16)code = authcode[len(authcode)//2:]decode = iv1 ^ niv2 = a ^ decodeprint((hex(iv2)+code)[2:])#flag&#123;filp_the_word!!!!!!!!&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"BUU刷题日记20221026","slug":"BUU刷题日记20221026","date":"2022-10-25T16:00:00.000Z","updated":"2022-12-07T09:39:19.641Z","comments":true,"path":"2022/10/26/BUU刷题日记20221026/","link":"","permalink":"https://sch01ar.github.io/2022/10/26/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221026/","excerpt":"","text":"RSA5 题目分析 给定e=65537 给了很多组n、c 由于e过大，所以不考虑使用CRT，由于m是同一个，因此遍历一下，求出两个n的最大公约数，即为p，后续就简单了。 EXP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677n1 = 20474918894051778533305262345601880928088284471121823754049725354072477155873778848055073843345820697886641086842612486541250183965966001591342031562953561793332341641334302847996108417466360688139866505179689516589305636902137210185624650854906780037204412206309949199080005576922775773722438863762117750429327585792093447423980002401200613302943834212820909269713876683465817369158585822294675056978970612202885426436071950214538262921077409076160417436699836138801162621314845608796870206834704116707763169847387223307828908570944984416973019427529790029089766264949078038669523465243837675263858062854739083634207c1 = 974463908243330865728978769213595400782053398596897741316275722596415018912929508637393850919224969271766388710025195039896961956062895570062146947736340342927974992616678893372744261954172873490878805483241196345881721164078651156067119957816422768524442025688079462656755605982104174001635345874022133045402344010045961111720151990412034477755851802769069309069018738541854130183692204758761427121279982002993939745343695671900015296790637464880337375511536424796890996526681200633086841036320395847725935744757993013352804650575068136129295591306569213300156333650910795946800820067494143364885842896291126137320n2 = 20918819960648891349438263046954902210959146407860980742165930253781318759285692492511475263234242002509419079545644051755251311392635763412553499744506421566074721268822337321637265942226790343839856182100575539845358877493718334237585821263388181126545189723429262149630651289446553402190531135520836104217160268349688525168375213462570213612845898989694324269410202496871688649978370284661017399056903931840656757330859626183773396574056413017367606446540199973155630466239453637232936904063706551160650295031273385619470740593510267285957905801566362502262757750629162937373721291789527659531499435235261620309759c2 = 15819636201971185538694880505120469332582151856714070824521803121848292387556864177196229718923770810072104155432038682511434979353089791861087415144087855679134383396897817458726543883093567600325204596156649305930352575274039425470836355002691145864435755333821133969266951545158052745938252574301327696822347115053614052423028835532509220641378760800693351542633860702225772638930501021571415907348128269681224178300248272689705308911282208685459668200507057183420662959113956077584781737983254788703048275698921427029884282557468334399677849962342196140864403989162117738206246183665814938783122909930082802031855n3 = 25033254625906757272369609119214202033162128625171246436639570615263949157363273213121556825878737923265290579551873824374870957467163989542063489416636713654642486717219231225074115269684119428086352535471683359486248203644461465935500517901513233739152882943010177276545128308412934555830087776128355125932914846459470221102007666912211992310538890654396487111705385730502843589727289829692152177134753098649781412247065660637826282055169991824099110916576856188876975621376606634258927784025787142263367152947108720757222446686415627479703666031871635656314282727051189190889008763055811680040315277078928068816491c3 = 4185308529416874005831230781014092407198451385955677399668501833902623478395669279404883990725184332709152443372583701076198786635291739356770857286702107156730020004358955622511061410661058982622055199736820808203841446796305284394651714430918690389486920560834672316158146453183789412140939029029324756035358081754426645160033262924330248675216108270980157049705488620263485129480952814764002865280019185127662449318324279383277766416258142275143923532168798413011028271543085249029048997452212503111742302302065401051458066585395360468447460658672952851643547193822775218387853623453638025492389122204507555908862n4 = 21206968097314131007183427944486801953583151151443627943113736996776787181111063957960698092696800555044199156765677935373149598221184792286812213294617749834607696302116136745662816658117055427803315230042700695125718401646810484873064775005221089174056824724922160855810527236751389605017579545235876864998419873065217294820244730785120525126565815560229001887622837549118168081685183371092395128598125004730268910276024806808565802081366898904032509920453785997056150497645234925528883879419642189109649009132381586673390027614766605038951015853086721168018787523459264932165046816881682774229243688581614306480751c4 = 4521038011044758441891128468467233088493885750850588985708519911154778090597136126150289041893454126674468141393472662337350361712212694867311622970440707727941113263832357173141775855227973742571088974593476302084111770625764222838366277559560887042948859892138551472680654517814916609279748365580610712259856677740518477086531592233107175470068291903607505799432931989663707477017904611426213770238397005743730386080031955694158466558475599751940245039167629126576784024482348452868313417471542956778285567779435940267140679906686531862467627238401003459101637191297209422470388121802536569761414457618258343550613n5 = 22822039733049388110936778173014765663663303811791283234361230649775805923902173438553927805407463106104699773994158375704033093471761387799852168337898526980521753614307899669015931387819927421875316304591521901592823814417756447695701045846773508629371397013053684553042185725059996791532391626429712416994990889693732805181947970071429309599614973772736556299404246424791660679253884940021728846906344198854779191951739719342908761330661910477119933428550774242910420952496929605686154799487839923424336353747442153571678064520763149793294360787821751703543288696726923909670396821551053048035619499706391118145067c5 = 15406498580761780108625891878008526815145372096234083936681442225155097299264808624358826686906535594853622687379268969468433072388149786607395396424104318820879443743112358706546753935215756078345959375299650718555759698887852318017597503074317356745122514481807843745626429797861463012940172797612589031686718185390345389295851075279278516147076602270178540690147808314172798987497259330037810328523464851895621851859027823681655934104713689539848047163088666896473665500158179046196538210778897730209572708430067658411755959866033531700460551556380993982706171848970460224304996455600503982223448904878212849412357n6 = 21574139855341432908474064784318462018475296809327285532337706940126942575349507668289214078026102682252713757703081553093108823214063791518482289846780197329821139507974763780260290309600884920811959842925540583967085670848765317877441480914852329276375776405689784571404635852204097622600656222714808541872252335877037561388406257181715278766652824786376262249274960467193961956690974853679795249158751078422296580367506219719738762159965958877806187461070689071290948181949561254144310776943334859775121650186245846031720507944987838489723127897223416802436021278671237227993686791944711422345000479751187704426369c6 = 20366856150710305124583065375297661819795242238376485264951185336996083744604593418983336285185491197426018595031444652123288461491879021096028203694136683203441692987069563513026001861435722117985559909692670907347563594578265880806540396777223906955491026286843168637367593400342814725694366078337030937104035993569672959361347287894143027186846856772983058328919716702982222142848848117768499996617588305301483085428547267337070998767412540225911508196842253134355901263861121500650240296746702967594224401650220168780537141654489215019142122284308116284129004257364769474080721001708734051264841350424152506027932n7 = 25360227412666612490102161131174584819240931803196448481224305250583841439581008528535930814167338381983764991296575637231916547647970573758269411168219302370541684789125112505021148506809643081950237623703181025696585998044695691322012183660424636496897073045557400768745943787342548267386564625462143150176113656264450210023925571945961405709276631990731602198104287528528055650050486159837612279600415259486306154947514005408907590083747758953115486124865486720633820559135063440942528031402951958557630833503775112010715604278114325528993771081233535247118481765852273252404963430792898948219539473312462979849137c7 = 19892772524651452341027595619482734356243435671592398172680379981502759695784087900669089919987705675899945658648623800090272599154590123082189645021800958076861518397325439521139995652026377132368232502108620033400051346127757698623886142621793423225749240286511666556091787851683978017506983310073524398287279737680091787333547538239920607761080988243639547570818363788673249582783015475682109984715293163137324439862838574460108793714172603672477766831356411304446881998674779501188163600664488032943639694828698984739492200699684462748922883550002652913518229322945040819064133350314536378694523704793396169065179n8 = 22726855244632356029159691753451822163331519237547639938779517751496498713174588935566576167329576494790219360727877166074136496129927296296996970048082870488804456564986667129388136556137013346228118981936899510687589585286517151323048293150257036847475424044378109168179412287889340596394755257704938006162677656581509375471102546261355748251869048003600520034656264521931808651038524134185732929570384705918563982065684145766427962502261522481994191989820110575981906998431553107525542001187655703534683231777988419268338249547641335718393312295800044734534761692799403469497954062897856299031257454735945867491191c8 = 6040119795175856407541082360023532204614723858688636724822712717572759793960246341800308149739809871234313049629732934797569781053000686185666374833978403290525072598774001731350244744590772795701065129561898116576499984185920661271123665356132719193665474235596884239108030605882777868856122378222681140570519180321286976947154042272622411303981011302586225630859892731724640574658125478287115198406253847367979883768000812605395482952698689604477719478947595442185921480652637868335673233200662100621025061500895729605305665864693122952557361871523165300206070325660353095592778037767395360329231331322823610060006n9 = 23297333791443053297363000786835336095252290818461950054542658327484507406594632785712767459958917943095522594228205423428207345128899745800927319147257669773812669542782839237744305180098276578841929496345963997512244219376701787616046235397139381894837435562662591060768476997333538748065294033141610502252325292801816812268934171361934399951548627267791401089703937389012586581080223313060159456238857080740699528666411303029934807011214953984169785844714159627792016926490955282697877141614638806397689306795328344778478692084754216753425842557818899467945102646776342655167655384224860504086083147841252232760941c9 = 5418120301208378713115889465579964257871814114515046096090960159737859076829258516920361577853903925954198406843757303687557848302302200229295916902430205737843601806700738234756698575708612424928480440868739120075888681672062206529156566421276611107802917418993625029690627196813830326369874249777619239603300605876865967515719079797115910578653562787899019310139945904958024882417833736304894765433489476234575356755275147256577387022873348906900149634940747104513850154118106991137072643308620284663108283052245750945228995387803432128842152251549292698947407663643895853432650029352092018372834457054271102816934n10 = 28873667904715682722987234293493200306976947898711255064125115933666968678742598858722431426218914462903521596341771131695619382266194233561677824357379805303885993804266436810606263022097900266975250431575654686915049693091467864820512767070713267708993899899011156106766178906700336111712803362113039613548672937053397875663144794018087017731949087794894903737682383916173267421403408140967713071026001874733487295007501068871044649170615709891451856792232315526696220161842742664778581287321318748202431466508948902745314372299799561625186955234673012098210919745879882268512656931714326782335211089576897310591491c10 = 9919880463786836684987957979091527477471444996392375244075527841865509160181666543016317634963512437510324198702416322841377489417029572388474450075801462996825244657530286107428186354172836716502817609070590929769261932324275353289939302536440310628698349244872064005700644520223727670950787924296004296883032978941200883362653993351638545860207179022472492671256630427228461852668118035317021428675954874947015197745916918197725121122236369382741533983023462255913924692806249387449016629865823316402366017657844166919846683497851842388058283856219900535567427103603869955066193425501385255322097901531402103883869n11 = 22324685947539653722499932469409607533065419157347813961958075689047690465266404384199483683908594787312445528159635527833904475801890381455653807265501217328757871352731293000303438205315816792663917579066674842307743845261771032363928568844669895768092515658328756229245837025261744260614860746997931503548788509983868038349720225305730985576293675269073709022350700836510054067641753713212999954307022524495885583361707378513742162566339010134354907863733205921845038918224463903789841881400814074587261720283879760122070901466517118265422863420376921536734845502100251460872499122236686832189549698020737176683019c11 = 1491527050203294989882829248560395184804977277747126143103957219164624187528441047837351263580440686474767380464005540264627910126483129930668344095814547592115061057843470131498075060420395111008619027199037019925701236660166563068245683975787762804359520164701691690916482591026138582705558246869496162759780878437137960823000043988227303003876410503121370163303711603359430764539337597866862508451528158285103251810058741879687875218384160282506172706613359477657215420734816049393339593755489218588796607060261897905233453268671411610631047340459487937479511933450369462213795738933019001471803157607791738538467n12 = 27646746423759020111007828653264027999257847645666129907789026054594393648800236117046769112762641778865620892443423100189619327585811384883515424918752749559627553637785037359639801125213256163008431942593727931931898199727552768626775618479833029101249692573716030706695702510982283555740851047022672485743432464647772882314215176114732257497240284164016914018689044557218920300262234652840632406067273375269301008409860193180822366735877288205783314326102263756503786736122321348320031950012144905869556204017430593656052867939493633163499580242224763404338807022510136217187779084917996171602737036564991036724299c12 = 21991524128957260536043771284854920393105808126700128222125856775506885721971193109361315961129190814674647136464887087893990660894961612838205086401018885457667488911898654270235561980111174603323721280911197488286585269356849579263043456316319476495888696219344219866516861187654180509247881251251278919346267129904739277386289240394384575124331135655943513831009934023397457082184699737734388823763306805326430395849935770213817533387235486307008892410920611669932693018165569417445885810825749609388627231235840912644654685819620931663346297596334834498661789016450371769203650109994771872404185770230172934013971n13 = 20545487405816928731738988374475012686827933709789784391855706835136270270933401203019329136937650878386117187776530639342572123237188053978622697282521473917978282830432161153221216194169879669541998840691383025487220850872075436064308499924958517979727954402965612196081404341651517326364041519250125036424822634354268773895465698920883439222996581226358595873993976604699830613932320720554130011671297944433515047180565484495191003887599891289037982010216357831078328159028953222056918189365840711588671093333013117454034313622855082795813122338562446223041211192277089225078324682108033843023903550172891959673551c13 = 14227439188191029461250476692790539654619199888487319429114414557975376308688908028140817157205579804059783807641305577385724758530138514972962209062230576107406142402603484375626077345190883094097636019771377866339531511965136650567412363889183159616188449263752475328663245311059988337996047359263288837436305588848044572937759424466586870280512424336807064729894515840552404756879590698797046333336445465120445087587621743906624279621779634772378802959109714400516183718323267273824736540168545946444437586299214110424738159957388350785999348535171553569373088251552712391288365295267665691357719616011613628772175n14 = 27359727711584277234897157724055852794019216845229798938655814269460046384353568138598567755392559653460949444557879120040796798142218939251844762461270251672399546774067275348291003962551964648742053215424620256999345448398805278592777049668281558312871773979931343097806878701114056030041506690476954254006592555275342579529625231194321357904668512121539514880704046969974898412095675082585315458267591016734924646294357666924293908418345508902112711075232047998775303603175363964055048589769318562104883659754974955561725694779754279606726358588862479198815999276839234952142017210593887371950645418417355912567987c14 = 3788529784248255027081674540877016372807848222776887920453488878247137930578296797437647922494510483767651150492933356093288965943741570268943861987024276610712717409139946409513963043114463933146088430004237747163422802959250296602570649363016151581364006795894226599584708072582696996740518887606785460775851029814280359385763091078902301957226484620428513604630585131511167015763190591225884202772840456563643159507805711004113901417503751181050823638207803533111429510911616160851391754754434764819568054850823810901159821297849790005646102129354035735350124476838786661542089045509656910348676742844957008857457n15 = 27545937603751737248785220891735796468973329738076209144079921449967292572349424539010502287564030116831261268197384650511043068738911429169730640135947800885987171539267214611907687570587001933829208655100828045651391618089603288456570334500533178695238407684702251252671579371018651675054368606282524673369983034682330578308769886456335818733827237294570476853673552685361689144261552895758266522393004116017849397346259119221063821663280935820440671825601452417487330105280889520007917979115568067161590058277418371493228631232457972494285014767469893647892888681433965857496916110704944758070268626897045014782837c15 = 14069112970608895732417039977542732665796601893762401500878786871680645798754783315693511261740059725171342404186571066972546332813667711135661176659424619936101038903439144294886379322591635766682645179888058617577572409307484708171144488708410543462972008179994594087473935638026612679389759756811490524127195628741262871304427908481214992471182859308828778119005750928935764927967212343526503410515793717201360360437981322576798056276657140363332700714732224848346808963992302409037706094588964170239521193589470070839790404597252990818583717869140229811712295005710540476356743378906642267045723633874011649259842n16 = 25746162075697911560263181791216433062574178572424600336856278176112733054431463253903433128232709054141607100891177804285813783247735063753406524678030561284491481221681954564804141454666928657549670266775659862814924386584148785453647316864935942772919140563506305666207816897601862713092809234429096584753263707828899780979223118181009293655563146526792388913462557306433664296966331469906428665127438829399703002867800269947855869262036714256550075520193125987011945192273531732276641728008406855871598678936585324782438668746810516660152018244253008092470066555687277138937298747951929576231036251316270602513451c16 = 17344284860275489477491525819922855326792275128719709401292545608122859829827462088390044612234967551682879954301458425842831995513832410355328065562098763660326163262033200347338773439095709944202252494552172589503915965931524326523663289777583152664722241920800537867331030623906674081852296232306336271542832728410803631170229642717524942332390842467035143631504401140727083270732464237443915263865880580308776111219718961746378842924644142127243573824972533819479079381023103585862099063382129757560124074676150622288706094110075567706403442920696472627797607697962873026112240527498308535903232663939028587036724n17 = 23288486934117120315036919418588136227028485494137930196323715336208849327833965693894670567217971727921243839129969128783853015760155446770590696037582684845937132790047363216362087277861336964760890214059732779383020349204803205725870225429985939570141508220041286857810048164696707018663758416807708910671477407366098883430811861933014973409390179948577712579749352299440310543689035651465399867908428885541237776143404376333442949397063249223702355051571790555151203866821867908531733788784978667478707672984539512431549558672467752712004519300318999208102076732501412589104904734983789895358753664077486894529499c17 = 10738254418114076548071448844964046468141621740603214384986354189105236977071001429271560636428075970459890958274941762528116445171161040040833357876134689749846940052619392750394683504816081193432350669452446113285638982551762586656329109007214019944975816434827768882704630460001209452239162896576191876324662333153835533956600295255158377025198426950944040643235430211011063586032467724329735785947372051759042138171054165854842472990583800899984893232549092766400510300083585513014171220423103452292891496141806956300396540682381668367564569427813092064053993103537635994311143010708814851867239706492577203899024n18 = 19591441383958529435598729113936346657001352578357909347657257239777540424811749817783061233235817916560689138344041497732749011519736303038986277394036718790971374656832741054547056417771501234494768509780369075443550907847298246275717420562375114406055733620258777905222169702036494045086017381084272496162770259955811174440490126514747876661317750649488774992348005044389081101686016446219264069971370646319546429782904810063020324704138495608761532563310699753322444871060383693044481932265801505819646998535192083036872551683405766123968487907648980900712118052346174533513978009131757167547595857552370586353973c18= 3834917098887202931981968704659119341624432294759361919553937551053499607440333234018189141970246302299385742548278589896033282894981200353270637127213483172182529890495903425649116755901631101665876301799865612717750360089085179142750664603454193642053016384714515855868368723508922271767190285521137785688075622832924829248362774476456232826885801046969384519549385428259591566716890844604696258783639390854153039329480726205147199247183621535172450825979047132495439603840806501254997167051142427157381799890725323765558803808030109468048682252028720241357478614704610089120810367192414352034177484688502364022887n19 = 19254242571588430171308191757871261075358521158624745702744057556054652332495961196795369630484782930292003238730267396462491733557715379956969694238267908985251699834707734400775311452868924330866502429576951934279223234676654749272932769107390976321208605516299532560054081301829440688796904635446986081691156842271268059970762004259219036753174909942343204432795076377432107630203621754552804124408792358220071862369443201584155711893388877350138023238624566616551246804054720492816226651467017802504094070614892556444425915920269485861799532473383304622064493223627552558344088839860178294589481899206318863310603c19 = 6790553533991297205804561991225493105312398825187682250780197510784765226429663284220400480563039341938599783346724051076211265663468643826430109013245014035811178295081939958687087477312867720289964506097819762095244479129359998867671811819738196687884696680463458661374310994610760009474264115750204920875527434486437536623589684519411519100170291423367424938566820315486507444202022408003879118465761273916755290898112991525546114191064022991329724370064632569903856189236177894007766690782630247443895358893983735822824243487181851098787271270256780891094405121947631088729917398317652320497765101790132679171889n20 = 26809700251171279102974962949184411136459372267620535198421449833298448092580497485301953796619185339316064387798092220298630428207556482805739803420279056191194360049651767412572609187680508073074653291350998253938793269214230457117194434853888765303403385824786231859450351212449404870776320297419712486574804794325602760347306432927281716160368830187944940128907971027838510079519466846176106565164730963988892400240063089397720414921398936399927948235195085202171264728816184532651138221862240969655185596628285814057082448321749567943946273776184657698104465062749244327092588237927996419620170254423837876806659c20 = 386213556608434013769864727123879412041991271528990528548507451210692618986652870424632219424601677524265011043146748309774067894985069288067952546139416819404039688454756044862784630882833496090822568580572859029800646671301748901528132153712913301179254879877441322285914544974519727307311002330350534857867516466612474769753577858660075830592891403551867246057397839688329172530177187042229028685862036140779065771061933528137423019407311473581832405899089709251747002788032002094495379614686544672969073249309703482556386024622814731015767810042969813752548617464974915714425595351940266077021672409858645427346n=[n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12,n13,n14,n15,n16,n17,n18,n19,n20]import mathimport gmpy2from Crypto.Util.number import long_to_bytesfor i in range(20): for j in range(i+1,20): if math.gcd(n[i],n[j]) &gt; 1: p=math.gcd(n[i],n[j]) print(i,j,p) break#i=4,j=17e=65537q = n[4]// pphi4=(p-1)*(q-1)d=gmpy2.invert(e,phi4)m=pow(c5,d,n[4])print(long_to_bytes(m))# b&#x27;flag&#123;abdcbe5fd94e23b3de429223ab9c2fdf&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"2022 DASCTF 10月挑战赛wp","slug":"2022DASCTF10月挑战赛wp","date":"2022-10-22T16:00:00.000Z","updated":"2022-12-07T09:42:51.960Z","comments":true,"path":"2022/10/23/2022DASCTF10月挑战赛wp/","link":"","permalink":"https://sch01ar.github.io/2022/10/23/2022DASCTF10%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwp/","excerpt":"","text":"RSA 题目如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from Crypto.Util.number import *from secret import flagn_2 = 675835056744450121024004008337170937331109883435712066354955474563267257037603081555653829598886559337325172694278764741403348512872239277008719548968016702852609803016353158454788807563316656327979897318887566108985783153878668451688372252234938716250621575338314779485058267785731636967957494369458211599823364746908763588582489400785865427060804408606617016267936273888743392372620816053927031794575978032607311497491069242347165424963308662091557862342478844612402720375931726316909635118113432836702120449010n_3 = 91294511667572917673898699346231897684542006136956966126836916292947639514392684487940336406038086150289315439796780158189004157494824987037667065310517044311794725172075653186677331434123198117797575528982908532086038107428540586044471407073066169603930082133459486076777574046803264038780927350142555712567e_1 = 65537e_2 = 3c_1 = 47029848959680138397125259006172340325269302342762903311733700258745280761154948381409328053449580957972265859283407071931484707002138926840483316880087281153554181290481533c_2 = 332431c_3 = 11951299411967534922967467740790967733301092706094553308467975774492025797106594440070380723007894861454249455013202734019215071856834943490096156048504952328784989777263664832098681831398770963056616417301705739505187754236801407014715780468333977293887519001724078504320344074325196167699818117367329779609m = 9530454742891231590945778054072843874837824815724564463369259282490619049557772650832818763768769359762168560563265763313176741847581931364k = 8139616873420730499092246564709331937498029453340099806219977060224838957080870950877930756958455278369862703151353509623205172658012437573652818022676431def encrypt1(n): n1 = hex(n&gt;&gt;200).encode() n2 = str(hex(n))[20:].encode() return n1,n2def encrypt2(m , n_1): c_1 = pow(m,e_1,n_1) print(&#x27;c_1 = &#x27;+str(c_1))def encrypt3(m , n_2): c_2 = pow( m , e_2 , n_2) print(&#x27;c_2 = &#x27;+str(c_2))def encrypt4(m): k = getPrime(512) m = m % k c_3 = pow(m, e_2, n_3) print(&#x27;c_3 = &#x27; + str(c_3)) print(&#x27;m = &#x27; + str(m)) print(&#x27;k = &#x27; + str(k))m1,m2 = encrypt1(flag)m1 = bytes_to_long(m1)m2 = bytes_to_long(m2)print(&#x27;n_2 = &#x27; + str(n_2))print(&#x27;n_3 = &#x27; + str(n_3))print(&#x27;e_1 = &#x27; + str(e_1))print(&#x27;e_2 = &#x27; + str(e_2))encrypt2(m1,n_1)encrypt3(n_1,n_2)encrypt4(m2) 题目分析 该题的加密顺序是： 1、加密flag，分为两部分m1、m2 2、加密m1 3、加密m2 同理我们解密的顺序应该也是 1、解出m1、m2 2、解出flag 求m2 先观察一下encrypt4函数 虽然说e_2=3，按理来说使用低加密指数攻击，但并不可行。 又因为m = m % k 可通过这点和c_3 = pow(m, e_2, n_3)做遍历求出m 最后发现m即为m2，m2 &lt; k 求m1 发现m1加密方式采用RSA，但是n_1未知 n_1又通过一次RSA加密，已知n_1对应的密文 利用低加密指数攻击解出n1 发现n1可分解为3个素数乘积 故phi可求，即求出m1 求flag 观察encryt1 m1是flag右移200位之后转为字节 m2是flag的20位之后转成字节 所以来说m2是没什么问题，主要找到flag的前20位，再把m2拼到后面即可。 由于m1是flag右移200位，因此flag的低位缺失，但高位还在，由于不知道flag总长度，抱着试一试的心态，猜测一下它的高位前20位没有缺失 我们将m1和m2转为字节发现 m1:b'0x666c61677b3230366538353964' m2:b'383539643865383534633466363030636231323735376262663966357d' 发现m1和m2有重叠部分，即38353开始 可以证实m1前20位确实没有缺失 因此取m1前20位，加m2，即可解出flag EXP 1234567891011121314151617181920212223242526272829303132333435363738394041import mathfrom typing import ByteStringimport gmpy2from Crypto.Util.number import *n_2 = 675835056744450121024004008337170937331109883435712066354955474563267257037603081555653829598886559337325172694278764741403348512872239277008719548968016702852609803016353158454788807563316656327979897318887566108985783153878668451688372252234938716250621575338314779485058267785731636967957494369458211599823364746908763588582489400785865427060804408606617016267936273888743392372620816053927031794575978032607311497491069242347165424963308662091557862342478844612402720375931726316909635118113432836702120449010e_2=3c_1 = 47029848959680138397125259006172340325269302342762903311733700258745280761154948381409328053449580957972265859283407071931484707002138926840483316880087281153554181290481533c_2 = 332431def dec(c,e,n): i=0 while(1): m1=c+n*i result,flag=gmpy2.iroot(m1,e) if flag==True: return result i+=1n_1=70406706457855863712635967741447303613971473150228480705119773604469794649140239446237334040048504811343327173817296308781190911727763110615393368497803655390445303946160971p_1=2732337821e_1 = 65537t_1=2224243981q_1=11585031296201346891716939633970482508158508580350404805965250133832632323150440185890235814142601827544669601048550999405490149435265122374459158586377571phi_1=(p_1-1)*(q_1-1)*(t_1-1)d_1=gmpy2.invert(e_1,phi_1)m1=pow(c_1,d_1,n_1)c=pow(m1,e_1,n_1)n_3 = 91294511667572917673898699346231897684542006136956966126836916292947639514392684487940336406038086150289315439796780158189004157494824987037667065310517044311794725172075653186677331434123198117797575528982908532086038107428540586044471407073066169603930082133459486076777574046803264038780927350142555712567c_3 = 11951299411967534922967467740790967733301092706094553308467975774492025797106594440070380723007894861454249455013202734019215071856834943490096156048504952328784989777263664832098681831398770963056616417301705739505187754236801407014715780468333977293887519001724078504320344074325196167699818117367329779609m = 9530454742891231590945778054072843874837824815724564463369259282490619049557772650832818763768769359762168560563265763313176741847581931364k = 8139616873420730499092246564709331937498029453340099806219977060224838957080870950877930756958455278369862703151353509623205172658012437573652818022676431m2=long_to_bytes(m)print(m2)print(long_to_bytes(m1)[:20])m=0x666c61677b32303665383539643865383534633466363030636231323735376262663966357dprint(long_to_bytes(m))# b&#x27;383539643865383534633466363030636231323735376262663966357d&#x27;# b&#x27;0x666c61677b32303665&#x27;# b&#x27;flag&#123;206e859d8e854c4f600cb12757bbf9f5&#125;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"BUU刷题日记20221022","slug":"BUU刷题日记20221022","date":"2022-10-21T16:00:00.000Z","updated":"2022-12-07T09:40:10.592Z","comments":true,"path":"2022/10/22/BUU刷题日记20221022/","link":"","permalink":"https://sch01ar.github.io/2022/10/22/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221022/","excerpt":"","text":"RSA4 题目只给了三组n、c，采用中国剩余定理，具体推导如下 推导过程 me ≡ c1 mod n1 me ≡ c2 mod n2 me ≡ c3 mod n3 中国剩余定理（CRT） 中国剩余定理的内容是： 针对上述方程组，若n1、n2、n3互质，对于任意的c1、c2、c3，方程组都有解，使用条件是m^e &lt; n1、n2、n3。通解形式如下： 令N = n1 * n2 * n3，N1 = N/n1，N2、N3同理 令t1 = N1(-1)，即其对应的模n1运算的逆元，t2，t3同理，可用t1=gmpy2.invert(N1,n1)表示。 有了Ni和ti的定义，我们就可以给出通解形式： x = c1 * N1 * t1 …… 有了通解公式我们就可以求出m^e，对e进行一下遍历即可，m开方成功即可。 EXP 123456789101112131415161718192021222324252627import gmpy2from sympy.ntheory.modular import crtfrom Crypto.Util.number import long_to_bytese = 3n1 = &#x27;331310324212000030020214312244232222400142410423413104441140203003243002104333214202031202212403400220031202142322434104143104244241214204444443323000244130122022422310201104411044030113302323014101331214303223312402430402404413033243132101010422240133122211400434023222214231402403403200012221023341333340042343122302113410210110221233241303024431330001303404020104442443120130000334110042432010203401440404010003442001223042211442001413004&#x27;c1 = &#x27;310020004234033304244200421414413320341301002123030311202340222410301423440312412440240244110200112141140201224032402232131204213012303204422003300004011434102141321223311243242010014140422411342304322201241112402132203101131221223004022003120002110230023341143201404311340311134230140231412201333333142402423134333211302102413111111424430032440123340034044314223400401224111323000242234420441240411021023100222003123214343030122032301042243&#x27;n2 = &#x27;302240000040421410144422133334143140011011044322223144412002220243001141141114123223331331304421113021231204322233120121444434210041232214144413244434424302311222143224402302432102242132244032010020113224011121043232143221203424243134044314022212024343100042342002432331144300214212414033414120004344211330224020301223033334324244031204240122301242232011303211220044222411134403012132420311110302442344021122101224411230002203344140143044114&#x27;c2 = &#x27;112200203404013430330214124004404423210041321043000303233141423344144222343401042200334033203124030011440014210112103234440312134032123400444344144233020130110134042102220302002413321102022414130443041144240310121020100310104334204234412411424420321211112232031121330310333414423433343322024400121200333330432223421433344122023012440013041401423202210124024431040013414313121123433424113113414422043330422002314144111134142044333404112240344&#x27;n3 = &#x27;332200324410041111434222123043121331442103233332422341041340412034230003314420311333101344231212130200312041044324431141033004333110021013020140020011222012300020041342040004002220210223122111314112124333211132230332124022423141214031303144444134403024420111423244424030030003340213032121303213343020401304243330001314023030121034113334404440421242240113103203013341231330004332040302440011324004130324034323430143102401440130242321424020323&#x27;c3 = &#x27;10013444120141130322433204124002242224332334011124210012440241402342100410331131441303242011002101323040403311120421304422222200324402244243322422444414043342130111111330022213203030324422101133032212042042243101434342203204121042113212104212423330331134311311114143200011240002111312122234340003403312040401043021433112031334324322123304112340014030132021432101130211241134422413442312013042141212003102211300321404043012124332013240431242&#x27;c1=int(c1,5)n1=int(n1,5)c2=int(c2,5)n2=int(n2,5)c3=int(c3,5)n3=int(n3,5)e=3n=[n1,n2,n3]c=[c1,c2,c3]resultant,mod= crt(n, c)# 有现成的库函数可以调用print(gmpy2.iroot(resultant, e))m=259362307225540148883586283191025214233097658309244310540770399135748418469298031742173624766441014006294782333print(long_to_bytes(m))#noxCTF&#123;D4mn_y0u_h4s74d_wh47_4_b100dy_b4s74rd!&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"BUU刷题日记20221021","slug":"BUU刷题日记20221021","date":"2022-10-20T16:00:00.000Z","updated":"2022-12-08T05:42:21.849Z","comments":true,"path":"2022/10/21/BUU刷题日记20221021/","link":"","permalink":"https://sch01ar.github.io/2022/10/21/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221021/","excerpt":"","text":"RSA2 题目给定n、e、dp、c 非预期解：直接分解n 下面考虑n不能分解的情况 推导过程 dp ≡ d mod (p-1) ed ≡ 1 mod (p-1) * (q-1) ed = 1 + k2(p-1)(q-1) 对1式两端同乘e，得 e * dp ≡ ed mod (p-1) e * dp = k1(p-1) + ed 代入ed得 e * dp = k1(p-1) + 1 + k2(p-1)(q-1) 由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余p-1，即可消掉n e * dp ≡ 1 mod (p-1) e * dp =k(p-1) + 1 得到这个式子后，其实真正意义上的未知数只有我们要求的p，但是还存在一个k。 针对k，我们判断一下他的范围，看看能否采用爆破的方式。 k = (e * dp - 1)/(p-1) 因为dp &lt; p-1 所以k &lt; e 通过遍历k然后找到(e * dp - 1)可以整除k的情况即可。 (跑了一下发现限制条件还不够) 因此再加一个n能否整除p即可。 EXP 1234567891011121314151617181920import gmpy2from Crypto.Util.number import long_to_bytese = 65537n = 248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113dp = 905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657c = 140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751# p = 13468634736343473907717969603434376212206335187555458742257940406618189481177835992217885676243155145465521141546915941147336786447889325606555333350540003# q = 18432009829596386103558375461387837845170621179295293289126504231317130550979989727125205467379713835047300158256398009229511746203459540859429194971855371for k in range(1,e): if (e*dp-1)%k == 0: p=(e*dp-1)//k + 1 if n%p == 0: print(p) breakq=n//pphi= (p-1)*(q-1)d= gmpy2.invert(e,phi)m=pow(c,d,n)print(long_to_bytes(m))#flag&#123;wow_leaking_dp_breaks_rsa?_98924743502&#125; RSA3 给定n、e1、c1、e2、c2。 m ≡ c1^e1 mod n m ≡ c2^e2 mod n 这里采用共模攻击，详细原理如下： 扩展欧几里得算法：给定两个整数a、b，必定存在x、y，使得gcd(a,b)=ax+by 对应到本题当中，由于e1、e2互为素数，因此gcd(e1,e2)=1，从而存在s1、s2使得: s1 * e1 + s2 * e2 = 1 推导过程 m = m % n m = m^(s1 * e1 + s2 * e2)^ % n m = m^(e1 * s1)^ * m^(e2 * s2)^ % n m = (m^(e1 * s1)^ % n) * (m^(e2 * s2)^ % n) % n m = (c1s1 % n) * (c2s2 % n) % n EXP 123456789101112import gmpy2from Crypto.Util.number import long_to_bytesc1=22322035275663237041646893770451933509324701913484303338076210603542612758956262869640822486470121149424485571361007421293675516338822195280313794991136048140918842471219840263536338886250492682739436410013436651161720725855484866690084788721349555662019879081501113222996123305533009325964377798892703161521852805956811219563883312896330156298621674684353919547558127920925706842808914762199011054955816534977675267395009575347820387073483928425066536361482774892370969520740304287456555508933372782327506569010772537497541764311429052216291198932092617792645253901478910801592878203564861118912045464959832566051361n=22708078815885011462462049064339185898712439277226831073457888403129378547350292420267016551819052430779004755846649044001024141485283286483130702616057274698473611149508798869706347501931583117632710700787228016480127677393649929530416598686027354216422565934459015161927613607902831542857977859612596282353679327773303727004407262197231586324599181983572622404590354084541788062262164510140605868122410388090174420147752408554129789760902300898046273909007852818474030770699647647363015102118956737673941354217692696044969695308506436573142565573487583507037356944848039864382339216266670673567488871508925311154801e1=11187289c2=18702010045187015556548691642394982835669262147230212731309938675226458555210425972429418449273410535387985931036711854265623905066805665751803269106880746769003478900791099590239513925449748814075904017471585572848473556490565450062664706449128415834787961947266259789785962922238701134079720414228414066193071495304612341052987455615930023536823801499269773357186087452747500840640419365011554421183037505653461286732740983702740822671148045619497667184586123657285604061875653909567822328914065337797733444640351518775487649819978262363617265797982843179630888729407238496650987720428708217115257989007867331698397e2=9647291r,s1,s2=gmpy2.gcdext(e1,e2)m=(pow(c1,s1,n) * pow(c2,s2,n)) %nprint(long_to_bytes(m))#flag&#123;49d91077a1abcb14f1a9d546c80be9ef&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"BUU刷题日记20221020","slug":"BUU刷题日记20221020","date":"2022-10-19T16:00:00.000Z","updated":"2022-12-06T07:25:59.850Z","comments":true,"path":"2022/10/20/BUU刷题日记20221020/","link":"","permalink":"https://sch01ar.github.io/2022/10/20/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221020/","excerpt":"","text":"RSA1 给定dp、dq类型 dp ≡ d mod (p-1) dq ≡ d mod (q-1) m ≡ cd mod n m = cd + k * n m = cd +k * p * q 对上式两端同时对p、q分别取余，得：（中国剩余定理） m1 ≡ cd mod p m2 ≡ cd mod q 同理，可得到 cd = m1 +k * p 代入到 m2 ≡ cd mod q 中： m2 ≡ (m1 + k * p)mod q ，两端减去m1得 m2 - m1 ≡ k * p mod q ，两端乘p的逆元得 (m2 - m1)p-1 ≡ k mod q 将k代入到 cd = m1 +k * p 中得： cd = m1 + ((m2 - m1)p-1 mod q) * p m=cd mod n 得到 m ≡ (((m2 - m1) * p-1 mod q) * p + m1) mod n 接下来就是求解m1，m2 m1 ≡ cdp+k(p-1) mod p m2 ≡ cdq+k(q-1) mod q 根据费马小定理 若p是素数，则a(p-1) ≡ 1 mod p 因此 m1 ≡ cdp mod p，m2 ≡ cdq mod q 最终可求得m exp 1234567891011121314import gmpy2from Crypto.Util.number import long_to_bytesp = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852m1=pow(c,dp,p)m2=pow(c,dq,q)n=p*qp0=gmpy2.invert(p,q)m=(((m2-m1)*p0 % q)* p +m1)%nprint(long_to_bytes(m))#noxCTF&#123;W31c0m3_70_Ch1n470wn&#125; RSAROLL 1234RSA roll！roll！roll！Only number and a-z（don&#x27;t use editorwhich MS provide） 给了一个data.txt文件，打开盲猜一下第一行是n，e，后面是c 1234567891011121314151617import gmpy2from Crypto.Util.number import long_to_bytesn = 920139713e = 19p=18443q=49891phi =(p-1)*(q-1)d=gmpy2.invert(e,phi)c=[704796792,752211152,274704164,18414022,368270835,483295235,263072905,459788476,483295235,459788476,663551792,475206804,459788476,428313374,475206804,459788476,425392137,704796792,458265677,341524652,483295235,534149509,425392137,428313374,425392137,341524652,458265677,263072905,483295235,828509797,341524652,425392137,475206804,428313374,483295235,475206804,459788476,306220148,]m=[]flag=b&#x27;&#x27;for i in range (len(c)): m.append(pow(c[i],d,n)) flag+=long_to_bytes(m[i])print(flag)#flag&#123;13212je2ue28fy71w8u87y31r78eu1e2&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"}]},{"title":"2021ByteCTF-easyxor","slug":"2021ByteCTF-easyxor","date":"2022-10-15T16:00:00.000Z","updated":"2022-12-07T09:34:59.756Z","comments":true,"path":"2022/10/16/2021ByteCTF-easyxor/","link":"","permalink":"https://sch01ar.github.io/2022/10/16/2021ByteCTF-easyxor/","excerpt":"","text":"题目源码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#! /usr/bin/env pythonfrom Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randint, getrandbitsdef shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; cdef convert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(4): m = shift(m, key[t], c_list[t]) return mdef encrypt(m, k, iv, mode=&#x27;CBC&#x27;): assert len(m) % 8 == 0 num = len(m) // 8 groups = [] for i in range(num): groups.append(bytes_to_long(m[i * 8: (i + 1) * 8])) last = iv cipher = [] if mode == &#x27;CBC&#x27;: for eve in groups: cur = eve ^ last cur_c = convert(cur, k) cipher.append(cur_c) last = cur_c elif mode == &#x27;OFB&#x27;: for eve in groups: cur_c = convert(last, k) cipher.append(cur_c ^ eve) last = cur_c else: print &#x27;Not supported now!&#x27; return &#x27;&#x27;.join([hex(eve)[2:].strip(&#x27;L&#x27;).rjust(16, &#x27;0&#x27;) for eve in cipher])if __name__ == &#x27;__main__&#x27;: from secret import flag if len(flag) % 8 != 0: flag += &#x27;$&#x27; * (8 - len(flag) % 8) length = len(flag) num = length // 8 keys = [randint(-32, 32) for _ in range(4)] IV = getrandbits(64) front = flag[:length // 2] back = flag[length // 2:] cipher1 = encrypt(front, keys, IV, mode=&#x27;OFB&#x27;) cipher2 = encrypt(back, keys, IV) print cipher1 + cipher2#89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912 题目分析 将flag分为两段，前半段采用OFB加密，后半段采用CBC加密 OFB解密 将前半段flag又进行切分，将其8位分为一组，存到group数组中。 123456#主要加密代码elif mode == &#x27;OFB&#x27;: for eve in groups: cur_c = convert(last, k) cipher.append(cur_c ^ eve) last = cur_c 针对一个随机生成的64位的last，与keys进行convert加密，再与group中的数进行异或。 keys是四个-32～32的数，可爆破。 对于OFB解密十分简单，因为我们已知第一组明文，恰好是8位的'ByteCTF{'，由于分组密码的性质，所以后面的也就迎刃而解，通过group[ 0]^cipher[ 0] 即可得到cur_c，从而求得下一次的cur_c，以此类推。 expOFB 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#OFB解密#! /usr/bin/env pythonfrom Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randint, getrandbitsdef shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; cdef convert(m, key): c_list = [ 0x37386180AF9AE39E, 0xAF754E29895EE11A, 0x85E1A429A2B7030C, 0x964C5A89F6D3AE8C, ] for t in range(4): m = shift(m, key[t], c_list[t]) return mdef check(s): c=1 for i in s: if 32&lt;=i&lt;=127: continue else: c=0 break return cc = &quot;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912&quot;c=c[:len(c)//2]cipher = []for i in range(len(c)//16): cipher.append(int(c[i*16:(i+1)*16],16))flag = b&#x27;ByteCTF&#123;&#x27;m0 = bytes_to_long(flag)m_m = m0 ^ cipher[0]for a in range(-32,32): for b in range(-32,32): for c in range(-32,32): for d in range(-32,32): keys=[a,b,c,d] m_m1=convert(m_m,keys) m1=long_to_bytes((m_m1^cipher[1])) if check(m1): m_m2 = convert(m_m1, keys) m2 = long_to_bytes((m_m2 ^ cipher[2])) if check(m2): flag+=m1 flag+=m2 print(flag) print(a,b,c,d)#b&#x27;ByteCTF&#123;5831a241s-f30980&#x27;#keys：-12 26 -3 -31 CBC解密 针对后半部分，我们需要逆向解出convert函数，因此就是对shift函数中的加密运算进行解密。 之前上网搜的wp都一笔带过，没解释unshift逆函数怎么写的。“难道有什么定理？？” 这里简单写一下我的理解。 分析shift 1234def shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; c 推理过程 这里我们举例k&gt;0时的情况。（k&lt;0同理） m和c都是64位,k是-32～32的10进制数。 1、m &lt;&lt; k相当于在m后补k位0，得到的新数我们称为a，a=m &lt;&lt; k。 2、令b = a &amp; c，由于a是64+k位，c是64位，所以b是64位，并且b的后k位都是0。 3、令x = m ^ b，x则是shift加密之后的值，x也是64位，并且x的后k位是与m的后k位相同的，与0异或得本身。 我们走完了一遍shift加密，得到的结论是，密文的位数同样是64，并且密文的后k位与明文相同。 分析unshift 12345678910def unshift(m, k, c, bits=64): tmp = m if k &lt; 0: for i in range(bits // (-k)): tmp = m ^ tmp &gt;&gt; (-k) &amp; c else: for i in range(bits // k): tmp = m ^ tmp &lt;&lt; k &amp; c assert shift(tmp, k, c) == m return tmp 推理过程 同样我们举例k&gt;0的情况。 之前我们得到的密文x，相当于tmp。 1、a'=tmp &lt;&lt; k，tmp后k位为0，tmp后2k～k位等于m的后k位。 2、b'=a' &amp; c，b'后k位为0，后2k～k位为m&amp;c。 3、y=x ^ b'，y的后k位，等于x的后k位，也就是m的后k位。 4、y的后2k～k位，在shift加密当中，a &amp; c的后2k～k位等于m的后k位&amp;c，记作m1 &amp; c。 shift中的x，也就是m ^ b，m ^(m1 &amp; c)，在unshift最后的一步操作中，y= m ^(m1 &amp; c) ^ b'。 这时我们只考虑y的后2k～k位，y=m ^(m1 &amp; c)^(m1 &amp; c) = m 所以这时y的2k～k位也等于m了。 总结 因此，我们发现每经过unshift一次，就有k位被还原，何时才能被完全还原？即循环bits//k次。 此推理正确，可以在unshift函数运行时输出每次的tmp观察即可。 ps：自我感觉这种位运算应该是属于一种性质或者定理，网上大佬们都是说“简单写个逆”。。。 expCBC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randint, getrandbitsdef shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; cdef unconvert(m, key): tmp = m c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(3,-1,-1): m = unshift(m, key[t], c_list[t]) return mdef unshift(m, k, c, bits=64): tmp = m if k &lt; 0: for i in range(bits // (-k)): tmp = m ^ tmp &gt;&gt; (-k) &amp; c else: for i in range(bits // k): tmp = m ^ tmp &lt;&lt; k &amp; c assert shift(tmp, k, c) == m return tmpkeys=[-12,26,-3,-31]c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c]flag=b&#x27;ByteCTF&#123;&#x27;flag=bytes_to_long(flag)iv=16476971533267772345c = &quot;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912&quot;c=c[len(c)//2:]cipher = []for i in range(len(c)//16): cipher.append(int(c[i*16:(i+1)*16],16))group=[]curc1=unconvert(cipher[0],keys)group.append(long_to_bytes(curc1^iv))curc2=unconvert(cipher[1],keys)group.append(long_to_bytes(curc2^cipher[0]))curc3=unconvert(cipher[2],keys)group.append(long_to_bytes(curc3^cipher[1]))group[0]+=group[1]group[0]+=group[2]print(group[0])#b&#x27;q535af-2156547475u2t&#125;$$$&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"2022BUUCTF新生赛-RSA","slug":"2022BUUCTF新生赛-RSA","date":"2022-10-15T16:00:00.000Z","updated":"2022-12-08T07:35:16.441Z","comments":true,"path":"2022/10/16/2022BUUCTF新生赛-RSA/","link":"","permalink":"https://sch01ar.github.io/2022/10/16/2022BUUCTF%E6%96%B0%E7%94%9F%E8%B5%9B-RSA/","excerpt":"","text":"题目源码 123456789101112131415161718from Crypto.Util.number import *import gmpy2m = bytes_to_long(flag)p = getPrime(512)q = getPrime(512)n = p * p * qe = 0x10001d = inverse(e, p * (p-1) * (q-1))assert m &lt; nc = pow(m, e, n)hint = pow(d, e, n)print(f&#x27;c = &#123;c&#125;&#x27;)print(f&#x27;hint = &#123;hint&#125;&#x27;)print(f&#x27;n = &#123;n&#125;&#x27;)#c = 295390424904695335160238045484482823778874523176268561514416832384667341911461624807479360352155340771798064104910086195729675369023485015714514440154903376061747094964841316582559859939271083212458383263813162552258150862316694340739316654325015871916752667846321388549685578217102034863664378037876690856340358410405404601972377258035410485778168718251025950362254734939336524237028597772764421048442121802994478847811235518434239824115849516645106981074204342#hint = 381689393821386814936953643422859595359427105930487728052490073810065861656721298489533943537291889430179955685768552743683931382858386278229412048061640902207419922278984960983464060741314251570306423515751064678573919676919458734440112312205062810416467534525851481716577433432802746104452081670842385746300503903217917867773267569384218933894515975838815295351900841003897643955266573211223356519224254883905741607839206824725522319870208594077622555096443077#n = 1330047950007581682981905423145560321016033324862143764072994099149659943994269827526733343998097272206411640734177032076844564188190644548214106206913310385320478977860962140014336074250277764844699709526956803401392604949854612016074894825128737598849968249437120905834713554348840283463250157701334045079523107114507765969484185723955713386597151991074970735613177368468450679646585239506590480790958808030534070060413924423517044064816910208776798401702408317 题目分析 发现n和phin都不常规，没入手点，发现hint，hint=pow(d,e,n)，有趣，用d做明文，尝试推理一下： d = pow(hint,d,n) d = pow((d ** e % n),d,n) d = (d ** e % n) ** d % n d = d ** (e*d) % n d = pow(d e,d,n) 把d e再次看做密文，可得 d e = pow(d,e,n) 因为hint = pow(d,e,n) 可得hint = d e d e * e e-&gt;(ed) e-&gt;(ed) e == 1 mod phin 因此根据e和hint即可求得phin 从而得到phin和n的最大公约数p 脚本如下 1234567891011121314from Crypto.Util.number import *import gmpy2import mathe = 0x10001c = 295390424904695335160238045484482823778874523176268561514416832384667341911461624807479360352155340771798064104910086195729675369023485015714514440154903376061747094964841316582559859939271083212458383263813162552258150862316694340739316654325015871916752667846321388549685578217102034863664378037876690856340358410405404601972377258035410485778168718251025950362254734939336524237028597772764421048442121802994478847811235518434239824115849516645106981074204342hint = 381689393821386814936953643422859595359427105930487728052490073810065861656721298489533943537291889430179955685768552743683931382858386278229412048061640902207419922278984960983464060741314251570306423515751064678573919676919458734440112312205062810416467534525851481716577433432802746104452081670842385746300503903217917867773267569384218933894515975838815295351900841003897643955266573211223356519224254883905741607839206824725522319870208594077622555096443077n = 1330047950007581682981905423145560321016033324862143764072994099149659943994269827526733343998097272206411640734177032076844564188190644548214106206913310385320478977860962140014336074250277764844699709526956803401392604949854612016074894825128737598849968249437120905834713554348840283463250157701334045079523107114507765969484185723955713386597151991074970735613177368468450679646585239506590480790958808030534070060413924423517044064816910208776798401702408317p=math.gcd((hint*pow(e,e) -1),n)q=n//(p**2)phi=p*(p-1)*(q-1)d=gmpy2.invert(e,phi)m=pow(c,d,n)print(long_to_bytes(m))#flag&#123;43075d24-77a7-4f57-ae89-54fe4f96db69&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"}]},{"title":"梦开始的地方","slug":"梦开始的地方","date":"2022-10-15T07:59:58.000Z","updated":"2022-12-01T05:15:04.679Z","comments":true,"path":"2022/10/15/梦开始的地方/","link":"","permalink":"https://sch01ar.github.io/2022/10/15/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/","excerpt":"","text":"Mac下利用Hexo和github pages搭建个人博客 环境配置 1.Node.js安装 下载地址：Node.js 2.淘宝镜像安装 12//打开终端terminal$ npm install -g cnpm --registry=https://registry.npm.taobao.org 3.安装Hexo 1234// 使用命令去安装Hexocnpm install -g hexo-cli//安装成功后查看版本hexo -v 初始化Hexo Blog 1.初始化Hexo 新建一个文件夹并进入，例如blog 12//初始化hexohexo init #### 2.本地启动Hexo 1hexo s 浏览器打开网站，即可看到本地博客 创建博客文章 1.创建文章 1hexo n &quot;我的第一篇文章&quot; 在blog文件夹中的_post里即可看到新建的md文件 #### 2.清理缓存项目 在新建博客或修改博客时，需要进行该操作 1hexo clean #### 3.重新生成博客 1hexo g 4.启动博客 1hexo d","categories":[{"name":"建站","slug":"建站","permalink":"https://sch01ar.github.io/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://sch01ar.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-10-15T07:57:23.442Z","updated":"2022-12-01T05:15:29.274Z","comments":true,"path":"2022/10/15/hello-world/","link":"","permalink":"https://sch01ar.github.io/2022/10/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://sch01ar.github.io/categories/CTF/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://sch01ar.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"建站","slug":"建站","permalink":"https://sch01ar.github.io/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"lattice","slug":"lattice","permalink":"https://sch01ar.github.io/tags/lattice/"},{"name":"wp","slug":"wp","permalink":"https://sch01ar.github.io/tags/wp/"},{"name":"非对称加密","slug":"非对称加密","permalink":"https://sch01ar.github.io/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"},{"name":"二叉树","slug":"二叉树","permalink":"https://sch01ar.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"diary","slug":"diary","permalink":"https://sch01ar.github.io/tags/diary/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://sch01ar.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}