{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"2022-10-16T02:33:28.077Z","updated":"2022-10-16T01:15:58.120Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-10-16T02:33:21.117Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-10-16T02:30:27.247Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-10-17T01:02:57.129Z","updated":"2022-10-15T08:09:45.464Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-10-16T03:25:28.438Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-10-16T02:41:49.050Z","updated":"2022-10-15T08:09:45.464Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"BUU刷题日记20221020","slug":"BUU刷题日记20221020","date":"2022-10-19T16:00:00.000Z","updated":"2022-10-20T10:19:01.419Z","comments":true,"path":"2022/10/20/BUU刷题日记20221020/","link":"","permalink":"http://example.com/2022/10/20/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221020/","excerpt":"","text":"RSA1给定dp、dq类型dp ≡ d mod (p-1)dq ≡ d mod (q-1)m ≡ c^d^ mod nm &#x3D; c^d^ + k * nm &#x3D; c^d^ +k * p * q对上式两端同时对p、q分别取余，得：（中国剩余定理）$$m1 ≡ c^d mod p$$m2 ≡ c^d^ mod q同理，可得到c^d^ &#x3D; m1 +k * p代入到 m2 ≡ c^d^ mod q 中：m2 ≡ (m1 + k * p)mod q ，两端减去m1得m2 - m1 ≡ k * p mod q ，两端乘p的逆元得(m2 - m1)p^-1^ ≡ k mod q将k代入到 c^d^ &#x3D; m1 +k * p 中得：c^d^ &#x3D; m1 + ((m2 - m1)p^-1^ mod q) * pm&#x3D;c^d^ mod n得到m ≡ (((m2 - m1) * p^-1^ mod q) * p + m1) mod n接下来就是求解m1，m2m1 ≡ c^dp+k*(p-1)^ mod pm2 ≡ c^dq+k*(q-1)^ mod q根据&#x3D;&#x3D;费马小定理&#x3D;&#x3D;若p是素数，则a^(p-1)^ ≡ 1 mod p因此 m1 ≡ c^dp^ mod p，m2 ≡ c^dq^ mod q最终可求得m exp1234567891011121314import gmpy2from Crypto.Util.number import long_to_bytesp = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852m1=pow(c,dp,p)m2=pow(c,dq,q)n=p*qp0=gmpy2.invert(p,q)m=(((m2-m1)*p0 % q)* p +m1)%nprint(long_to_bytes(m))#noxCTF&#123;W31c0m3_70_Ch1n470wn&#125; RSAROLL1234RSA roll！roll！roll！Only number and a-z（don&#x27;t use editorwhich MS provide） 给了一个data.txt文件，打开盲猜一下第一行是n，e，后面是c 1234567891011121314151617import gmpy2from Crypto.Util.number import long_to_bytesn = 920139713e = 19p=18443q=49891phi =(p-1)*(q-1)d=gmpy2.invert(e,phi)c=[704796792,752211152,274704164,18414022,368270835,483295235,263072905,459788476,483295235,459788476,663551792,475206804,459788476,428313374,475206804,459788476,425392137,704796792,458265677,341524652,483295235,534149509,425392137,428313374,425392137,341524652,458265677,263072905,483295235,828509797,341524652,425392137,475206804,428313374,483295235,475206804,459788476,306220148,]m=[]flag=b&#x27;&#x27;for i in range (len(c)): m.append(pow(c[i],d,n)) flag+=long_to_bytes(m[i])print(flag)#flag&#123;13212je2ue28fy71w8u87y31r78eu1e2&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://example.com/tags/diary/"}]},{"title":"2021ByteCTF-easyxor","slug":"2021ByteCTF-easyxor","date":"2022-10-15T16:00:00.000Z","updated":"2022-10-20T06:12:18.079Z","comments":true,"path":"2022/10/16/2021ByteCTF-easyxor/","link":"","permalink":"http://example.com/2022/10/16/2021ByteCTF-easyxor/","excerpt":"","text":"[TOC] 题目源码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#! /usr/bin/env pythonfrom Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randint, getrandbitsdef shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; cdef convert(m, key): c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(4): m = shift(m, key[t], c_list[t]) return mdef encrypt(m, k, iv, mode=&#x27;CBC&#x27;): assert len(m) % 8 == 0 num = len(m) // 8 groups = [] for i in range(num): groups.append(bytes_to_long(m[i * 8: (i + 1) * 8])) last = iv cipher = [] if mode == &#x27;CBC&#x27;: for eve in groups: cur = eve ^ last cur_c = convert(cur, k) cipher.append(cur_c) last = cur_c elif mode == &#x27;OFB&#x27;: for eve in groups: cur_c = convert(last, k) cipher.append(cur_c ^ eve) last = cur_c else: print &#x27;Not supported now!&#x27; return &#x27;&#x27;.join([hex(eve)[2:].strip(&#x27;L&#x27;).rjust(16, &#x27;0&#x27;) for eve in cipher])if __name__ == &#x27;__main__&#x27;: from secret import flag if len(flag) % 8 != 0: flag += &#x27;$&#x27; * (8 - len(flag) % 8) length = len(flag) num = length // 8 keys = [randint(-32, 32) for _ in range(4)] IV = getrandbits(64) front = flag[:length // 2] back = flag[length // 2:] cipher1 = encrypt(front, keys, IV, mode=&#x27;OFB&#x27;) cipher2 = encrypt(back, keys, IV) print cipher1 + cipher2#89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912 题目分析将flag分为两段，前半段采用OFB加密，后半段采用CBC加密 OFB解密将前半段flag又进行切分，将其8位分为一组，存到group数组中。 123456#主要加密代码elif mode == &#x27;OFB&#x27;: for eve in groups: cur_c = convert(last, k) cipher.append(cur_c ^ eve) last = cur_c 针对一个随机生成的64位的last，与keys进行convert加密，再与group中的数进行异或。keys是四个-32～32的数，可爆破。对于OFB解密十分简单，因为我们已知第一组明文，恰好是8位的’ByteCTF{‘，由于分组密码的性质，所以后面的也就迎刃而解，通过group[ 0]^cipher[ 0] 即可得到cur_c，从而求得下一次的cur_c，以此类推。 expOFB123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#OFB解密#! /usr/bin/env pythonfrom Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randint, getrandbitsdef shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; cdef convert(m, key): c_list = [ 0x37386180AF9AE39E, 0xAF754E29895EE11A, 0x85E1A429A2B7030C, 0x964C5A89F6D3AE8C, ] for t in range(4): m = shift(m, key[t], c_list[t]) return mdef check(s): c=1 for i in s: if 32&lt;=i&lt;=127: continue else: c=0 break return cc = &quot;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912&quot;c=c[:len(c)//2]cipher = []for i in range(len(c)//16): cipher.append(int(c[i*16:(i+1)*16],16))flag = b&#x27;ByteCTF&#123;&#x27;m0 = bytes_to_long(flag)m_m = m0 ^ cipher[0]for a in range(-32,32): for b in range(-32,32): for c in range(-32,32): for d in range(-32,32): keys=[a,b,c,d] m_m1=convert(m_m,keys) m1=long_to_bytes((m_m1^cipher[1])) if check(m1): m_m2 = convert(m_m1, keys) m2 = long_to_bytes((m_m2 ^ cipher[2])) if check(m2): flag+=m1 flag+=m2 print(flag) print(a,b,c,d)#b&#x27;ByteCTF&#123;5831a241s-f30980&#x27;#keys：-12 26 -3 -31 CBC解密针对后半部分，我们需要逆向解出convert函数，因此就是对shift函数中的加密运算进行解密。之前上网搜的wp都一笔带过，没解释unshift逆函数怎么写的。“难道有什么定理？？”这里简单写一下我的理解。 分析shift1234def shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; c 推理过程这里我们举例k&gt;0时的情况。（k&lt;0同理）m和c都是64位,k是-32～32的10进制数。1、m &lt;&lt; k相当于在m后补k位0，得到的新数我们称为a，a&#x3D;m &lt;&lt; k。2、令b &#x3D; a &amp; c，由于a是64+k位，c是64位，所以b是64位，并且b的后k位都是0。3、令x &#x3D; m ^ b，x则是shift加密之后的值，x也是64位，并且x的后k位是与m的后k位相同的，与0异或得本身。我们走完了一遍shift加密，得到的结论是，密文的位数同样是64，并且密文的后k位与明文相同。 分析unshift12345678910def unshift(m, k, c, bits=64): tmp = m if k &lt; 0: for i in range(bits // (-k)): tmp = m ^ tmp &gt;&gt; (-k) &amp; c else: for i in range(bits // k): tmp = m ^ tmp &lt;&lt; k &amp; c assert shift(tmp, k, c) == m return tmp 推理过程同样我们举例k&gt;0的情况。之前我们得到的密文x，相当于tmp。1、a’&#x3D;tmp &lt;&lt; k，tmp后k位为0，tmp后2k～k位等于m的后k位。2、b’&#x3D;a’ &amp; c，b’后k位为0，后2k～k位为m&amp;c。3、y&#x3D;x ^ b’，y的后k位，等于x的后k位，也就是m的后k位。4、y的后2k～k位，在shift加密当中，a &amp; c的后2k～k位等于m的后k位&amp;c，记作m1 &amp; c。shift中的x，也就是m ^ b，m ^(m1 &amp; c)，在unshift最后的一步操作中，y&#x3D; m ^(m1 &amp; c) ^ b’。这时我们只考虑y的后2k～k位，y&#x3D;m ^(m1 &amp; c)^(m1 &amp; c) &#x3D; m所以这时y的2k～k位也等于m了。 总结因此，我们发现每经过unshift一次，就有k位被还原，何时才能被完全还原？即循环bits&#x2F;&#x2F;k次。此推理正确，可以在unshift函数运行时输出每次的tmp观察即可。ps：自我感觉这种位运算应该是属于一种性质或者定理，网上大佬们都是说“简单写个逆”。。。 expCBC12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from Crypto.Util.number import bytes_to_long, long_to_bytesfrom random import randint, getrandbitsdef shift(m, k, c): if k &lt; 0: return m ^ m &gt;&gt; (-k) &amp; c return m ^ m &lt;&lt; k &amp; cdef unconvert(m, key): tmp = m c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c] for t in range(3,-1,-1): m = unshift(m, key[t], c_list[t]) return mdef unshift(m, k, c, bits=64): tmp = m if k &lt; 0: for i in range(bits // (-k)): tmp = m ^ tmp &gt;&gt; (-k) &amp; c else: for i in range(bits // k): tmp = m ^ tmp &lt;&lt; k &amp; c assert shift(tmp, k, c) == m return tmpkeys=[-12,26,-3,-31]c_list = [0x37386180af9ae39e, 0xaf754e29895ee11a, 0x85e1a429a2b7030c, 0x964c5a89f6d3ae8c]flag=b&#x27;ByteCTF&#123;&#x27;flag=bytes_to_long(flag)iv=16476971533267772345c = &quot;89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912&quot;c=c[len(c)//2:]cipher = []for i in range(len(c)//16): cipher.append(int(c[i*16:(i+1)*16],16))group=[]curc1=unconvert(cipher[0],keys)group.append(long_to_bytes(curc1^iv))curc2=unconvert(cipher[1],keys)group.append(long_to_bytes(curc2^cipher[0]))curc3=unconvert(cipher[2],keys)group.append(long_to_bytes(curc3^cipher[1]))group[0]+=group[1]group[0]+=group[2]print(group[0])#b&#x27;q535af-2156547475u2t&#125;$$$&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"}]},{"title":"2022BUUCTF新生赛-RSA","slug":"2022BUUCTF新生赛-RSA","date":"2022-10-15T16:00:00.000Z","updated":"2022-10-16T12:37:14.514Z","comments":true,"path":"2022/10/16/2022BUUCTF新生赛-RSA/","link":"","permalink":"http://example.com/2022/10/16/2022BUUCTF%E6%96%B0%E7%94%9F%E8%B5%9B-RSA/","excerpt":"","text":"题目源码123456789101112131415161718from Crypto.Util.number import *import gmpy2m = bytes_to_long(flag)p = getPrime(512)q = getPrime(512)n = p * p * qe = 0x10001d = inverse(e, p * (p-1) * (q-1))assert m &lt; nc = pow(m, e, n)hint = pow(d, e, n)print(f&#x27;c = &#123;c&#125;&#x27;)print(f&#x27;hint = &#123;hint&#125;&#x27;)print(f&#x27;n = &#123;n&#125;&#x27;)#c = 295390424904695335160238045484482823778874523176268561514416832384667341911461624807479360352155340771798064104910086195729675369023485015714514440154903376061747094964841316582559859939271083212458383263813162552258150862316694340739316654325015871916752667846321388549685578217102034863664378037876690856340358410405404601972377258035410485778168718251025950362254734939336524237028597772764421048442121802994478847811235518434239824115849516645106981074204342#hint = 381689393821386814936953643422859595359427105930487728052490073810065861656721298489533943537291889430179955685768552743683931382858386278229412048061640902207419922278984960983464060741314251570306423515751064678573919676919458734440112312205062810416467534525851481716577433432802746104452081670842385746300503903217917867773267569384218933894515975838815295351900841003897643955266573211223356519224254883905741607839206824725522319870208594077622555096443077#n = 1330047950007581682981905423145560321016033324862143764072994099149659943994269827526733343998097272206411640734177032076844564188190644548214106206913310385320478977860962140014336074250277764844699709526956803401392604949854612016074894825128737598849968249437120905834713554348840283463250157701334045079523107114507765969484185723955713386597151991074970735613177368468450679646585239506590480790958808030534070060413924423517044064816910208776798401702408317 题目分析发现n和phin都不常规，没入手点，发现hint，hint&#x3D;pow(d,e,n)，有趣，用d做明文，尝试推理一下：d &#x3D; pow(hint,d,n)d &#x3D; pow((d ** e % n),d,n)d &#x3D; (d ** e % n) ** d % nd &#x3D; d ** (e*d) % nd &#x3D; pow(d ** e,d,n)把d ** e再次看做密文，可得d ** e &#x3D; pow(d,e,n)因为hint &#x3D; pow(d,e,n)可得hint &#x3D; d ** ed ** e * e ** e-&gt;(ed) ** e-&gt;(ed) ** e &#x3D;&#x3D; 1 mod phin因此根据e和hint即可求得phin从而得到phin和n的最大公约数p脚本如下 1234567891011121314from Crypto.Util.number import *import gmpy2import mathe = 0x10001c = 295390424904695335160238045484482823778874523176268561514416832384667341911461624807479360352155340771798064104910086195729675369023485015714514440154903376061747094964841316582559859939271083212458383263813162552258150862316694340739316654325015871916752667846321388549685578217102034863664378037876690856340358410405404601972377258035410485778168718251025950362254734939336524237028597772764421048442121802994478847811235518434239824115849516645106981074204342hint = 381689393821386814936953643422859595359427105930487728052490073810065861656721298489533943537291889430179955685768552743683931382858386278229412048061640902207419922278984960983464060741314251570306423515751064678573919676919458734440112312205062810416467534525851481716577433432802746104452081670842385746300503903217917867773267569384218933894515975838815295351900841003897643955266573211223356519224254883905741607839206824725522319870208594077622555096443077n = 1330047950007581682981905423145560321016033324862143764072994099149659943994269827526733343998097272206411640734177032076844564188190644548214106206913310385320478977860962140014336074250277764844699709526956803401392604949854612016074894825128737598849968249437120905834713554348840283463250157701334045079523107114507765969484185723955713386597151991074970735613177368468450679646585239506590480790958808030534070060413924423517044064816910208776798401702408317p=math.gcd((hint*pow(e,e) -1),n)q=n//(p**2)phi=p*(p-1)*(q-1)d=gmpy2.invert(e,phi)m=pow(c,d,n)print(long_to_bytes(m))#flag&#123;43075d24-77a7-4f57-ae89-54fe4f96db69&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"}]},{"title":"梦开始的地方","slug":"梦开始的地方","date":"2022-10-15T07:59:58.000Z","updated":"2022-10-16T05:22:27.882Z","comments":true,"path":"2022/10/15/梦开始的地方/","link":"","permalink":"http://example.com/2022/10/15/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/","excerpt":"","text":"Mac下利用Hexo和github pages搭建个人博客环境配置1.Node.js安装下载地址：Node.js 2.淘宝镜像安装12//打开终端terminal$ npm install -g cnpm --registry=https://registry.npm.taobao.org 3.安装Hexo1234// 使用命令去安装Hexocnpm install -g hexo-cli//安装成功后查看版本hexo -v 初始化Hexo Blog1.初始化Hexo新建一个文件夹并进入，例如blog 12//初始化hexohexo init 2.本地启动Hexo1hexo s 浏览器打开网站，即可看到本地博客 创建博客文章1.创建文章1hexo n &quot;我的第一篇文章&quot; 在blog文件夹中的_post里即可看到新建的md文件 2.清理缓存项目在新建博客或修改博客时，需要进行该操作 1hexo clean 3.重新生成博客1hexo g 4.启动博客1hexo d","categories":[{"name":"建站","slug":"建站","permalink":"http://example.com/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-10-15T07:57:23.442Z","updated":"2022-10-15T07:57:23.442Z","comments":true,"path":"2022/10/15/hello-world/","link":"","permalink":"http://example.com/2022/10/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"},{"name":"建站","slug":"建站","permalink":"http://example.com/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://example.com/tags/diary/"},{"name":"wp","slug":"wp","permalink":"http://example.com/tags/wp/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}