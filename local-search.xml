<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2023寒假集合</title>
    <link href="/2023/02/04/2023%E5%AF%92%E5%81%87%E9%9B%86%E5%90%88/"/>
    <url>/2023/02/04/2023%E5%AF%92%E5%81%87%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1>ECC</h1><h2 id="sage-环境"><a class="header-anchor" href="#sage-环境">¶</a>sage 环境</h2><p>进行简单运算</p><p>&lt;!–code￼0–&gt;</p><h2 id="ECDLP"><a class="header-anchor" href="#ECDLP">¶</a>ECDLP</h2><p>给定椭圆曲线 E，已知 P、Q 以及$Q=kP$，求 k。</p><p>&lt;!–code￼1–&gt;</p><h3 id="RWCTF2023-体验赛"><a class="header-anchor" href="#RWCTF2023-体验赛">¶</a>RWCTF2023 体验赛</h3><h1>RSA</h1><h2 id="rabin"><a class="header-anchor" href="#rabin">¶</a>rabin</h2><p>适用于 RSA 中 e=2 的情况</p><h3 id="pqpq-seccon2022"><a class="header-anchor" href="#pqpq-seccon2022">¶</a>pqpq(seccon2022)</h3><p>&lt;!–code￼2–&gt;</p><h4 id="大致思路"><a class="header-anchor" href="#大致思路">¶</a>大致思路</h4><p>根据题目，可先通过计算 c1、c2 表达式，合并找出公因子，即可求出 p、q，从而 r 也可求得。<br>发现 e=65537 * 2，因此是无逆元存在的，索性就将 e 拆分为 65537 与 2，e2=2 时便可通过 Rabin 算法解密。</p><h4 id="求-p、q、r"><a class="header-anchor" href="#求-p、q、r">¶</a>求 p、q、r</h4><p>$c2 = (p - q)^e \mod n \$<br>左右同乘 r<br>$c2 * r = rp^e + rq^e + X*pqr = rp^e + rq^e \mod n\$<br>$c2 = p^e + q^e \mod n\$<br>同理得到$c1 = p^e - q^e \mod n \$<br>从而求得 p、q<br>$p=gcd(c1+c2,n)\$</p><p>$q=gcd(c1-c2,n)\$</p><h4 id="求解-m-2"><a class="header-anchor" href="#求解-m-2">¶</a>求解 m^2</h4><p>$\phi(n)=(p-1)<em>(q-1)</em>(r-1)\$<br>通过 e1(e/2)和$\phi(n)$求出 d，得到$cm<sup>d=m</sup>{2<em>e1</em>d}=m^2 \mod n$</p><h4 id="Rabin-解密"><a class="header-anchor" href="#Rabin-解密">¶</a>Rabin 解密</h4><p>接下来就是传统 Rabin 解密，找了两种脚本，exp 中的<code>sqrtPrime(n,p)</code>和<code>Tonelli_Shanks(n,p)</code>任选其一即可，都是基于二次剩余定理所实现的解密算法</p><p>&lt;!–code￼3–&gt;</p><h2 id=""><a class="header-anchor" href="#">¶</a></h2>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RSA补充</title>
    <link href="/2022/12/07/RSA%E8%A1%A5%E5%85%85/"/>
    <url>/2022/12/07/RSA%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1>回顾</h1><p>RSA 中加、解密：</p><p>加密$c = m^e\quad mod\quad n$</p><p>解密$m = c^d\quad mod\quad n$</p><p>接下来证明一下解密过程，先引入欧拉定理。</p><h2 id="欧拉定理"><a class="header-anchor" href="#欧拉定理">¶</a>欧拉定理</h2><p>对于互为质数的 m、n 两个数，有$m^{\phi(n)} = 1\quad mod\quad n$，其中$\phi(n)$表示小于 n 的质数的个数。</p><h2 id="解密原理"><a class="header-anchor" href="#解密原理">¶</a>解密原理</h2><p>通过$c = m^e\quad mod\quad n$与欧拉定理$m^{\phi(n)} = 1\quad mod\quad n$，我们便可进行推导。</p><p>对欧拉定理进行变形，得到$m^{k\phi(n)+1} = m\quad mod\quad n$</p><p>因为我们已经知道$c = m^e\quad mod\quad n$，所以寻找一个 d，使得$ed = k\phi(n)+1$,则可以得到$m^{ed}=m\quad mod \quad n$</p><p>则得到了$c^d =m\quad mod\quad n$</p><h1>共模攻击</h1><p>所谓共模，就是 n 相同，会对应多组 c，e。</p><p>例：给定 n、c1、c2、e1、e2</p><p>m = c<sub>1</sub><sup>e1</sup> mod n</p><p>m = c<sub>2</sub><sup>e2</sup> mod n</p><h2 id="扩展欧几里得算法"><a class="header-anchor" href="#扩展欧几里得算法">¶</a>扩展欧几里得算法</h2><p>给定两个整数 a、b，必定存在 x、y，使得 gcd(a,b)=ax+by</p><p>运用该算法推导过程</p><p>m = m % n</p><p>m = m<sup>s1e1+s2e2</sup> % n</p><p>m = (m<sup>e1s1</sup> * m<sup>e2s2</sup>)% n</p><p>m = (m<sup>e1s1</sup> % n) * (m<sup>e2s2</sup> % n) % n</p><p>m = (c1<sup>s1</sup> % n) * (c2<sup>s2</sup> % n) % n</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p><h1>低加密指数广播攻击</h1><p>特点是 e 小，有多组 n，对应了多组 c</p><p>m<sup>e</sup> = c1 mod n1</p><p>m<sup>e</sup> = c2 mod n2</p><p>m<sup>e</sup> = c3 mod n3</p><h2 id="中国剩余定理-CRT"><a class="header-anchor" href="#中国剩余定理-CRT">¶</a>中国剩余定理(CRT)</h2><p>定理内容如下</p><p>针对上述方程组，若 n1、n2、n3 互质，对于任意的 c1、c2、c3，方程组都有解 m。</p><p>使用条件是 m^e &lt; n1、n2、n3。通解推导如下：</p><p>设$N=n_1 \times n_2 \times n_3, N_1=N/n_1, N_2=N/n_2, N_3=N/n_3$</p><p>设$t_i=N_i^{-1}$,这里表示$t_i$是$N_i$在模$n_i$的逆元。</p><p>有了以上几个数，我们可以给出通解形式：</p><p>$$m=c_1t_1N_1+c_2t_2N_2+c_3t_3N_3+kN=kN+\sum_{i=1}^3c_it_iN_i$$</p><p>在模 N 后，只剩唯一解$m=\sum_{i=1}^3c_it_iN_i$</p><h2 id="EXP-v2"><a class="header-anchor" href="#EXP-v2">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p><h1>dp、dq 相关</h1><h2 id="给定-dp、dq-类型"><a class="header-anchor" href="#给定-dp、dq-类型">¶</a>给定 dp、dq 类型</h2><p>dp ≡ d mod (p-1)</p><p>dq ≡ d mod (q-1)</p><p>m ≡ c<sup>d</sup> mod n</p><p>m = c<sup>d</sup> + k * n</p><p>m = c<sup>d</sup> +k _ p _ q</p><p>对上式两端同时对 p、q 分别取余，得：（中国剩余定理）</p><p>m1 ≡ c<sup>d</sup> mod p</p><p>m2 ≡ c<sup>d</sup> mod q</p><p>同理，可得到<br>c<sup>d</sup> = m1 +k * p</p><p>代入到 m2 ≡ c<sup>d</sup> mod q 中：</p><p>m2 ≡ (m1 + k * p)mod q ，两端减去 m1 得</p><p>m2 - m1 ≡ k * p mod q ，两端乘 p 的逆元得</p><p>(m2 - m1)p<sup>-1</sup> ≡ k mod q</p><p>将 k 代入到 c<sup>d</sup> = m1 +k * p 中得：</p><p>c<sup>d</sup> = m1 + ((m2 - m1)p<sup>-1</sup> mod q) * p</p><p>m=c<sup>d</sup> mod n</p><p>得到</p><p>m ≡ (((m2 - m1) _ p<sup>-1</sup> mod q) _ p + m1) mod n</p><p>接下来就是求解 m1，m2</p><p>m1 ≡ c<sup>dp+k(p-1)</sup> mod p</p><p>m2 ≡ c<sup>dq+k(q-1)</sup> mod q</p><p>根据费马小定理</p><p>若 p 是素数，则 a<sup>(p-1)</sup> ≡ 1 mod p</p><p>因此 m1 ≡ c<sup>dp</sup> mod p，m2 ≡ c<sup>dq</sup> mod q</p><p>最终可求得 m</p><h3 id="EXP-v3"><a class="header-anchor" href="#EXP-v3">¶</a>EXP</h3><p>&lt;!–code￼2–&gt;</p><h2 id="只给定-dp"><a class="header-anchor" href="#只给定-dp">¶</a>只给定 dp</h2><p>dp ≡ d mod (p-1)</p><p>ed ≡ 1 mod (p-1) * (q-1)</p><p>ed = 1 + k2(p-1)(q-1)</p><p>对 1 式两端同乘 e，得</p><p>e * dp ≡ ed mod (p-1)</p><p>e * dp = k1(p-1) + ed</p><p>代入 ed 得</p><p>e * dp = k1(p-1) + 1 + k2(p-1)(q-1)</p><p>由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余 p-1，即可消掉 n</p><p>e * dp ≡ 1 mod (p-1)</p><p>e * dp =k(p-1) + 1</p><p>得到这个式子后，其实真正意义上的未知数只有我们要求的 p，但是还存在一个 k。</p><p>针对 k，我们判断一下他的范围，看看能否采用爆破的方式。</p><p>k = (e * dp - 1)/(p-1)</p><p>因为 dp &lt; p-1</p><p>所以 k &lt; e</p><p>通过遍历 k 然后找到(e * dp - 1)可以整除 k 的情况即可。</p><p>(跑了一下发现限制条件还不够)</p><p>因此再加一个 n 能否整除 p 即可。</p><h3 id="EXP-v4"><a class="header-anchor" href="#EXP-v4">¶</a>EXP</h3><p>&lt;!–code￼3–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022DASCTF_NOV-lllcccggg-wp</title>
    <link href="/2022/11/30/2022DASCTF_NOV-lllcccgggwp/"/>
    <url>/2022/11/30/2022DASCTF_NOV-lllcccgggwp/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p>如题目名字一样，有好多个lcg，<s>当时看晕了</s><br>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>1.<code>key</code>是一个背包问题，已知公钥<code>m</code>，和的话目前不知道。</p><p>2.以1中的和为<code>seed</code>，通过LCG产生了一组序列<code>output</code>。</p><p>至此，已经可以根据<code>output</code>来求出LCG中的a、b、n，从而求出<code>seed</code>，从而通过背包可求得key。</p><p>3.以<code>key</code>为seed，称作<code>state</code>，再进行LCG，<code>state = (a * state + b) % c</code>，并且a，b，c已知。</p><p>但是想要直接正向求解出最后的state，十分困难，for循环了10^10000次，这里涉及到了<strong>矩阵快速幂</strong>的使用。</p><p>通过构造矩阵<br>$$<br>\mathbf{A} =<br>\begin{bmatrix}<br>state &amp; 1<br>\end{bmatrix}<br>$$<br>$$<br>\mathbf{C} =<br>\begin{bmatrix}<br>a &amp; 0\<br>b &amp; 1\<br>\end{bmatrix}<br>$$<br>通过计算$A<em>C^{10</em>10000}$即可得到矩阵B，B = [ state, 1]</p><p>4.求出state后进行异或解密即可。</p><h1>EXP</h1><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包加密算法</title>
    <link href="/2022/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/"/>
    <url>/2022/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>在一次CTF比赛中遇到了，写了10个for嵌套硬爆出来了，复现的时候发现是背包加密。</p><p><img src="/img/bag.png" alt=""></p><h2 id="Merkle–Hellman-公钥加密算法"><a class="header-anchor" href="#Merkle–Hellman-公钥加密算法">¶</a>Merkle–Hellman 公钥加密算法</h2><p>整体加密流程<br>&lt;!–code￼0–&gt;<br>可以发现，加密十分容易，但解密十分困难，这也是非对称加密的特点。</p><h3 id="加密"><a class="header-anchor" href="#加密">¶</a>加密</h3><h4 id="生成私钥"><a class="header-anchor" href="#生成私钥">¶</a>生成私钥</h4><p>超递增序列，也就是a中每一位元素需要大于其之前所有元素的和。<br>&lt;!–code￼1–&gt;</p><h4 id="生成公钥"><a class="header-anchor" href="#生成公钥">¶</a>生成公钥</h4><p>模数m要求：<code>m &gt; sum(a)</code><br>乘数w要求：<code>gcd(w,m) == 1</code><br>&lt;!–code￼2–&gt;<br>b和m作为公钥。<br>加密：<code>S = numpy.dot(x,b)</code></p><h3 id="解密"><a class="header-anchor" href="#解密">¶</a>解密</h3><p>拿到公钥$M=(m_1,m_2,\ldots,m_n)$，构造如下矩阵<br>$$<br>\begin{bmatrix}<br>2 &amp; 0 &amp; \ldots &amp; 0 &amp; m_1 \<br>0 &amp; 2 &amp; \ldots &amp; 0 &amp; m_2 \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \<br>0 &amp; 0 &amp; \ldots &amp; 2 &amp; m_n \<br>1 &amp; 1 &amp; \ldots &amp; 1 &amp; S \<br>\end{bmatrix}<br>$$<br>这个矩阵的所有行向量的线性组合构成了一个格，接下来将通过明文的特点和格上的特殊解法来进行解密。</p><h4 id="LLL"><a class="header-anchor" href="#LLL">¶</a>LLL</h4><p>对于明文$X=(x_1,x_2,\ldots,x_n)$这一组数来说，构造一个向量<br>$$<br>a=\sum_{i=1}^nx_iv_i-v_{n+1}=(2x_1-1,2x_2-1,\ldots,2x_n-1,0)<br>$$<br>显然，a向量在格L上。因为X中的所有x只能取值0或1，因此a向量的长度很小，约为$\sqrt{n}$，对于很大的格基来说，a向量无疑是格L上的最小向量，因此我们利用LLL算法即可求出a向量。</p><h4 id="例题"><a class="header-anchor" href="#例题">¶</a>例题</h4><p>&lt;!–code￼3–&gt;<br>这里注意一下，第一行向量中是有+1与-1，需要进行取反，即-1代表1，1代表0。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>非对称加密</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hitcon 2022-㊙️BabySSS</title>
    <link href="/2022/11/28/hitcon2022-BabySSS/"/>
    <url>/2022/11/28/hitcon2022-BabySSS/</url>
    
    <content type="html"><![CDATA[<p>I implemented a toy Shamir’s Secret Sharing for fun. Can you help me check is there any issues with this?</p><h1>Shamir’s Secret Sharing密钥分享算法</h1><p>$$f(x)=a_0 + a_1x + a_2x^2 + …… + a_{k-1} x^{k-1} mod p<br>$$</p><h1>题目源码</h1><p>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>题目给了8组x，y的值，可通过CRT模x求出a_0 ，通过模x^2 可求出a_1 ，同理可求出所有系数，恢复出polyeval函数，从而得到正确的secret。</p><h1>EXP</h1><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gauss格基约简算法</title>
    <link href="/2022/11/24/Gauss%E6%A0%BC%E5%9F%BA%E7%BA%A6%E7%AE%80%E7%AE%97%E6%B3%95/"/>
    <url>/2022/11/24/Gauss%E6%A0%BC%E5%9F%BA%E7%BA%A6%E7%AE%80%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>由Gauss提出的二维格基约化算法</p><h1>算法伪代码</h1><p>即对给定的两个基向量进行不断的相互约化，最终求得格上的最小向量</p><p>Loop</p><p>(a) If ||v2|| &lt; ||v1||, swap v1, v2</p><p>(b) Compute m = ⌊ v1∙v2 / v1∙v1 ⌉</p><p>© If m = 0, return v1, v2</p><p>(d) v2 = v2 - m*v1</p><p>Continue Loop</p><h1>代码实现</h1><p>&lt;!–code￼0–&gt;</p><h1>例题</h1><p>&lt;!–code￼1–&gt;</p><h2 id="思路"><a class="header-anchor" href="#思路">¶</a>思路</h2><p>给定公钥q、h，以及明文e</p><p>要求私钥f、g</p><p>他们之间有如下关系：</p><p>fh ≡ g mod q</p><p>即 kq + g =fh</p><p>g = fh -kq<br>根据这一特点即可构造格，也就是格密码中很经典的，遇到一个向量乘矩阵，即可进行构造</p><p>由于存在一组a、b，使得a（1，h）+ b（0，q）=（f，g）$a(1,h) + b(0,q) = (f,g)$</p><p>a = f，b = k</p><p>选取一组基底为（1，h）和（0，q），也就是上述高斯约简算法当中的v1与v2，求出v1与v2格上最小的向量，即为（f，g）</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼2–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lattice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树建立与遍历</title>
    <link href="/2022/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/"/>
    <url>/2022/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>网上很多算法通过直接将二叉树结点连接，从而构成二叉树，这里我构建了一个二叉树类，通过用户控制输入来建立二叉树。</p><p>有层序遍历，递归、非递归的前序遍历、中序遍历、后序遍历算法。</p><p>&lt;!–code￼0–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022祥云杯wp-crypto</title>
    <link href="/2022/10/30/2022-10-30-2022%E7%A5%A5%E4%BA%91%E6%9D%AFwp-crypto/"/>
    <url>/2022/10/30/2022-10-30-2022%E7%A5%A5%E4%BA%91%E6%9D%AFwp-crypto/</url>
    
    <content type="html"><![CDATA[<h1>little little fermat</h1><h2 id="题目源码"><a class="header-anchor" href="#题目源码">¶</a>题目源码</h2><p>&lt;!–code￼0–&gt;</p><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>根据题目名字来看，此题和费马小定理的使用有关，题目中有一个<code> obfuscate</code>函数，进行了对q的生成，<code>q=p+A</code>，这里可以看一下A的范围，是在2<sup>[18,319]</sup>之间，因此p、q接近，尝试一下yafu分解。</p><p><img src="/img/20221030.jpg" alt=""><br>题目对m先进行了处理，再进行RSA加密，因此我们需要知道x。<code>assert 114514 ** x % p == 1</code>运用费马小定理，若114514与p互素，则x=p-1，即可求解m。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p><h1>fill</h1><h2 id="题目源码-v2"><a class="header-anchor" href="#题目源码-v2">¶</a>题目源码</h2><p>&lt;!–code￼2–&gt;</p><h2 id="题目分析-v2"><a class="header-anchor" href="#题目分析-v2">¶</a>题目分析</h2><p>随机产生32位的数，sha256()加密后作为flag，并将其2进制的每一位存到了<code>f_list</code>数组中。</p><p>又 创建了一个<code>r_list</code>32位数组，里面存着随机数，先暂时不管。</p><p>双 对<code>r_list</code>数组中的随机数做了加密，产生了<code>M</code>数组。</p><p>对<code>f_list</code>和<code>M</code>数组进行了<code>numpy.dot</code>运算，即向量乘法，得到和为S。</p><p>叒 创建了一个<code>s</code>数组，这个很明显，用LCG线性同余算法进行了加密。</p><p>最后将<code>M</code>数组与<code>s</code>数组相加。</p><p>这就是这道题整体的流程，每一步并不难，只是步骤多，略显复杂。</p><h2 id="EXP-v2"><a class="header-anchor" href="#EXP-v2">¶</a>EXP</h2><h3 id="0x01"><a class="header-anchor" href="#0x01">¶</a>0x01</h3><p>可以先进行一下LCG的求解，把s数组求解出来，从而求出M数组。</p><p>&lt;!–code￼3–&gt;</p><h3 id="0x02"><a class="header-anchor" href="#0x02">¶</a>0x02</h3><p>按理来说，感觉应该根据求出来的<code>M</code>数组进行逆运算，求出<code>r_list</code>数组，但是求出来<code>r_list</code>有什么用呢，所以直接尝试求<code>f_list</code>。因为<code>f_list</code>中不是0就是1，与<code>M</code>做向量乘法，即为<code>M</code>数组中若干元素的和。根据题目给定和S，先大概看一下需要<code>M</code>中多少个元素累加。发现在M前21位和 &lt; S，前22位和 &gt; S，所以猜想应该是M当中，除10个左右元素之外的和。</p><p>这里就遍历了一下，复杂度实在太高了，也没想着能出，结果还真算出来了o.O</p><p>&lt;!–code￼4–&gt;</p><p>也就说明，<code>f_list</code>中下标为这些的，对应值是0，其余为1，即可得到msg的2进制数，转为十进制后进行<code>sha256()</code>加密即可。</p><p>&lt;!–code￼5–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022NewStarCTF-flip_flop</title>
    <link href="/2022/10/27/2022NewStarCTF-flip_flop/"/>
    <url>/2022/10/27/2022NewStarCTF-flip_flop/</url>
    
    <content type="html"><![CDATA[<h1>flip-flop</h1><p>AES-CBC加密模式</p><h2 id="题目"><a class="header-anchor" href="#题目">¶</a>题目</h2><p>源码如下：<br>&lt;!–code￼0–&gt;</p><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>此题是通过注册得到的用户账户的密文，然后输入管理员账户对应的密文，才能得到flag。</p><p>对用户账户和管理员账户的加密解密均采用AES-CBC模式，但是本题仅有一组明文，iv仅作为偏移量，也就是本题中的user_key。</p><p>这里先来说一下我最一开始的思路，由于user_key每次是随机产生的，但是一次程序的运行当中是不变的。由于密文由两部分组成，前半部分为user_key.hex()，后半部分为code.hex()，所以只要构造出admin对应的code即可，那么就需要AES加密当中的key，所以就需要构造一个key来产生出admin对应的code。查询了很多资料发现都难以实现。于是……</p><p>那为什么不换一下思路？不能构造code，能不能构造iv？</p><p>先来看一下加密方式：</p><p>C = encrypt(M ^ iv)</p><p>M = decrypt©^iv</p><p>对应一下本题当中的NewStarCTFer和admin：<br><code>b'NewStarCTFer____' = decrypt(code) ^ iv1</code></p><p><code>b'AdminAdmin______' = decrypt(code) ^ iv2</code></p><p>因此可求出admin对应的iv2，随后拼接上普通用户的后半段code即可。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUU刷题日记20221026</title>
    <link href="/2022/10/26/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221026/"/>
    <url>/2022/10/26/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221026/</url>
    
    <content type="html"><![CDATA[<h1>RSA5</h1><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>给定e=65537</p><p>给了很多组n、c</p><p>由于e过大，所以不考虑使用CRT，由于m是同一个，因此遍历一下，求出两个n的最大公约数，即为p，后续就简单了。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022 DASCTF 10月挑战赛wp</title>
    <link href="/2022/10/23/2022DASCTF10%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwp/"/>
    <url>/2022/10/23/2022DASCTF10%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwp/</url>
    
    <content type="html"><![CDATA[<h1>RSA</h1><h2 id="题目如下"><a class="header-anchor" href="#题目如下">¶</a>题目如下</h2><p>&lt;!–code￼0–&gt;</p><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>该题的加密顺序是：</p><p>1、加密flag，分为两部分m1、m2</p><p>2、加密m1</p><p>3、加密m2</p><p>同理我们解密的顺序应该也是</p><p>1、解出m1、m2</p><p>2、解出flag</p><h3 id="求m2"><a class="header-anchor" href="#求m2">¶</a>求m2</h3><p>先观察一下encrypt4函数</p><p>虽然说e_2=3，按理来说使用低加密指数攻击，但并不可行。</p><p>又因为m = m % k</p><p>可通过这点和<code>c_3 = pow(m, e_2, n_3)</code>做遍历求出m</p><p>最后发现m即为m2，m2 &lt; k</p><h3 id="求m1"><a class="header-anchor" href="#求m1">¶</a>求m1</h3><p>发现m1加密方式采用RSA，但是n_1未知</p><p>n_1又通过一次RSA加密，已知n_1对应的密文</p><p>利用低加密指数攻击解出n1</p><p>发现n1可分解为3个素数乘积</p><p>故phi可求，即求出m1</p><h3 id="求flag"><a class="header-anchor" href="#求flag">¶</a>求flag</h3><p>观察encryt1</p><p>m1是flag右移200位之后转为字节</p><p>m2是flag的20位之后转成字节</p><p>所以来说m2是没什么问题，主要找到flag的前20位，再把m2拼到后面即可。</p><p>由于m1是flag右移200位，因此flag的低位缺失，但高位还在，由于不知道flag总长度，抱着试一试的心态，猜测一下它的高位前20位没有缺失</p><p>我们将m1和m2转为字节发现</p><p>m1:b’0x666c61677b3230366538353964’</p><p>m2:b’383539643865383534633466363030636231323735376262663966357d’</p><p>发现m1和m2有重叠部分，即38353开始</p><p>可以证实m1前20位确实没有缺失</p><p>因此取m1前20位，加m2，即可解出flag</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUU刷题日记20221022</title>
    <link href="/2022/10/22/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221022/"/>
    <url>/2022/10/22/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221022/</url>
    
    <content type="html"><![CDATA[<h1>RSA4</h1><p>题目只给了三组n、c，采用中国剩余定理，具体推导如下</p><h2 id="推导过程"><a class="header-anchor" href="#推导过程">¶</a>推导过程</h2><p>m<sup>e</sup> ≡ c1 mod n1<br>m<sup>e</sup> ≡ c2 mod n2<br>m<sup>e</sup> ≡ c3 mod n3</p><h3 id="中国剩余定理（CRT）"><a class="header-anchor" href="#中国剩余定理（CRT）">¶</a>中国剩余定理（CRT）</h3><p>中国剩余定理的内容是：</p><p>针对上述方程组，若n1、n2、n3互质，对于任意的c1、c2、c3，方程组都有解，使用条件是m^e &lt; n1、n2、n3。通解形式如下：</p><p>令N = n1 * n2 * n3，N1 = N/n1，N2、N3同理</p><p>令t1 = N1<sup>(-1)</sup>，即其对应的模n1运算的逆元，t2，t3同理，可用<code>t1=gmpy2.invert(N1,n1)</code>表示。</p><p>有了Ni和ti的定义，我们就可以给出通解形式：</p><p>x = c1 * N1 * t1 ……</p><p>有了通解公式我们就可以求出m^e，对e进行一下遍历即可，m开方成功即可。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUU刷题日记20221021</title>
    <link href="/2022/10/21/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221021/"/>
    <url>/2022/10/21/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221021/</url>
    
    <content type="html"><![CDATA[<h1>RSA2</h1><p>题目给定n、e、dp、c</p><p>非预期解：直接分解n</p><p>下面考虑n不能分解的情况</p><h2 id="推导过程"><a class="header-anchor" href="#推导过程">¶</a>推导过程</h2><p>dp ≡ d mod (p-1)</p><p>ed ≡ 1 mod (p-1) * (q-1)</p><p>ed = 1 + k2(p-1)(q-1)</p><p>对1式两端同乘e，得</p><p>e * dp ≡ ed mod (p-1)</p><p>e * dp = k1(p-1) + ed</p><p>代入ed得</p><p>e * dp = k1(p-1) + 1 + k2(p-1)(q-1)</p><p>由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余p-1，即可消掉n</p><p>e * dp ≡ 1 mod (p-1)</p><p>e * dp =k(p-1) + 1</p><p>得到这个式子后，其实真正意义上的未知数只有我们要求的p，但是还存在一个k。</p><p>针对k，我们判断一下他的范围，看看能否采用爆破的方式。</p><p>k = (e * dp - 1)/(p-1)</p><p>因为dp &lt; p-1</p><p>所以k &lt; e</p><p>通过遍历k然后找到(e * dp - 1)可以整除k的情况即可。</p><p>(跑了一下发现限制条件还不够)</p><p>因此再加一个n能否整除p即可。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p><h1>RSA3</h1><p>给定n、e1、c1、e2、c2。</p><p>m ≡ c1^e1 mod n</p><p>m ≡ c2^e2 mod n</p><p>这里采用共模攻击，详细原理如下：</p><p>扩展欧几里得算法：给定两个整数a、b，必定存在x、y，使得gcd(a,b)=ax+by</p><p>对应到本题当中，由于e1、e2互为素数，因此gcd(e1,e2)=1，从而存在s1、s2使得:</p><p>s1 * e1 + s2 * e2 = 1</p><h2 id="推导过程-v2"><a class="header-anchor" href="#推导过程-v2">¶</a>推导过程</h2><p>m = m % n</p><p>m = m^(s1 * e1 + s2 * e2)^ % n</p><p>m = m^(e1 * s1)^ * m^(e2 * s2)^ % n</p><p>m = (m^(e1 * s1)^ % n) * (m^(e2 * s2)^ % n) % n</p><p>m = (c1<sup>s1</sup> % n) * (c2<sup>s2</sup> % n) % n</p><h2 id="EXP-v2"><a class="header-anchor" href="#EXP-v2">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUU刷题日记20221020</title>
    <link href="/2022/10/20/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221020/"/>
    <url>/2022/10/20/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221020/</url>
    
    <content type="html"><![CDATA[<h1>RSA1</h1><p>给定dp、dq类型</p><p>dp ≡ d mod (p-1)</p><p>dq ≡ d mod (q-1)</p><p>m ≡ c<sup>d</sup> mod n</p><p>m = c<sup>d</sup> + k * n</p><p>m = c<sup>d</sup> +k * p * q</p><p>对上式两端同时对p、q分别取余，得：（中国剩余定理）</p><p>m1 ≡ c<sup>d</sup> mod p</p><p>m2 ≡ c<sup>d</sup> mod q</p><p>同理，可得到<br>c<sup>d</sup> = m1 +k * p</p><p>代入到 m2 ≡ c<sup>d</sup> mod q 中：</p><p>m2 ≡ (m1 + k * p)mod q ，两端减去m1得</p><p>m2 - m1 ≡ k * p mod q ，两端乘p的逆元得</p><p>(m2 - m1)p<sup>-1</sup> ≡ k mod q</p><p>将k代入到 c<sup>d</sup> = m1 +k * p 中得：</p><p>c<sup>d</sup> = m1 + ((m2 - m1)p<sup>-1</sup> mod q) * p</p><p>m=c<sup>d</sup> mod n</p><p>得到</p><p>m ≡ (((m2 - m1) * p<sup>-1</sup> mod q) * p + m1) mod n</p><p>接下来就是求解m1，m2</p><p>m1 ≡ c<sup>dp+k(p-1)</sup> mod p</p><p>m2 ≡ c<sup>dq+k(q-1)</sup> mod q</p><p>根据费马小定理</p><p>若p是素数，则a<sup>(p-1)</sup> ≡ 1 mod p</p><p>因此 m1 ≡ c<sup>dp</sup> mod p，m2 ≡ c<sup>dq</sup> mod q</p><p>最终可求得m</p><h2 id="exp"><a class="header-anchor" href="#exp">¶</a>exp</h2><p>&lt;!–code￼0–&gt;</p><h1>RSAROLL</h1><p>&lt;!–code￼1–&gt;<br>给了一个data.txt文件，打开盲猜一下第一行是n，e，后面是c<br>&lt;!–code￼2–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021ByteCTF-easyxor</title>
    <link href="/2022/10/16/2021ByteCTF-easyxor/"/>
    <url>/2022/10/16/2021ByteCTF-easyxor/</url>
    
    <content type="html"><![CDATA[<h1>题目源码如下</h1><p>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>将flag分为两段，前半段采用OFB加密，后半段采用CBC加密</p><h2 id="OFB解密"><a class="header-anchor" href="#OFB解密">¶</a>OFB解密</h2><p>将前半段flag又进行切分，将其8位分为一组，存到group数组中。<br>&lt;!–code￼1–&gt;<br>针对一个随机生成的64位的last，与keys进行convert加密，再与group中的数进行异或。<br>keys是四个-32～32的数，可爆破。<br>对于OFB解密十分简单，因为我们已知第一组明文，恰好是8位的’ByteCTF{'，由于分组密码的性质，所以后面的也就迎刃而解，通过group[ 0]^cipher[ 0] 即可得到cur_c，从而求得下一次的cur_c，以此类推。</p><h3 id="expOFB"><a class="header-anchor" href="#expOFB">¶</a>expOFB</h3><p>&lt;!–code￼2–&gt;</p><h2 id="CBC解密"><a class="header-anchor" href="#CBC解密">¶</a>CBC解密</h2><p>针对后半部分，我们需要逆向解出convert函数，因此就是对shift函数中的加密运算进行解密。<br>之前上网搜的wp都一笔带过，没解释unshift逆函数怎么写的。“难道有什么定理？？”<br>这里简单写一下我的理解。</p><h3 id="分析shift"><a class="header-anchor" href="#分析shift">¶</a>分析shift</h3><p>&lt;!–code￼3–&gt;</p><h4 id="推理过程"><a class="header-anchor" href="#推理过程">¶</a>推理过程</h4><p>这里我们举例k&gt;0时的情况。（k&lt;0同理）</p><p>m和c都是64位,k是-32～32的10进制数。</p><p>1、m &lt;&lt; k相当于在m后补k位0，得到的新数我们称为a，a=m &lt;&lt; k。</p><p>2、令b = a &amp; c，由于a是64+k位，c是64位，所以b是64位，并且b的后k位都是0。</p><p>3、令x = m ^ b，x则是shift加密之后的值，x也是64位，并且x的后k位是与m的后k位相同的，与0异或得本身。</p><p>我们走完了一遍shift加密，得到的结论是，密文的位数同样是64，并且密文的后k位与明文相同。</p><h3 id="分析unshift"><a class="header-anchor" href="#分析unshift">¶</a>分析unshift</h3><p>&lt;!–code￼4–&gt;</p><h4 id="推理过程-v2"><a class="header-anchor" href="#推理过程-v2">¶</a>推理过程</h4><p>同样我们举例k&gt;0的情况。</p><p>之前我们得到的密文x，相当于tmp。</p><p>1、a’=tmp &lt;&lt; k，tmp后k位为0，tmp后2k～k位等于m的后k位。</p><p>2、b’=a’ &amp; c，b’后k位为0，后2k～k位为m&amp;c。</p><p>3、y=x ^ b’，y的后k位，等于x的后k位，也就是m的后k位。</p><p>4、y的后2k～k位，在shift加密当中，a &amp; c的后2k～k位等于m的后k位&amp;c，记作m1 &amp; c。</p><p>shift中的x，也就是m ^ b，m ^(m1 &amp; c)，在unshift最后的一步操作中，y= m ^(m1 &amp; c) ^ b’。</p><p>这时我们只考虑y的后2k～k位，y=m ^(m1 &amp; c)^(m1 &amp; c) = m</p><p>所以这时y的2k～k位也等于m了。</p><h4 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h4><p>因此，我们发现每经过unshift一次，就有k位被还原，何时才能被完全还原？即循环bits//k次。</p><p>此推理正确，可以在unshift函数运行时输出每次的tmp观察即可。</p><p>ps：自我感觉这种位运算应该是属于一种性质或者定理，网上大佬们都是说“简单写个逆”。。。</p><h3 id="expCBC"><a class="header-anchor" href="#expCBC">¶</a>expCBC</h3><p>&lt;!–code￼5–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022BUUCTF新生赛-RSA</title>
    <link href="/2022/10/16/2022BUUCTF%E6%96%B0%E7%94%9F%E8%B5%9B-RSA/"/>
    <url>/2022/10/16/2022BUUCTF%E6%96%B0%E7%94%9F%E8%B5%9B-RSA/</url>
    
    <content type="html"><![CDATA[<h1>题目源码</h1><p>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>发现n和phin都不常规，没入手点，发现hint，hint=pow(d,e,n)，有趣，用d做明文，尝试推理一下：<br>d = pow(hint,d,n)<br>d = pow((d ** e % n),d,n)<br>d = (d ** e % n) ** d % n<br>d = d ** (e*d) % n<br>d = pow(d ** e,d,n)<br>把d ** e再次看做密文，可得<br>d ** e = pow(d,e,n)<br>因为hint = pow(d,e,n)<br>可得hint = d ** e<br>d ** e * e ** e-&gt;(ed) ** e-&gt;(ed) ** e == 1 mod phin<br>因此根据e和hint即可求得phin<br>从而得到phin和n的最大公约数p<br>脚本如下<br>&lt;!–code￼1–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>梦开始的地方</title>
    <link href="/2022/10/15/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
    <url>/2022/10/15/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="Mac下利用Hexo和github-pages搭建个人博客"><a class="header-anchor" href="#Mac下利用Hexo和github-pages搭建个人博客">¶</a>Mac下利用Hexo和github pages搭建个人博客</h2><h3 id="环境配置"><a class="header-anchor" href="#环境配置">¶</a>环境配置</h3><h4 id="1-Node-js安装"><a class="header-anchor" href="#1-Node-js安装">¶</a>1.Node.js安装</h4><p>下载地址：<a href="https://nodejs.org/en/">Node.js</a></p><h4 id="2-淘宝镜像安装"><a class="header-anchor" href="#2-淘宝镜像安装">¶</a>2.淘宝镜像安装</h4><p>&lt;!–code￼0–&gt;</p><h4 id="3-安装Hexo"><a class="header-anchor" href="#3-安装Hexo">¶</a>3.安装Hexo</h4><p>&lt;!–code￼1–&gt;</p><h3 id="初始化Hexo-Blog"><a class="header-anchor" href="#初始化Hexo-Blog">¶</a>初始化Hexo Blog</h3><h4 id="1-初始化Hexo"><a class="header-anchor" href="#1-初始化Hexo">¶</a>1.初始化Hexo</h4><p>新建一个文件夹并进入，例如blog<br>&lt;!–code￼2–&gt;</p><h4 id="2-本地启动Hexo"><a class="header-anchor" href="#2-本地启动Hexo">¶</a>2.本地启动Hexo</h4><p>&lt;!–code￼3–&gt;<br>浏览器打开网站，即可看到本地博客</p><h3 id="创建博客文章"><a class="header-anchor" href="#创建博客文章">¶</a>创建博客文章</h3><h4 id="1-创建文章"><a class="header-anchor" href="#1-创建文章">¶</a>1.创建文章</h4><p>&lt;!–code￼4–&gt;<br>在blog文件夹中的_post里即可看到新建的md文件</p><h4 id="2-清理缓存项目"><a class="header-anchor" href="#2-清理缓存项目">¶</a>2.清理缓存项目</h4><p>在新建博客或修改博客时，需要进行该操作<br>&lt;!–code￼5–&gt;</p><h4 id="3-重新生成博客"><a class="header-anchor" href="#3-重新生成博客">¶</a>3.重新生成博客</h4><p>&lt;!–code￼6–&gt;</p><h4 id="4-启动博客"><a class="header-anchor" href="#4-启动博客">¶</a>4.启动博客</h4><p>&lt;!–code￼7–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>建站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/15/hello-world/"/>
    <url>/2022/10/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3><p>&lt;!–code￼0–&gt;</p><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3><p>&lt;!–code￼1–&gt;</p><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3><p>&lt;!–code￼2–&gt;</p><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><p>&lt;!–code￼3–&gt;</p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
