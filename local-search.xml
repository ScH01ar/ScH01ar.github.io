<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>格密码</title>
    <link href="/2023/11/10/lattice/"/>
    <url>/2023/11/10/lattice/</url>
    
    <content type="html"><![CDATA[<h2 id="线性代数前置知识"><a class="header-anchor" href="#线性代数前置知识">¶</a>线性代数前置知识</h2><blockquote><p>先回顾一下学校线代课程讲过的几个概念</p></blockquote><h3 id="向量空间"><a class="header-anchor" href="#向量空间">¶</a>向量空间</h3><p>设$V$是 n 元向量的集合，如果$V$非空，并且对于向量的线性运算封闭(即对任意 $\boldsymbol{v_1} \in V,\boldsymbol{v_2} \in V,k \in \mathbb{R}$ ，都有 $\boldsymbol{v_1+v_2} \in V,k\boldsymbol{v_1} \in V$ )，则称 $V$ 是一个<strong>向量空间</strong>。</p><h3 id="向量空间的基与维数"><a class="header-anchor" href="#向量空间的基与维数">¶</a>向量空间的基与维数</h3><p>向量空间$V$的一个极大无关组叫做$V$的一个<strong>基</strong>，$V$ 的秩叫做$V$的<strong>维数</strong>，记作$dim(V)$。若 $dim(V)=r$，则称$V$为$r$维向量空间。</p><p>若已知$r$维向量空间$V$的基为$\boldsymbol{v_1,v_2,\cdots,v_r}$，则向量空间$V$可以表示成</p><p>$$<br>V={ \boldsymbol{v}=x_1\boldsymbol{v_1}+x_2\boldsymbol{v_2}+\cdots +x_r\boldsymbol{v_r} | x_1,x_2,\cdots,x_r \in \mathbb{R}}<br>$$</p><h3 id="向量正交与施密特-Schmidt-正交化"><a class="header-anchor" href="#向量正交与施密特-Schmidt-正交化">¶</a>向量正交与施密特(Schmidt)正交化</h3><ul><li><p>当$\boldsymbol{a\neq 0,b\neq 0}$时，当$(\boldsymbol{a,b}=0)$，即$\boldsymbol{a^Tb}=0$时，称向量$\boldsymbol{a,b}$正交。</p></li><li><p>由两两正交的非零向量组成的向量组称为<strong>正交向量组</strong>，由单位向量组成的正交向量组称为<strong>标准正交向量组</strong>。</p></li></ul><h2 id="格"><a class="header-anchor" href="#格">¶</a>格</h2><p>$n$元向量的集合 $v_1,\cdots,v_n \in \mathbb{R}^n$，格（Lattices）就是这些向量的线性组合</p><p>$$L={a_1v_1+a_2v_2+\cdots+a_nv_n \mid a_1,a_2,\cdots,a_n \in \mathbb{Z}}$$</p><p>对比向量空间的定义，可以发现系数是整数，因此定义出来的格空间是一些格点，而非连续的向量空间。</p><p>下图是一个二维格，平行四边形的一组邻边是格的基底。通过对这两个向量不断进行线性组合，那么就产生了很多格点，就形成了一个格。<br><img src="/img/lattice.png" alt=""></p><h3 id="基本域"><a class="header-anchor" href="#基本域">¶</a>基本域</h3><p>假定 $v_1,v_2,\cdots,v_n$ 是格 $L$ 的基，$F{v_1,v_2,\cdots,v_n}={a_1v_1+a_2v_2+\cdots+a_nv_n \mid a_1,a_2,\cdots,a_n \in [0,1]}$</p><p>上图中的平行四边形，就是二维格中一组基底构成的基本域。</p><p>格基本域的<strong>体积</strong>等于格的<strong>行列式</strong>的值，基本域的体积就是积分，而这也正是行列式的几何意义，$Volume(F{v_1,v_2,\cdots,v_n})=det(L)$</p><h3 id="矩阵表示"><a class="header-anchor" href="#矩阵表示">¶</a>矩阵表示</h3><p>假定 $v_1,v_2,\cdots,v_n$ 是格 $L$ 的基，$w_1,w_2,\cdots,w_n \in L$，则必然存在整系数 $a_{ij}$ 使得：</p><p>$$<br>\begin{cases} w_1=a_{11}v_1+a_{12}v_2+\cdots+a_{1n}v_n \ w_2=a_{21}v_1+a_{22}v_2+\cdots+a_{2n}v_n \ \vdots \ w_n=a_{n1}v_1+a_{n2}v_2+\cdots+a_{nn}v_n \end{cases}<br>$$</p><p>可以提取出一个系数矩阵</p><p>$$<br>A=<br>\begin{bmatrix}<br>a_{1,1} &amp; a_{1,2} &amp; \ldots &amp; a_{1,n}\<br>a_{2,1} &amp; a_{2,2} &amp; \ldots &amp; a_{2,n}\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>a_{n,1} &amp; a_{n,2} &amp; \ldots &amp; a_{n,n}<br>\end{bmatrix}<br>$$</p><p>进而将上述方程组转换为矩阵表示$\boldsymbol{w}=A * \boldsymbol{v}$</p><h2 id="LLL-BKZ-算法"><a class="header-anchor" href="#LLL-BKZ-算法">¶</a>LLL/BKZ 算法</h2><p>一种<strong>格基约简</strong>算法，可以找到格上的一组最短的<strong>正交基</strong>。</p><p>在<code>Sagemath</code>中可以直接调用函数。</p><p>但对于函数的实现以及算法的原理没必要深究，在具体题目当中会使用即可。</p><p>&lt;!–code￼0–&gt;</p><p>下图是高斯启发式，为我们展示了格上最短向量的<strong>欧几里得范数</strong>的大致范围。<br><img src="/img/gsqf.png" alt=""></p><p>这样我们就知道构造出来的格，是否可以规约出我们的目标向量，也为我们调整格的平衡提供了思路。接下来我们在以下几个问题当中具体看一下<code>LLL</code>算法的应用。</p><h3 id="LLL-解决-SVP-问题"><a class="header-anchor" href="#LLL-解决-SVP-问题">¶</a>LLL 解决 SVP 问题</h3><blockquote><p>最短向量问题(Shortest Vector Problem，SVP)</p></blockquote><p>这是最基本的一个问题，后续很多格问题最终都转换成了<code>SVP</code>问题，从<code>LLL</code>算法中我们也可以看出，最终得到的是格上的最短正交向量组。</p><p>下面从一个例子来介绍格的构造和 LLL 的应用。</p><p>&lt;!–code￼1–&gt;</p><p>$$(p*f - 58 * f + q) % g = 44$$<br>$$k\cdot g+44=(p-58)\cdot f+q$$<br>我们目的是通过$f,g$求出$p,q$，从代码的定义可以看到，$p,q$的位数相比于$f,g$来说很小，因此可以应用格的思路，构造一个合适的格，规约出$(p,q)$</p><p>写出如下方程组<br>$$k\cdot g-(p-58)\cdot f=q-44$$<br>$$k\cdot 0-(p-58)\cdot (-1)=p-58$$<br>可以看到第二个式子是一个恒等式，在构造格时我们通常需要加入这样的恒等式。</p><p>下面将方程组转换为矩阵。</p><p>$$(k, p-58) \begin{bmatrix}0&amp;g\1&amp;-f \end{bmatrix}=(p-58,q-44)$$</p><p>得到了$v*B=w$的形式。在这个式子中我们关心的是$w$向量是否是格$B$上的最短向量，$v$这是线性组合的系数并不用过多关注。</p><p>在介绍<strong>高斯启发式</strong>的时候，提到了格上最短向量的<strong>欧几里得范数</strong>的大致范围，我们现在验证一下，看看$w$是否是格$B$上的最短向量，即比较长度$||w||$和高斯期望值$\sigma(det(B))$<br>$$||w|| = \sqrt{(p-58)<sup>2+(q-44)</sup>2}\approx 2^{1024}$$<br>$$\sigma(det(B))\approx det(B)^{1/2}=\sqrt{g}\approx 2^{1024}$$</p><p>于是$w$大概率为格$B$上的最短向量，构造格$B$进行<code>LLL</code>算法即可。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lattice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些关于p^q问题剪枝算法</title>
    <link href="/2023/11/07/%E5%89%AA%E6%9E%9D/"/>
    <url>/2023/11/07/%E5%89%AA%E6%9E%9D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>此篇文章针对 RSA 中 p^q 相关问题及变种做一个总结。之前做过很多 p^q 相关的问题，但是思路大差不差，周末打了鹏城杯，复现时发现要结合 copper 和 dfs 来剪枝。</p></blockquote><p>参考文章</p><p><a href="https://tangcuxiaojikuai.xyz/post/342113ee.html">https://tangcuxiaojikuai.xyz/post/342113ee.html</a></p><p><a href="https://mp.weixin.qq.com/s/Bi0iQOXwM5UlntrtdRL1oA">https://mp.weixin.qq.com/s/Bi0iQOXwM5UlntrtdRL1oA</a></p><h2 id="p-q"><a class="header-anchor" href="#p-q">¶</a>p^q</h2><h3 id="搜索方式"><a class="header-anchor" href="#搜索方式">¶</a>搜索方式</h3><ul><li>从低位搜索，在已知 p^q 和 p*q 的情况下，由于异或是按位进行的，对于每一位异或的结果来说，p、q 该位的组合情况有 4 种<code>[1,0][0,1][1,1][0,0]</code></li></ul><h3 id="剪枝条件"><a class="header-anchor" href="#剪枝条件">¶</a>剪枝条件</h3><ul><li>利用<code>p*q==n</code>这一条件来进行筛选，由于是从低位开始爆破，因此满足$p_{low}*q_{low}==n_{low}$</li></ul><p>&lt;!–code￼0–&gt;</p><h2 id="p-q-rev"><a class="header-anchor" href="#p-q-rev">¶</a>p^q_rev</h2><p>&lt;!–code￼1–&gt;</p><h3 id="搜索方式-v2"><a class="header-anchor" href="#搜索方式-v2">¶</a>搜索方式</h3><ul><li>从两端爆破</li><li>每一次搜索，需利用当前 gift 两端的 bit 位。这是因为，gift 的当前最高位对应 p 的最高位及 q 的最低位，gift 的当前最低位对应 p 的最低位及 q 的最高位</li></ul><h3 id="剪枝条件-v2"><a class="header-anchor" href="#剪枝条件-v2">¶</a>剪枝条件</h3><ul><li>将 p、q 未搜索到的位全填 0，乘积应小于 n</li><li>将 p、q 未搜索到的位全填 1，乘积应大于 n</li><li>p、q 低 k 位乘积再取低 k 位，应与 n 的低 k 位相同</li></ul><p>&lt;!–code￼2–&gt;</p><h2 id="p-q-nbits"><a class="header-anchor" href="#p-q-nbits">¶</a>p^(q&gt;&gt;nbits)</h2><p>&lt;!–code￼3–&gt;</p><h3 id="思路"><a class="header-anchor" href="#思路">¶</a>思路</h3><p>这个其实并不算剪枝了，因为 gift 的高 16 位就是 P 的高 16 位。用 N 除以 P 后得到的就是 Q 的高位，再次利用 Q 的高位和 gift，可以求出 P 的 16 ～ 32 位，以此类推来恢复 P、Q。</p><p>&lt;!–code￼4–&gt;</p><h2 id="p-q-nbits-v2"><a class="header-anchor" href="#p-q-nbits-v2">¶</a>(p^q)&gt;&gt;nbits</h2><p>&lt;!–code￼5–&gt;</p><h3 id="搜索方式-v3"><a class="header-anchor" href="#搜索方式-v3">¶</a>搜索方式</h3><ul><li>从高位搜索</li><li>p 的高位乘 q 的高位的前半部分等于 n 的高位</li></ul><h3 id="剪枝条件-v3"><a class="header-anchor" href="#剪枝条件-v3">¶</a>剪枝条件</h3><ul><li>低位全补 0，相乘结果 &lt; n</li><li>低位全补 1，相乘结果 &gt; n</li></ul><p>&lt;!–code￼6–&gt;</p><h3 id="coppersmith"><a class="header-anchor" href="#coppersmith">¶</a>coppersmith</h3><p>上述剪枝只能求出高 262 位了，有多种组合，但仍缺少低 250 位，因此需要用到 coppersmith 来求解。</p><p>在具体应用情景中应当适当调整<code>beta</code>和<code>epsilon</code>。</p><p>&lt;!–code￼7–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2023CBCTF</title>
    <link href="/2023/11/01/2023CBCTF/"/>
    <url>/2023/11/01/2023CBCTF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前和 N1CTF 撞了，但是比赛题目质量很高，当时浅看了一下，现在补一下。</p></blockquote><h2 id="CB-Curve"><a class="header-anchor" href="#CB-Curve">¶</a>CB_Curve</h2><p>利用 Grobner 基解 P 点，后续复现才知道这是<code>HUFF</code>曲线，根据论文方法得到曲线的定义和映射方法，这样就可得到维尔斯特拉斯形式，后续通过光滑阶求解离散对数即可。</p><p>关于 Grobner 基的应用，想到暑假<code>0x401</code>师傅出的一道题，后续写在这道题后面，加深一下印象。</p><p>曲线形式</p><p>$$<br>x(a<sup>2y-1)≡y(bx</sup>2-1) mod \quad p<br>$$</p><p>曲线映射</p><p>$$<br>(x,y)→(\frac{bx-ay}{y-x},\frac{b-a}{y-x})<br>$$</p><p>目标曲线</p><p>$$<br>y<sup>2≡x</sup>3+(a+b)x^2+abx \quad mod \quad p<br>$$</p><p>&lt;!–code￼0–&gt;</p><h3 id="ezAlgebra-DASCTF-2023-0X401"><a class="header-anchor" href="#ezAlgebra-DASCTF-2023-0X401">¶</a>ezAlgebra(DASCTF 2023 &amp; 0X401)</h3><p>题目描述</p><p>&lt;!–code￼1–&gt;</p><p>一元 coppersimth 用 c1 求 t，从而获得 p</p><p>&lt;!–code￼2–&gt;</p><p>根据 c2、c3 建立两个多项式</p><p>&lt;!–code￼3–&gt;</p><p>虽然只有 m 未知，但使用 Grobner 基需要至少二元多项式，所以引入 t，同理引入<code>f3 = t-2915836867</code>，接下来采用 Grobner 获得理想基即可。</p><p>&lt;!–code￼4–&gt;</p><p>最终解 flag</p><p>&lt;!–code￼5–&gt;</p><h2 id="CB-RSA"><a class="header-anchor" href="#CB-RSA">¶</a>CB_RSA</h2><p>&lt;!–code￼6–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2023ACTF</title>
    <link href="/2023/10/30/2023ACTF/"/>
    <url>/2023/10/30/2023ACTF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>周末打了一下 ACTF，题目质量很高。总共 6 道题目做了 3 道，有一道卡着等后续复现。最近太累了，周末比赛，周内复现。。。🐭🐭 我啊，打 CTF 打的！</p></blockquote><h2 id="MDH"><a class="header-anchor" href="#MDH">¶</a>MDH</h2><blockquote><p>手快抢了个三血 hh</p></blockquote><p>看到这道题第一反应是死去的线代开始攻击我，好在还有点印象，对于矩阵的迹来说，就是对角线元素的和。</p><p>&lt;!–code￼0–&gt;</p><p>将<code>shared</code>的矩阵表示为$a_1^T\cdot b_1\cdot b_2^T \cdot a_2$</p><p>而题目已知$PKA=a_1\cdot a_2^T,PKB=b_1\cdot b_2^T$</p><p>对于迹的一个性质来说，若干向量相乘所得的方阵，改变其相乘顺序，矩阵的迹都应一致。</p><p>因此只需计算$PKA^T\cdot PKB$的迹即可。</p><p>&lt;!–code￼1–&gt;</p><h2 id="claw-crane"><a class="header-anchor" href="#claw-crane">¶</a>claw crane</h2><blockquote><p>题如其名，真牛魔抓娃娃</p></blockquote><p>&lt;!–code￼2–&gt;</p><p>总之就是要在你构造出的 128 位数当中随机选择选到 0 才会加分，256 次中需要正确 220 次，因此就想方设法让数字的 2 进制 0 多一些，<code>delta = abs(r * q - p * pow(2, 128))</code>，r 已知，需要我们传入 p、q，由于$p\cdot 2^{128}$相当于左移 128 位，因此我们也要让 rq 的低位尽可能也为 0，q 不能超过 2^64 次方，因此 q 的取值可以为$2<sup>{63},2</sup>{63}+2<sup>{62},2</sup>{62}…$ 对于给定的 r 和 q 计算一个 p 值，在多组当中进行 delta 中 0 个数的计算，选择 0 个数最高的一组 p、q 发送，分数可以稳定在 2000 以上，运气好一会就出了。</p><p>&lt;!–code￼3–&gt;</p><h2 id="Easy-RSA"><a class="header-anchor" href="#Easy-RSA">¶</a>Easy RSA</h2><p>题目</p><p>&lt;!–code￼4–&gt;</p><p>关键信息</p><p>&lt;!–code￼5–&gt;</p><p>说明了这一组<code>e_,d_</code>满足三个模数 n，相当于已知三组 n、e，对于题目所限制的 d 的位数，刚好满足造格的情况</p><p>&lt;!–code￼6–&gt;</p><h3 id="Review"><a class="header-anchor" href="#Review">¶</a>Review</h3><p>此部分在阅读其余队伍 wp 后的复盘，对于上题，格的具体构造思路描述如下：</p><p>$$<br>\begin{aligned}<br>ED -k_1N_1 &amp;= 1+k_1x_1 \<br>ED -aN_2 &amp;= 1+ax_2 \<br>ED -dN_3 &amp;= 1+dx_3<br>\end{aligned}<br>$$</p><p>构造格:</p><p>$$<br>\begin{bmatrix}<br>2^{767} &amp; E &amp;E&amp;E\<br>0 &amp; -N_1 &amp;0&amp;0\<br>0 &amp; 0 &amp;-N_2&amp;0\<br>0 &amp; 0 &amp;0&amp;-N_3\<br>\end{bmatrix}<br>$$</p><h2 id="Mid-RSA-赛后复现"><a class="header-anchor" href="#Mid-RSA-赛后复现">¶</a>Mid RSA(赛后复现)</h2><p>与 Easy 不同的地方在于将 d 位数提高，原本的格无法规约出来，当时调格子调吐了，但是真没想到本地生成一组数和上一题对比一下，上题的格子拿过来只是差了几位低位。。。</p><p>&lt;!–code￼7–&gt;</p><p>对于</p><p>$$<br>\begin{aligned}<br>e(d_h\times2^{16}+d_l) -1 &amp;= k_1\phi(N_1) \<br>e(d_h\times2^{16}+d_l) -1 &amp;= k_2\phi(N_2) \<br>e(d_h\times2^{16}+d_l) -1 &amp;= k_3\phi(N_3)<br>\end{aligned}<br>$$</p><p>有</p><p>$$<br>\begin{aligned}<br>e2^{16}d_h+ed_l -k_1N_1 &amp;= 1+k_1s_1 \<br>e2^{16}d_h+ed_l -k_2N_2 &amp;= 1+k_2s_2 \<br>e2^{16}d_h+ed_l -k_3N_3 &amp;= 1+k_3s_3<br>\end{aligned}<br>$$</p><p>构造格:</p><p>$$<br>\begin{bmatrix}<br>1 &amp; e2^{16} &amp;e2<sup>{16}&amp;e2</sup>{16}&amp;0\<br>0 &amp; -N_1 &amp;0&amp;0&amp;0\<br>0 &amp; 0 &amp;-N_2&amp;0&amp;0\<br>0 &amp; 0 &amp;0&amp;-N_3&amp;0\<br>0 &amp; ed_l&amp;ed_l&amp;ed_l&amp;1\<br>\end{bmatrix}<br>$$</p><p>构造方法参考星盟 0HB 师傅，至于为何是低位 16 位，师傅给出的解释是，本地测了一组数据，发现用上一题的格子跑出来相差了 16 位，但具体相差多少还需要具体研究，由于 16 位已足够爆破，因此公式中写为了 16 次方。</p><p>经本人测试，对于本题的 d 缺失了 7 位。</p><p>&lt;!–code￼8–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2023N1CTF</title>
    <link href="/2023/10/23/N1CTF2023/"/>
    <url>/2023/10/23/N1CTF2023/</url>
    
    <content type="html"><![CDATA[<blockquote><p>周末和吉大东大的好哥哥们打了 n1，最后拿了 rank7，被 web👴 和 pwn👴带飞</p></blockquote><blockquote><p>DJB 战队 wp:https://mp.weixin.qq.com/s/N03QtNsMvpux42xIAXxvrA</p></blockquote><h2 id="e2wrmup">e2W@rmup</h2><p>ECDSA 椭圆曲线签名，之前没用过<code>ecdsa</code>库，结果发现 d就是私钥，拆分一下高低位，二元 coppersmith梭一下，中间可能要补一位，补了 0 之后就可以了。</p><p>后面看师傅们博客还可以用格做，学到了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> itertools<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">small_roots</span>(<span class="hljs-params">f, bounds, m=<span class="hljs-number">1</span>, d=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> d:<br>        d = f.degree()<br>    R = f.base_ring()<br>    N = R.cardinality()<br><br>    f /= f.coefficients().pop(<span class="hljs-number">0</span>)<br>    f = f.change_ring(ZZ)<br><br>    G = <span class="hljs-type">Sequence</span>([], f.parent())<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m + <span class="hljs-number">1</span>):<br>        base = N ^ (m - i) * f ^ i<br>        <span class="hljs-keyword">for</span> shifts <span class="hljs-keyword">in</span> itertools.product(<span class="hljs-built_in">range</span>(d), repeat=f.nvariables()):<br>            g = base * prod(<span class="hljs-built_in">map</span>(power, f.variables(), shifts))<br>            G.append(g)<br><br>    B, monomials = G.coefficient_matrix()<br>    monomials = vector(monomials)<br><br>    factors = [monomial(*bounds) <span class="hljs-keyword">for</span> monomial <span class="hljs-keyword">in</span> monomials]<br>    <span class="hljs-keyword">for</span> i, factor <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(factors):<br>        B.rescale_col(i, factor)<br><br>    B = B.dense_matrix().LLL()<br><br>    B = B.change_ring(QQ)<br>    <span class="hljs-keyword">for</span> i, factor <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(factors):<br>        B.rescale_col(i, <span class="hljs-number">1</span> / factor)<br><br>    H = <span class="hljs-type">Sequence</span>([], f.parent().change_ring(QQ))<br>    <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> <span class="hljs-built_in">filter</span>(<span class="hljs-literal">None</span>, B * monomials):<br>        H.append(h)<br>        I = H.ideal()<br>        <span class="hljs-keyword">if</span> I.dimension() == -<span class="hljs-number">1</span>:<br>            H.pop()<br>        <span class="hljs-keyword">elif</span> I.dimension() == <span class="hljs-number">0</span>:<br>            roots = []<br>            <span class="hljs-keyword">for</span> root <span class="hljs-keyword">in</span> I.variety(ring=ZZ):<br>                root = <span class="hljs-built_in">tuple</span>(R(root[var]) <span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> f.variables())<br>                roots.append(root)<br>            <span class="hljs-keyword">return</span> roots<br><br>    <span class="hljs-keyword">return</span> []<br><br>msg = <span class="hljs-string">b&#x27;welcome to n1ctf2023!&#x27;</span><br>msg_hash = bytes_to_long(hashlib.sha256(msg).digest())<br><br>s = <span class="hljs-number">98064531907276862129345013436610988187051831712632166876574510656675679745081</span><br>r = <span class="hljs-number">9821122129422509893435671316433203251343263825232865092134497361752993786340</span><br><br>p = <span class="hljs-number">115792089210356248762697446949407573529996955224135760342422259061068512044369</span><br>leak = <span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;10000111001100100010110100100000000100101000111011000001001011010100001010010000101001100011011010100000010010011011100010111001&quot;</span>, <span class="hljs-number">2</span>)<br>P.&lt;low,small&gt; = PolynomialRing(Zmod(p))<br><br>f = r*((small*(<span class="hljs-number">2</span>^<span class="hljs-number">128</span>))+low)+msg_hash-(leak&lt;&lt;<span class="hljs-number">128</span>)*s-small*s<br>roots = small_roots(f, [<span class="hljs-number">2</span>^<span class="hljs-number">129</span>, <span class="hljs-number">2</span>^<span class="hljs-number">130</span>], m=<span class="hljs-number">3</span>, d=<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(roots)<br><br>low = <span class="hljs-number">109657576978117277727118025094273115603</span><br>high = <span class="hljs-number">222660286808164019769040839717358598716</span><br><br>d = <span class="hljs-built_in">bin</span>(high)[<span class="hljs-number">2</span>:]+<span class="hljs-string">&#x27;0&#x27;</span>+<span class="hljs-built_in">bin</span>(low)[<span class="hljs-number">2</span>:]<br>d = <span class="hljs-built_in">int</span>(d, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(d.bit_length())<br>aes = AES.new(long_to_bytes(d), mode=AES.MODE_ECB)<br>cipher = <span class="hljs-string">b&#x27;\xf3#\xff\x17\xdf\xbb\xc0\xc6v\x1bg\xc7\x8a6\xf2\xdf~\x12\xd8]\xc5\x02Ot\x99\x9f\xf7\xf3\x98\xbc\x045\x08\xfb\xce1@e\xbcg[I\xd1\xbf\xf8\xea\n-&#x27;</span><br>flag = aes.decrypt(cipher)<br><span class="hljs-built_in">print</span>(flag)<br><span class="hljs-comment"># b&#x27;n1ctf&#123;Wow!__You_bre4k_my_s1gn_chal1enge!!___&#125;\x03\x03\x03&#x27;</span><br><br></code></pre></td></tr></table></figure><h2 id="e2d1p赛后复现">e2d1p[赛后复现]</h2><p>参考文章：</p><p><ahref="">https://tl2cents.github.io/2023/10/23/2023-N1CTF-Crypto-Writeups/</a></p><p>https://github.com/Nu1LCTF/n1ctf-2023/tree/main/crypto/e2D1p</p><p>题目</p><blockquote><p>Based on N1CTF 2022 “ezdlp”. Easy dlp too, try again : ).</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br>FLAG = os.environ.get(<span class="hljs-string">&#x27;FLAG&#x27;</span>, <span class="hljs-string">b&#x27;n1ctf&#123;XXXXFAKE_FLAGXXXX&#125;&#x27;</span>)<br><span class="hljs-keyword">assert</span> FLAG[:<span class="hljs-number">6</span>] == <span class="hljs-string">b&#x27;n1ctf&#123;&#x27;</span> <span class="hljs-keyword">and</span> FLAG[-<span class="hljs-number">1</span>:] == <span class="hljs-string">b&#x27;&#125;&#x27;</span><br>FLAG = FLAG[<span class="hljs-number">6</span>:-<span class="hljs-number">1</span>]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">keygen</span>(<span class="hljs-params">nbits</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        q = getPrime(nbits)<br>        <span class="hljs-keyword">if</span> isPrime(<span class="hljs-number">2</span>*q+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">0x10001</span>, q, <span class="hljs-number">2</span>*q+<span class="hljs-number">1</span>) == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*q+<span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">encrypt</span>(<span class="hljs-params">key, message, mask</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">0x10001</span>, message^mask, key)<br><br><br>p = keygen(<span class="hljs-number">512</span>)<br>flag = bytes_to_long(FLAG)<br>messages = [getRandomNBitInteger(flag.bit_length()) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>)]<br>enc = [encrypt(p, message, flag) <span class="hljs-keyword">for</span> message <span class="hljs-keyword">in</span> messages]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;message = <span class="hljs-subst">&#123;messages&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;enc = <span class="hljs-subst">&#123;enc&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="x01-恢复模数-p">0x01 恢复模数 p</h3><p>给了 200 组 m、c 满足等式<spanclass="math inline">\(65537^{m_i⊕mask}=c_i (mod p)\)</span></p><p>异或运算在指数上，没有什么运算性质。但异或的本质还是按位异或，以下用m[i]表示 m 的第 i 位，对于一组 m 和 c 而言</p><p><span class="math display">\[m\oplus mask = mask+\sum\limits_{j=0}\limits^{158}(m[j]\cdot2^i\cdot(-1)^{s[i]})\]</span></p><p>这样转换后即可把底数看作<spanclass="math inline">\(c_i=65537^{mask}\)</span>，下一步的目的就是找到某个向量<spanclass="math inline">\(e_i\)</span>使得<spanclass="math inline">\(c_i^{e_i}≡0\;mod\;p\)</span>，这样即可恢复出模数<spanclass="math inline">\(gcd(e_i,e_j)=p\)</span></p><p>找到满足条件的<span class="math inline">\(e_i\)</span>需要<spanclass="math inline">\(m_i\)</span>，构造如下格：</p><p><span class="math inline">\(m_{i,j}=m_{i,j}*2^{256}\)</span></p><p><span class="math display">\[\begin{bmatrix}m_{0,0} &amp; m_{0,1} &amp; \ldots &amp; m_{0,158} &amp; 1 &amp; 0 &amp;\ldots &amp;0\\m_{1,0} &amp; m_{1,1} &amp; \ldots &amp; m_{1,158} &amp; 0 &amp; 1&amp;\ldots &amp;0\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots&amp; \ddots &amp; \vdots\\m_{199,0} &amp; m_{199,1} &amp; \ldots &amp; m_{199,158} &amp; 0&amp;0&amp; \ldots &amp;1\\\end{bmatrix}\]</span></p><p>利用<code>LLL</code>算法得到的<spanclass="math inline">\(e_i\)</span>满足<spanclass="math inline">\(\sum\limits_{i=1}\limits^{200}e_i=0\)</span>，那么也就满足<spanclass="math inline">\(\sum\limits_{i=1}\limits^{200}e_i\cdotm_i=\vec{0}\)</span></p><h3 id="x02-求解-mask">0x02 求解 mask</h3><p>x=mask</p><p><span class="math display">\[65537^{\sum2^i\cdot(x_i\oplus m_i)}=c(mod \;p)\]</span></p><p>变换成如下形式</p><p><spanclass="math display">\[(65537)^{\sum\limits_{\{i|m_i=0\}}2^i\cdotx_i+\sum\limits_{\{j|m_j=1\}}2^j\cdot(1-x_j)}=c\;(mod \;p)\]</span></p><p><spanclass="math display">\[(65537)^{\sum\limits_{\{i|m_i=0\}}2^i\cdotx_i+\sum\limits_{\{j|m_j=1\}}2^j\cdot(-x_j)}=c\cdot65537^{-\sum\limits_{\{j|m_j=1\}}2^j} (mod \;p)\]</span></p><p>根据上式中<span class="math inline">\(m_i\)</span>为 0 或 1的情况构造对应<span class="math inline">\(x_i\)</span>的系数矩阵<spanclass="math inline">\(A\)</span>，系数只为 1 或-1</p><p>计算向量<span class="math inline">\(u\cdot A=(1,0,\cdots,0)\;(mod\;q)\)</span>（模 q 是保证阶为素数，使得向量有解）</p><p>当<span class="math inline">\(mask_i=0\)</span>时，便可按下式逐位恢复mask</p><p><spanclass="math display">\[\prod\limits_{i=1}\limits^{200}c_i^{u_i}=65537^0=1(mod\;p)\]</span><span class="math display">\[c_i=c_i\cdot65537^{-\sum\limits_{\{j|m_j=1\}}2^j}(mod\;p)\]</span></p><h3 id="exp">exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> ast <span class="hljs-keyword">import</span> literal_eval<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>lines = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./output.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>).readlines()<br>message = literal_eval(lines[<span class="hljs-number">0</span>].strip())<br>enc = literal_eval(lines[<span class="hljs-number">1</span>].strip())<br><br><br>m_l = <span class="hljs-number">159</span><br>dim = <span class="hljs-number">200</span><br>L = matrix(ZZ, dim, dim+m_l+<span class="hljs-number">1</span>)<br>g = <span class="hljs-number">2</span> ^ <span class="hljs-number">512</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(dim):<br>    L[i, i] = <span class="hljs-number">1</span><br>    L[i, dim+m_l] = g<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(dim):<br>    line = <span class="hljs-built_in">bin</span>(message[i])[<span class="hljs-number">2</span>:].rjust(m_l, <span class="hljs-string">&#x27;0&#x27;</span>)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(line)):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(line[j]):<br>            L[i, dim+j] = g<br>        <span class="hljs-keyword">else</span>:<br>            L[i, dim+j] = <span class="hljs-number">0</span><br><br><br>basis = L.LLL()[:<span class="hljs-number">40</span>]<br>p = []<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> basis:<br>    g1 = <span class="hljs-number">1</span><br>    g2 = <span class="hljs-number">1</span><br>    vec = item[:dim]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(vec)):<br>        <span class="hljs-keyword">if</span> vec[i] &gt;= <span class="hljs-number">0</span>:<br>            g1 *= <span class="hljs-built_in">pow</span>(enc[i], vec[i])<br>        <span class="hljs-keyword">else</span>:<br>            g2 *= <span class="hljs-built_in">pow</span>(enc[i], -vec[i])<br>    p.append(g1-g2)<br><br>p = <span class="hljs-built_in">list</span>(factor(reduce(GCD, p)))[-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br>q = (p-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span><br>A = matrix(Zmod(q), dim, m_l)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(dim):<br>    line = <span class="hljs-built_in">bin</span>(message[i])[<span class="hljs-number">2</span>:].rjust(m_l, <span class="hljs-string">&#x27;0&#x27;</span>)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(line)):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(line[j]):<br>            A[i, j] = -<span class="hljs-number">1</span><br>            enc[i] = enc[i]*inverse_mod(<span class="hljs-built_in">pow</span>(<span class="hljs-number">0x10001</span>, <span class="hljs-number">2</span> ^ (m_l-<span class="hljs-number">1</span>-j), p), p) % p<br>        <span class="hljs-keyword">else</span>:<br>            A[i, j] = <span class="hljs-number">1</span><br><br>m = <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(m_l)):<br>    v = vector(Zmod(q), [<span class="hljs-number">0</span>]*_+[<span class="hljs-number">1</span>]+[<span class="hljs-number">0</span>]*(m_l-<span class="hljs-number">1</span>-_))<br>    u = A.solve_left(v)<br>    sign = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(u)):<br>        <span class="hljs-keyword">if</span> u[i] &gt;= <span class="hljs-number">0</span>:<br>            sign = sign*<span class="hljs-built_in">pow</span>(enc[i], <span class="hljs-built_in">int</span>(u[i]), p) % p<br>        <span class="hljs-keyword">else</span>:<br>            sign = sign*inverse_mod(<span class="hljs-built_in">pow</span>(enc[i], -<span class="hljs-built_in">int</span>(u[i]), p), p) % p<br>    <span class="hljs-keyword">if</span> sign != <span class="hljs-number">1</span>:<br>        m += <span class="hljs-string">&#x27;1&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        m += <span class="hljs-string">&#x27;0&#x27;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bytes</span>.fromhex(<span class="hljs-built_in">hex</span>(<span class="hljs-built_in">int</span>(m, <span class="hljs-number">2</span>))[<span class="hljs-number">2</span>:]))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LCG</title>
    <link href="/2023/06/19/LCG/"/>
    <url>/2023/06/19/LCG/</url>
    
    <content type="html"><![CDATA[<h2 id="LCG"><a class="header-anchor" href="#LCG">¶</a>LCG</h2><p>线性同余（LCG）是产生伪随机数的方法。</p><h2 id="基本形式："><a class="header-anchor" href="#基本形式：">¶</a>基本形式：</h2><p>$$<br>X_{n+1}=(aX_n+b);mod;m<br>$$</p><h2 id="基本公式"><a class="header-anchor" href="#基本公式">¶</a>基本公式</h2><h3 id="公式一"><a class="header-anchor" href="#公式一">¶</a>公式一</h3><p><strong>求递归数组元素</strong></p><p>$$X_n=a^{-1}(X_{n+1}-b);mod;m$$</p><h3 id="公式二"><a class="header-anchor" href="#公式二">¶</a>公式二</h3><p><strong>求参数 a</strong><br>利用两个递归式消去 b 得到 a</p><p>$$a=(X_{n+2}-X_{n+1})(X_{n+1}-X_n)^{-1}$$</p><h3 id="公式三"><a class="header-anchor" href="#公式三">¶</a>公式三</h3><p><strong>求参数 b</strong><br>$$b=(X_{n+1}-aX_{n});mod;m$$</p><h3 id="公式四"><a class="header-anchor" href="#公式四">¶</a>公式四</h3><p><strong>求参数 m</strong></p><p>$$t_n=X_{n+1}-X_n$$<br>$$t_n=(aX_n+b)-(aX_{n-1}+b);mod;m$$<br>$$t_{n+1}t_{n-1}-t_nt_n=0;mod;m$$<br>$$T_n=t_{n+1}t_{n-1}-t_nt_n是 m 的倍数$$<br>$$m=gcd(T_n,T_{n-1})$$</p><h2 id="相关求解代码"><a class="header-anchor" href="#相关求解代码">¶</a>相关求解代码</h2><p>&lt;!–code￼0–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>D^3CTF</title>
    <link href="/2023/05/07/d3ctf2023/"/>
    <url>/2023/05/07/d3ctf2023/</url>
    
    <content type="html"><![CDATA[<h1>d3noisy</h1><p>&lt;!–code￼0–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RSA(持续更新🫡)</title>
    <link href="/2023/04/20/RSA/"/>
    <url>/2023/04/20/RSA/</url>
    
    <content type="html"><![CDATA[<h1>基本原理</h1><p>RSA 中加、解密：</p><p>加密$c = m^e\quad mod\quad n$</p><p>解密$m = c^d\quad mod\quad n$</p><p>接下来证明一下解密过程，先引入欧拉定理。</p><h2 id="欧拉定理"><a class="header-anchor" href="#欧拉定理">¶</a>欧拉定理</h2><p>对于互为质数的 m、n 两个数，有$m^{\phi(n)} = 1\quad mod\quad n$，其中$\phi(n)$表示小于 n 的质数的个数。</p><h2 id="解密原理"><a class="header-anchor" href="#解密原理">¶</a>解密原理</h2><p>通过$c = m^e\quad mod\quad n$与欧拉定理$m^{\phi(n)} = 1\quad mod\quad n$，我们便可进行推导。</p><p>对欧拉定理进行变形，得到$m^{k\phi(n)+1} = m\quad mod\quad n$</p><p>因为我们已经知道$c = m^e\quad mod\quad n$，所以寻找一个 d，使得$ed = k\phi(n)+1$,则可以得到$m^{ed}=m\quad mod \quad n$</p><p>则得到了$c^d =m\quad mod\quad n$</p><h1>共模攻击</h1><p>所谓共模，就是 n 相同，会对应多组 c，e。</p><p>例：给定 n、c1、c2、e1、e2</p><p>m = c<sub>1</sub><sup>e1</sup> mod n</p><p>m = c<sub>2</sub><sup>e2</sup> mod n</p><h2 id="扩展欧几里得算法"><a class="header-anchor" href="#扩展欧几里得算法">¶</a>扩展欧几里得算法</h2><p>给定两个整数 a、b，必定存在 x、y，使得 gcd(a,b)=ax+by</p><p>运用该算法推导过程</p><p>m = m % n</p><p>m = m<sup>s1e1+s2e2</sup> % n</p><p>m = (m<sup>e1s1</sup> * m<sup>e2s2</sup>)% n</p><p>m = (m<sup>e1s1</sup> % n) * (m<sup>e2s2</sup> % n) % n</p><p>m = (c1<sup>s1</sup> % n) * (c2<sup>s2</sup> % n) % n</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p><h1>Wiener’s Attack</h1><p>适用于已知 N、e，且 e 过大或过小。</p><p>Wiener 表示如果$d&lt;\frac{1}{3}n^{\frac{1}{4}}$,那么一种基于<strong>连分数</strong>的攻击就可危及 RSA 安全。</p><p>那么什么是连分数以及如何利用呢？</p><h2 id="连分数"><a class="header-anchor" href="#连分数">¶</a>连分数</h2><p>当 $a_0, a_1, a_2, \dots, a_n$ 都是正整数时，一个连分数可以表示为：<br>$$x;=;a_0 + \cfrac{1}{a_1 + \cfrac{1}{a_2 + \cfrac{1}{\ddots + \cfrac{1}{a_n}}}}$$</p><p>例如我们可以求解$\pi$的近似值<br>$$\pi = 3 + \cfrac{1}{7 + \cfrac{1^2}{15 + \cfrac{2^2}{1 + \cfrac{3^2}{1 + \cfrac{4^2}{2 + \cdots}}}}}$$<br>其中每一项可以用如下公式计算：</p><p>$$<br>a_k = \begin{cases}<br>a_0, &amp; k=0 \<br>\lfloor b_k \rfloor, &amp; k &gt; 0<br>\end{cases}\<br>$$</p><p>$$<br>b_k = \begin{cases}<br>a_0, &amp; k=0 \<br>\dfrac{1}{b_{k-1} - \lfloor b_{k-1} \rfloor}, &amp; k &gt; 0<br>\end{cases}<br>$$</p><p>在这个例子中，$a_0 = 3$，并且按照上述公式递归计算 $a_k$ 和 $b_k$ 直到达到一定精度为止，就可以得到一个近似值 $\pi \approx 3.14159265$。</p><p>至此也就明白了连分数的作用，常用于无理数的逼近。</p><p>当然，也可以逼近一个任意数，得到最接近精确值的近似值。</p><h2 id="Legendre’s-theorem"><a class="header-anchor" href="#Legendre’s-theorem">¶</a>Legendre’s theorem</h2><p>$$\left | \frac{e}{N}-\frac{k}{d} \right |\leq \frac{1}{2d^2}$$<br>当满足这一点时，$\frac{k}{d}$就是$\frac{e}{N}$的连分数收敛。</p><h2 id="攻击-RSA-原理"><a class="header-anchor" href="#攻击-RSA-原理">¶</a>攻击 RSA 原理</h2><p>$$\phi(n)=(p-1)(q-1)$$</p><p>$$\because p,q很大,\therefore \phi(n) \approx N$$<br>$$ed - 1=k\phi(n)$$<br>同除 $d\phi(n)$ 得<br>$$\frac{e}{\phi(n)}-\frac{k}{d}=\frac{1}{d\phi(n)}$$<br>$$\therefore \frac{e}{N}-\frac{k}{d}=\frac{1}{d\phi(n)}$$</p><p>到这里发现，等式右边的$\frac{1}{d\phi(n)}$很小，因此$\frac{k}{d}$就是一个对于已知量$\frac{e}{N}$的一个连分数逼近。</p><p>因此可以通过将$\frac{e}{N}$的连分数展开，依次计算每一个渐进分数。Wiener 证明了可以精准覆盖$\frac{k}{d}$。</p><h2 id="exp"><a class="header-anchor" href="#exp">¶</a>exp</h2><p>&lt;!–code￼1–&gt;</p><h1>Extending Wiener’s Attack</h1><p>扩展维纳攻击是为了扩展到$n$个加密指数$e_i$,且$d_i$都较小的情况。<br>由$e<em>d-k</em>\lambda(N)=1$得</p><p>$$d_ige_i-k_iN=g+k_is$$</p><p>记为维纳等式$W_i$。</p><p>利用 Guo 的方法可得到关系式:<br>$$k_id_je_j-k_jd_ie_i=k_i-k_j$$</p><p>记为郭等式$G_{i,j}$。注意到两种等式的右侧都非常小。</p><p>参考论文和 wiki 中的做法，后续的思路是使用这两个式子的不同关系去构造格，进而格基约化求得$\phi(N)$来实现$N$的分解。</p><h2 id="两个小解密指数"><a class="header-anchor" href="#两个小解密指数">¶</a>两个小解密指数</h2><h2 id="三个小解密指数"><a class="header-anchor" href="#三个小解密指数">¶</a>三个小解密指数</h2><h1>低加密指数攻击 e=3</h1><p>&lt;!–code￼2–&gt;</p><h1>低加密指数广播攻击</h1><p>特点是 e 小，有多组 n，对应了多组 c</p><p>m<sup>e</sup> = c1 mod n1</p><p>m<sup>e</sup> = c2 mod n2</p><p>m<sup>e</sup> = c3 mod n3</p><h2 id="中国剩余定理-CRT"><a class="header-anchor" href="#中国剩余定理-CRT">¶</a>中国剩余定理(CRT)</h2><p>定理内容如下</p><p>针对上述方程组，若 n1、n2、n3 互质，对于任意的 c1、c2、c3，方程组都有解 m。</p><p>使用条件是 m^e &lt; n1、n2、n3。通解推导如下：</p><p>设$N=n_1 \times n_2 \times n_3, N_1=N/n_1, N_2=N/n_2, N_3=N/n_3$</p><p>设$t_i=N_i^{-1}$,这里表示$t_i$是$N_i$在模$n_i$的逆元。</p><p>有了以上几个数，我们可以给出通解形式：</p><p>$$m=c_1t_1N_1+c_2t_2N_2+c_3t_3N_3+kN=kN+\sum_{i=1}^3c_it_iN_i$$</p><p>在模 N 后，只剩唯一解$m=\sum_{i=1}^3c_it_iN_i$</p><h2 id="EXP-v2"><a class="header-anchor" href="#EXP-v2">¶</a>EXP</h2><p>&lt;!–code￼3–&gt;</p><h1>dp、dq 相关</h1><h2 id="给定-dp、dq-类型"><a class="header-anchor" href="#给定-dp、dq-类型">¶</a>给定 dp、dq 类型</h2><p>dp ≡ d mod (p-1)</p><p>dq ≡ d mod (q-1)</p><p>m ≡ c<sup>d</sup> mod n</p><p>m = c<sup>d</sup> + k * n</p><p>m = c<sup>d</sup> +k _ p _ q</p><p>对上式两端同时对 p、q 分别取余，得：（中国剩余定理）</p><p>m1 ≡ c<sup>d</sup> mod p</p><p>m2 ≡ c<sup>d</sup> mod q</p><p>同理，可得到<br>c<sup>d</sup> = m1 +k * p</p><p>代入到 m2 ≡ c<sup>d</sup> mod q 中：</p><p>m2 ≡ (m1 + k * p)mod q ，两端减去 m1 得</p><p>m2 - m1 ≡ k * p mod q ，两端乘 p 的逆元得</p><p>(m2 - m1)p<sup>-1</sup> ≡ k mod q</p><p>将 k 代入到 c<sup>d</sup> = m1 +k * p 中得：</p><p>c<sup>d</sup> = m1 + ((m2 - m1)p<sup>-1</sup> mod q) * p</p><p>m=c<sup>d</sup> mod n</p><p>得到</p><p>m ≡ (((m2 - m1) _ p<sup>-1</sup> mod q) _ p + m1) mod n</p><p>接下来就是求解 m1，m2</p><p>m1 ≡ c<sup>dp+k(p-1)</sup> mod p</p><p>m2 ≡ c<sup>dq+k(q-1)</sup> mod q</p><p>根据费马小定理</p><p>若 p 是素数，则 a<sup>(p-1)</sup> ≡ 1 mod p</p><p>因此 m1 ≡ c<sup>dp</sup> mod p，m2 ≡ c<sup>dq</sup> mod q</p><p>最终可求得 m</p><h3 id="EXP-v3"><a class="header-anchor" href="#EXP-v3">¶</a>EXP</h3><p>&lt;!–code￼4–&gt;</p><h2 id="只给定-dp"><a class="header-anchor" href="#只给定-dp">¶</a>只给定 dp</h2><p>dp ≡ d mod (p-1)</p><p>ed ≡ 1 mod (p-1) * (q-1)</p><p>ed = 1 + k2(p-1)(q-1)</p><p>对 1 式两端同乘 e，得</p><p>e * dp ≡ ed mod (p-1)</p><p>e * dp = k1(p-1) + ed</p><p>代入 ed 得</p><p>e * dp = k1(p-1) + 1 + k2(p-1)(q-1)</p><p>由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余 p-1，即可消掉 n</p><p>e * dp ≡ 1 mod (p-1)</p><p>e * dp =k(p-1) + 1</p><p>得到这个式子后，其实真正意义上的未知数只有我们要求的 p，但是还存在一个 k。</p><p>针对 k，我们判断一下他的范围，看看能否采用爆破的方式。</p><p>k = (e * dp - 1)/(p-1)</p><p>因为 dp &lt; p-1</p><p>所以 k &lt; e</p><p>通过遍历 k 然后找到(e * dp - 1)可以整除 k 的情况即可。</p><p>(跑了一下发现限制条件还不够)</p><p>因此再加一个 n 能否整除 p 即可。</p><h3 id="EXP-v4"><a class="header-anchor" href="#EXP-v4">¶</a>EXP</h3><p>&lt;!–code￼5–&gt;</p><h1>DLP</h1><h2 id="magic-hitcon2021"><a class="header-anchor" href="#magic-hitcon2021">¶</a>magic(hitcon2021)</h2><p>&lt;!–code￼6–&gt;</p><h3 id="EXP-v5"><a class="header-anchor" href="#EXP-v5">¶</a>EXP</h3><h1>rabin</h1><p>适用于 RSA 中 e=2 的情况</p><h2 id="pqpq-seccon2022"><a class="header-anchor" href="#pqpq-seccon2022">¶</a>pqpq(seccon2022)</h2><p>&lt;!–code￼7–&gt;</p><h3 id="大致思路"><a class="header-anchor" href="#大致思路">¶</a>大致思路</h3><p>根据题目，可先通过计算 c1、c2 表达式，合并找出公因子，即可求出 p、q，从而 r 也可求得。<br>发现 e=65537 * 2，因此是无逆元存在的，索性就将 e 拆分为 65537 与 2，e2=2 时便可通过 Rabin 算法解密。</p><h3 id="求-p、q、r"><a class="header-anchor" href="#求-p、q、r">¶</a>求 p、q、r</h3><p>$c2 = (p - q)^e \mod n \$<br>左右同乘 r<br>$c2 * r = rp^e + rq^e + X*pqr = rp^e + rq^e \mod n\$<br>$c2 = p^e + q^e \mod n\$<br>同理得到$c1 = p^e - q^e \mod n \$<br>从而求得 p、q<br>$p=gcd(c1+c2,n)\$</p><p>$q=gcd(c1-c2,n)\$</p><h3 id="求解-m-2"><a class="header-anchor" href="#求解-m-2">¶</a>求解 m^2</h3><p>$\phi(n)=(p-1)<em>(q-1)</em>(r-1)\$<br>通过 e1(e/2)和$\phi(n)$求出 d，得到$cm<sup>d=m</sup>{2<em>e1</em>d}=m^2 \mod n$</p><h3 id="Rabin-解密"><a class="header-anchor" href="#Rabin-解密">¶</a>Rabin 解密</h3><p>接下来就是传统 Rabin 解密，找了两种脚本，exp 中的<code>sqrtPrime(n,p)</code>和<code>Tonelli_Shanks(n,p)</code>任选其一即可，都是基于二次剩余定理所实现的解密算法</p><p>&lt;!–code￼8–&gt;</p><h1>e 与 phi 不互素</h1><h2 id="GCD-p-1-e-1-GCD-q-1-e-1"><a class="header-anchor" href="#GCD-p-1-e-1-GCD-q-1-e-1">¶</a>GCD(p-1,e)!=1 GCD(q-1,e)!=1</h2><p>&lt;!–code￼9–&gt;</p><h2 id="m-GCD-n"><a class="header-anchor" href="#m-GCD-n">¶</a>m^GCD &lt; n</h2><p>求出$d*t$后，对$m$开$t$次方根。</p><p>&lt;!–code￼10–&gt;</p><h2 id="m-GCD-n-v2"><a class="header-anchor" href="#m-GCD-n-v2">¶</a>m^GCD &gt; n</h2><p>$$t=GCD(e,phi)$$<br>$$d=inverse(e//t,phi)$$<br>$$c=pow(c,d,n)$$<br>使用 CRT 进行有限域开根<br>$$x^t;=c;mod;p$$<br>$$x^t;=c;mod;q$$</p><p>&lt;!–code￼11–&gt;</p><h2 id="AMM"><a class="header-anchor" href="#AMM">¶</a>AMM</h2><p>适用于$e$可整除$\phi$的情况</p><p>&lt;!–code￼12–&gt;</p><h1>已知 p^q 和 p*q</h1><p>&lt;!–code￼13–&gt;</p><h1>明文相关攻击</h1><p>&lt;!–code￼14–&gt;</p><p>适用于</p><p>$$<br>C_1=M^e ; mod; n \</p><p>C_2=(aM+b)^e ; mod ; n<br>$$</p><p>&lt;!–code￼15–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ECC(持续更新🥱)</title>
    <link href="/2023/04/19/ECC/"/>
    <url>/2023/04/19/ECC/</url>
    
    <content type="html"><![CDATA[<h1>ECC</h1><p>椭圆曲线密码学(Elliptic Curve Cryptography)，是一种基于椭圆曲线数学的公钥密码。</p><p>基于 ECC 的三大问题：<strong>密钥交换</strong>、<strong>数字签名</strong>、<strong>离散对数</strong></p><h2 id="椭圆曲线"><a class="header-anchor" href="#椭圆曲线">¶</a>椭圆曲线</h2><p>椭圆曲线定义式：$y<sup>2;=x</sup>3+ax+b$，（维尔斯特拉斯标准形式）</p><p>曲线的一般形式：$y<sup>2+a_1xy+a_3y;=x</sup>3+a_2x^2+a_4x+a_6$</p><p>判别式$\Delta=-16(4a<sup>3+27b</sup>2);mod;p=0$</p><h3 id="曲线性质"><a class="header-anchor" href="#曲线性质">¶</a>曲线性质</h3><p>椭圆曲线上的困难问题:$Q=nP$，给定椭圆曲线上$P、Q$两点，求$n$十分困难</p><h4 id="point-addition-点加法"><a class="header-anchor" href="#point-addition-点加法">¶</a>point addition 点加法</h4><p>沿曲线的 P + Q 两点画一条通过两点的直线。现在继续这条线，直到它第三次与你的曲线相交。最后在该点沿 y 轴的方向取反射。<br>$P+Q+R’=0,R=P+Q,R’(x,-y)=R(x,y)$<br><img src="/img/ECClines.png" alt=""></p><h4 id="有限域"><a class="header-anchor" href="#有限域">¶</a>有限域</h4><p>定义在有限域$F_p$上，零元是$O$</p><p>**点的阶:**对于椭圆曲线上一点$P$，若存在一个最小的正整数$n$，使得$nP=O$，则称$n$是点$P$的阶。</p><p>**椭圆曲线的阶:**每个在有限域上的椭圆曲线都由有限个点组成，有多少个点椭圆曲线的阶就是多少。</p><h3 id="Sage-环境"><a class="header-anchor" href="#Sage-环境">¶</a>Sage 环境</h3><p>在线环境<a href="https://sagecell.sagemath.org/">https://sagecell.sagemath.org/</a></p><p>本地环境<a href="https://doc.sagemath.org/html/en/installation/index.html">https://doc.sagemath.org/html/en/installation/index.html</a> (推荐在 Linux 环境搭建)</p><p>基本语法<a href="https://www.osgeo.cn/sagemath/tutorial/index.html">https://www.osgeo.cn/sagemath/tutorial/index.html</a></p><h4 id="简单运算"><a class="header-anchor" href="#简单运算">¶</a>简单运算</h4><p>&lt;!–code￼0–&gt;</p><h2 id="ECDH（密钥交换）"><a class="header-anchor" href="#ECDH（密钥交换）">¶</a>ECDH（密钥交换）</h2><p>ECDH 是椭圆曲线迪菲-赫尔曼秘钥交换（Elliptic Curve Diffie–Hellman key Exchange），主要是用来在一个不安全的通道中建立起安全的共有加密资料，一般来说交换的都是私钥。</p><h3 id="算法交换过程"><a class="header-anchor" href="#算法交换过程">¶</a>算法交换过程</h3><p><strong>公有参数</strong>：$p,g$</p><p><strong>Alice 私钥</strong>：大整数$a$</p><p><strong>生成 Alice 公钥</strong>：$A=g^a;\mod;p$</p><p>Alice 将$A,p,g$传递给 Bob</p><p><strong>Bob 私钥</strong>：大整数$b$</p><p><strong>生成 Bob 公钥</strong>：$B=g^b;\mod;p$</p><p><strong>Bob 计算公共密钥</strong>：$K=A^b;\mod;p$</p><p>Bob 将$B,p,g$传递给 Alice<br><strong>Alice 计算公共密钥</strong>：$K=B^a;\mod;p$</p><p>交换完成，二者协商出<code>K</code>公共密钥，并且未在传输过程中暴露 K。</p><h3 id="An-der-schonen-Elliptische-Kurve"><a class="header-anchor" href="#An-der-schonen-Elliptische-Kurve">¶</a>An_der_schonen_Elliptische_Kurve</h3><p>&lt;!–code￼1–&gt;</p><h3 id="exp"><a class="header-anchor" href="#exp">¶</a>exp</h3><p>&lt;!–code￼2–&gt;</p><h2 id="ECDSA（数字签名）"><a class="header-anchor" href="#ECDSA（数字签名）">¶</a>ECDSA（数字签名）</h2><p>基于椭圆曲线的 DSA</p><h3 id="场景"><a class="header-anchor" href="#场景">¶</a>场景</h3><p>Alice 想要使用她的私钥$d_A$来签名，Bob 想用 Alice 的公钥 $H_A$要验证签名$H_A=d_AG$。<br>只有 Alice 才能提供正确的签名，而每个人都可以验证签名。</p><h3 id="签名"><a class="header-anchor" href="#签名">¶</a>签名</h3><p>1.选定一条椭圆曲线$E_p(a,b)$。</p><p>2.选取一个随机数$k,1&lt;k&lt;n-1$，$n$为椭圆曲线的阶。</p><p>3.选取椭圆曲线的基点$G(a,b)$,计算 $K=k * G(a,b)$，令$r=K[0]\mod n$，即 r 是 K 点的横坐标（若 r 为 0，重新选 k 进行计算）。</p><p>4.计算明文 M 的哈希，令$e=hash(M)$，计算$s=k^{-1}(z+rd_A)\mod n$。</p><p>5.给出签名$(r,s)$</p><h3 id="验证"><a class="header-anchor" href="#验证">¶</a>验证</h3><p>1.计算 $u_1=s^{-1}z\mod n$</p><p>2.计算 $u_2=s^{-1}r\mod n$</p><p>3.计算点$P=u_1G+u_2H_A$</p><p>当$r=x_P\mod n$时，签名验证成功。</p><h3 id="DSA-LCG"><a class="header-anchor" href="#DSA-LCG">¶</a>DSA-LCG</h3><p><a href="https://cseweb.ucsd.edu/~mihir/papers/dss-lcg.pdf">试试这个</a></p><p>&lt;!–code￼3–&gt;</p><h2 id="ECDLP（离散对数）"><a class="header-anchor" href="#ECDLP（离散对数）">¶</a>ECDLP（离散对数）</h2><p>给定椭圆曲线 E，已知 P、Q 以及$Q=kP$，求 k。</p><p>&lt;!–code￼4–&gt;</p><h3 id="PH-光滑阶分解"><a class="header-anchor" href="#PH-光滑阶分解">¶</a>PH 光滑阶分解</h3><h4 id="crypto-sign-in-1-VNCTF2023"><a class="header-anchor" href="#crypto-sign-in-1-VNCTF2023">¶</a>crypto-sign-in-1(VNCTF2023)</h4><p>一道 ECDLP 题目，当时想到使用<code>Pohlig-Hellman</code>算法，但是一直没能找到合适的 A、B 来确定 G 的阶 n，赛后看大佬 wp，果然是用 pwntools 远程多试几组 y1、y2，找到光滑的阶，从而解密成功。</p><p>&lt;!–code￼5–&gt;</p><h4 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h4><p>&lt;!–code￼6–&gt;</p><h3 id="Singular-Attack"><a class="header-anchor" href="#Singular-Attack">¶</a>Singular Attack</h3><p>利用曲线上的奇异点进行攻击，奇点就是该点导数不存在，或者导数为 0 但不是极值点。<br>若椭圆曲线的判别式$\Delta=-16(4a<sup>3+27b</sup>2);mod;p=0$，说明该曲线有奇点。</p><h4 id="RWCTF2023-体验赛"><a class="header-anchor" href="#RWCTF2023-体验赛">¶</a>RWCTF2023 体验赛</h4><p>&lt;!–code￼7–&gt;</p><p>根据题目，可得到曲线关于 x 的导数，$3x<sup>2+4x+1$，所以可得到方程为$y</sup>2=x<sup>3+2x</sup>2+x+C$</p><p>题目已知点(4,10)在曲线上，代入得到 100 = 64 + 32 + 4 + C，即 C = 0，所以方程确定$y<sup>2=x</sup>3+2x^2+x$</p><p>方程左右求导得到$2y \frac{dy}{dx}=3x^2+4x+1$，所以当 y=0 时导数不存在，再把 y=0 代入方程，求得 x=-1，所以找到该曲线的奇点为(-1,0)。</p><p>下一步我们把曲线平移，使得曲线以(0,0)为奇点，得到<code>y^2 = x^3 + 193387944202565886198256260591909756040*x^2</code>，改写为<code>y^2 = (x + 193387944202565886198256260591909756040) * x^2</code></p><p>因为<code>193387944202565886198256260591909756040 = pow(89654903351345918131227153390056628523,2,p)</code><br>我们就可把 P、Q 点映射到乘法群上，从而进行简单的对数计算。</p><p>映射法则如下:<br>$$(x,y)\rightarrow\frac{y+tx}{y-tx}$$</p><h4 id="EXP-v2"><a class="header-anchor" href="#EXP-v2">¶</a>EXP</h4><p>&lt;!–code￼8–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Euler&#39;s Factoring to RSA</title>
    <link href="/2023/04/18/Euler/"/>
    <url>/2023/04/18/Euler/</url>
    
    <content type="html"><![CDATA[<h1>Euler’s Factoring to RSA</h1><h2 id="Outline"><a class="header-anchor" href="#Outline">¶</a>Outline</h2><p>对于 RSA 中$N=(ma<sup>2+nb</sup>2)(mc<sup>2+nd</sup>2)$的情况进行分析以及安全性评测。</p><h2 id="Euler’s-factorization-method"><a class="header-anchor" href="#Euler’s-factorization-method">¶</a>Euler’s factorization method</h2><p>欧拉因式分解法是通过两种方式将数字写成两个平方和来分解数字的方法，对于一个合数$N$来说，若$N=a<sup>2+b</sup>2$，则可以将$N$进行因式分解，例如$1000009=1000<sup>2+3</sup>2=972<sup>2+235</sup>2=293\cdot3413$</p><h2 id="Theoretical-basis"><a class="header-anchor" href="#Theoretical-basis">¶</a>Theoretical basis</h2><p><strong>Brahmagupta-Fibonacci 恒等式</strong><br>$$(a<sup>2+b</sup>2)(c<sup>2+d</sup>2)=(ac-bd)<sup>2+(ad+bc)</sup>2=(ac+bd)<sup>2+(ad-bc)</sup>2$$</p><h2 id="Proof"><a class="header-anchor" href="#Proof">¶</a>Proof</h2><p><img src="/img/Euler.jpg" alt=""></p><p>$$a-c=kl$$<br>$$d-b=km$$<br>$$a+c=hm$$<br>$$d+b=hl$$<br>运用<strong>Brahmagupta-Fibonacci 恒等式</strong><br>$$(k<sup>2+h</sup>2)(l<sup>2+m</sup>2)=(kl+hm)<sup>2+(km-hl)</sup>2=((a-c)+(a+c))<sup>2+((d-b)-(d+b))</sup>2=4a<sup>2+4b</sup>2=4n$$<br>所以得到<br>$$n=((\frac{k}{2})<sup>2+(\frac{h}{2})</sup>2)(l<sup>2+m</sup>2)$$<br>后续求解如下：<br>$$khl<sup>2+khm</sup>2=(a-c)(d+b)+(a+c)(d-b)$$<br>$$kh(l<sup>2+m</sup>2)=2ad-2bc$$<br>$$l<sup>2+m</sup>2=GCD(ad-bc,n)$$</p><h2 id="Generally"><a class="header-anchor" href="#Generally">¶</a>Generally</h2><p>对于更一般的$N$来说，如果$N=ma<sup>2+nb</sup>2=mc<sup>2+nd</sup>2$的情况应用<strong>欧拉分解</strong>是否可以进行？<br>当然是可以的，但可惜欧拉在 1891 年失去了生命，没能继续进行他的研究。后世 Lucas 和 Mathews 先后对这样的情况进行了分析推导，证明了$N$是可分解的。</p><h2 id="My-proof"><a class="header-anchor" href="#My-proof">¶</a>My proof</h2><p>对于$a,b,c,d,m,n\in \mathbb{Z}^+,并且gcd(ma,nb)=gcd(mc,nd)=1$<br>$$N=ma<sup>2+nb</sup>2=mc<sup>2+nd</sup>2$$<br>$$N=\frac{1}{2}[m(a<sup>2+c</sup>2)+n(b<sup>2+d</sup>2)]$$</p><p>$$N(d<sup>2-b</sup>2)=\frac{1}{2}(ma<sup>2d</sup>2+mc<sup>2d</sup>2+nb<sup>2d</sup>2+nd<sup>4-ma</sup>2b<sup>2-mc</sup>2b<sup>2-nb</sup>4-nb<sup>2d</sup>2)$$<br>$$\because n(d<sup>2-b</sup>2)=m(a<sup>2-c</sup>2)$$</p><p>$$\therefore N=\frac{1}{2}[ma<sup>2d</sup>2-mb<sup>2c</sup>2+mc<sup>2d</sup>2-ma<sup>2b</sup>2+m(a<sup>2-c</sup>2)(d<sup>2+b</sup>2)]$$<br>$$N=m(ad+bc)(ad-bc)$$<br>我们还需要另外一个等式，运用<strong>Brahmagupta-Fibonacci 恒等式</strong>得到<br>$$N<sup>2=(ma</sup>2+nb<sup>2)(mc</sup>2+nd^2)$$<br>$$N<sup>2=(mac-nbd)</sup>2+mn(ad+bc)^2$$<br>因为$gcd(m,N)=1$,由此得到<br>$$N=gcd(N,ad-bc)* \frac{N}{gcd(N,ad-bc)}$$</p><h2 id="Apply-to-RSA"><a class="header-anchor" href="#Apply-to-RSA">¶</a>Apply to RSA</h2><p>在 RSA 传统加密中我们知道，$N$的选取尤为重要，如果选取的$N$易于分解，那么明文将不再安全。<br>对于$N=(ma<sup>2+nb</sup>2)(mc<sup>2+nd</sup>2)$，即$p=ma<sup>2+nb</sup>2,q=mc<sup>2+nd</sup>2$</p><p>针对这种看似数字很大的$N$,下面进行一些实际的代码生成与攻击。</p><h3 id="P、Q-generate"><a class="header-anchor" href="#P、Q-generate">¶</a>P、Q_generate</h3><p>&lt;!–code￼0–&gt;</p><h3 id="abcd-generate"><a class="header-anchor" href="#abcd-generate">¶</a>abcd_generate</h3><p>&lt;!–code￼1–&gt;</p><h3 id="Encrypt"><a class="header-anchor" href="#Encrypt">¶</a>Encrypt</h3><p>&lt;!–code￼2–&gt;</p><h3 id="Attack"><a class="header-anchor" href="#Attack">¶</a>Attack</h3><p>&lt;!–code￼3–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NSSCTF Round11</title>
    <link href="/2023/04/08/NSSCTFRound11/"/>
    <url>/2023/04/08/NSSCTFRound11/</url>
    
    <content type="html"><![CDATA[<p>最后 rank 排第 4，差一道 AK，可惜。</p><h1>ez_enc</h1><p>题目描述说了不是培根加密，所以考虑 AB 为二进制情况，192 位数判断，8 位为一组，简单写个脚本跑就行。<code>NSSCTF&#123;mS4gT1Kv9L8NjPzx&#125;</code></p><h1>MyMessage(2🩸)</h1><h2 id="题目"><a class="header-anchor" href="#题目">¶</a>题目</h2><p>&lt;!–code￼0–&gt;</p><h2 id="题解"><a class="header-anchor" href="#题解">¶</a>题解</h2><p>分析一下发现是 CRT，e 是 127，不算很大，pwntools 远程连一下就出了，用 127 组 n、c 就能出。</p><p>&lt;!–code￼1–&gt;</p><h1>MyGame(3🩸)</h1><h2 id="题目-v2"><a class="header-anchor" href="#题目-v2">¶</a>题目</h2><p>&lt;!–code￼2–&gt;</p><h2 id="题解-v2"><a class="header-anchor" href="#题解-v2">¶</a>题解</h2><p>仔细读代码，发现是共模攻击，找两组 c、e 即可</p><p>&lt;!–code￼3–&gt;</p><h1>ez_signin(3🩸)</h1><h2 id="题目-v3"><a class="header-anchor" href="#题目-v3">¶</a>题目</h2><p>&lt;!–code￼4–&gt;</p><h2 id="题解-v3"><a class="header-anchor" href="#题解-v3">¶</a>题解</h2><p>从 num1 和 num2 入手进行推导，这种类似推导在<code>seccon</code>中的<code>pqpq</code>也遇到过，遇到 p 和 q 和与差的次方时要善于展开。<br>$$num1=p^e - q^e ; mod ;n$$<br>$$num2=(p-q)^e ; mod ;n=p^e + q^e ;mod;n$$<br>$$num1-num2=2q^e ;mod;n$$<br>与 n 求 gcd 即可得到 q。后续又发现<code>gcd(e,phi)=4</code><br>我直接用<code>phi//4</code>就出了，但看别的师傅题解是使用了 16 次 rabin。<a href="https://www.cnblogs.com/App1eTree#/c/subject/p/nssctf_Round11.html">App1e_Tree</a></p><p>&lt;!–code￼5–&gt;</p><h1>NTR(4❄️)</h1><h2 id="题目-v4"><a class="header-anchor" href="#题目-v4">¶</a>题目</h2><p>&lt;!–code￼6–&gt;</p><h2 id="题解-v4"><a class="header-anchor" href="#题解-v4">¶</a>题解</h2><p>基础 NTRU 格密码，具体推导可看前几篇博客 DUTCTF 的 ez_RSA</p><p>&lt;!–code￼7–&gt;</p><h1>ez_fac(未出)</h1><h2 id="题目-v5"><a class="header-anchor" href="#题目-v5">¶</a>题目</h2><p>&lt;!–code￼8–&gt;</p><h2 id="题解-v5"><a class="header-anchor" href="#题解-v5">¶</a>题解</h2><p>赛后自己推了一下，欧拉公式分解<br><img src="/img/Euler.jpg" alt=""><br>因此有<br>$$a-c=kl$$<br>$$d-b=km$$<br>$$a+c=hm$$<br>$$d+b=hl$$<br>推到这步之后，运用<code>Brahmagupta-Fibonacci</code>恒等式，得到<br>$$n=((\frac{k}{2})<sup>2+(\frac{h}{2})</sup>2)(l<sup>2+m</sup>2)$$</p><p>$$khl<sup>2+khm</sup>2=(a-c)(d+b)+(a+c)(d-b)$$<br>$$kh(l<sup>2+m</sup>2)=2ad-2bc$$<br>$$l<sup>2+m</sup>2=GCD(ad-bc,n)$$<br>所以对应到本题当中，<code>p=GCD((a0*b1-a1*b0),n)</code></p><p>&lt;!–code￼9–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NKCTF2023</title>
    <link href="/2023/04/04/2023NKCTF/"/>
    <url>/2023/04/04/2023NKCTF/</url>
    
    <content type="html"><![CDATA[<h1>数字中国 Babysecret</h1><p>题目</p><p>&lt;!–code￼0–&gt;</p><p>$enc=pow(x,flag,p)$,离散对数问题，p 是光滑的，后续可通过 PH 求解，但 x 未知</p><p>$c=(rx+s);mod;p$,c 和 r 是 30 位的向量，通过 LWE 求解 x 即可。</p><p>&lt;!–code￼1–&gt;</p><h1>NKCTF2023</h1><h2 id="babyRSA"><a class="header-anchor" href="#babyRSA">¶</a>babyRSA</h2><p>题目</p><p>&lt;!–code￼2–&gt;</p><h3 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h3><p>题目后半部分是 dp 泄露，通过 N、e、dP 可求出 P、Q</p><p>&lt;!–code￼3–&gt;</p><h4 id="法一"><a class="header-anchor" href="#法一">¶</a>法一</h4><p>之后要通过$P = m<sup>p;mod;n$与$Q=m</sup>q; mod ;n$来求解 m，下面进行一些数学推导</p><p>$$c_1<sup>q=m</sup>{pq};mod;n$$<br>$$c_1<sup>{pq}=c_2</sup>{p^2};mod;n$$<br>$$c_1<sup>{pq}=c_2</sup>{p^2};mod;p$$</p><p>根据费马小定理转换可得</p><p>$$c_1<sup>n=c_2</sup>p;mod;p$$<br>$$gcd(c_1^n-c_2,n);=;p$$</p><p>求出 p 和 q 后，使用 crt 即可求得 m</p><p>&lt;!–code￼4–&gt;</p><h4 id="法二"><a class="header-anchor" href="#法二">¶</a>法二</h4><p>通过推导将原式转换为</p><p>$$PQ=(k_1p+m)(k_2q+m)$$<br>$$m(P+Q)=2m^2+(k_1p+k_2q)m$$<br>$$PQ-m(P+Q)+m^2=k_1k_2n$$<br>$$PQ-m(c_1+c_2)+m^2=0;mod;n$$</p><p>&lt;!–code￼5–&gt;</p><h2 id="ezRSA"><a class="header-anchor" href="#ezRSA">¶</a>ezRSA</h2><p>已知 phi 分解 n,后续同 babyRSA</p><p>&lt;!–code￼6–&gt;</p><h2 id="ez-math"><a class="header-anchor" href="#ez-math">¶</a>ez_math</h2><p>题目</p><p>&lt;!–code￼7–&gt;</p><p>根据一个 hint 得到<br>$$8^x;mod;n=4$$<br>$$2^{3x-2}=1;mod;n$$<br>由费马小定理得，3x-2=phi</p><p>&lt;!–code￼8–&gt;</p><h2 id="ez-polynomial"><a class="header-anchor" href="#ez-polynomial">¶</a>ez_polynomial</h2><p>题目</p><p>&lt;!–code￼9–&gt;</p><h3 id="题解"><a class="header-anchor" href="#题解">¶</a>题解</h3><p>多项式 RSA，给定 n、e、c</p><p>&lt;!–code￼10–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DUTCTF2023</title>
    <link href="/2023/03/28/DUTCTF2023/"/>
    <url>/2023/03/28/DUTCTF2023/</url>
    
    <content type="html"><![CDATA[<h1>DUTCTF2023wp</h1><h2 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h2><p>仔细一想自己学 CTF 也一年了，纪念一下最后一次参加校赛 🥹，明年可就是出题人了 🤓。但是感觉一年以来荒废了很多时间，在很多方面对题目不熟悉，总跑偏，甚至是自己复现过的一些方法都没意识到（hint 太到位了 😭）。</p><h2 id="Crypto"><a class="header-anchor" href="#Crypto">¶</a>Crypto</h2><p>第一次 ak，好爽 😭</p><h3 id="老滚五"><a class="header-anchor" href="#老滚五">¶</a>*老滚五</h3><p>百度搜龙语，耐心对着找就出了<code>DUTCTF&#123;YOU_ARE_A_REAL_DRAGONBORN&#125;</code></p><h3 id="神奇的短信"><a class="header-anchor" href="#神奇的短信">¶</a>*神奇的短信</h3><p>诺基亚手机，9 键，第一位代表哪个键，第二个代表第几个字母，<code>DUTCTF&#123;SCREW&#125;</code></p><h3 id="随机数的力量"><a class="header-anchor" href="#随机数的力量">¶</a>随机数的力量</h3><p>可先了解一下 MT19937 伪随机数原理，然后看一下<a href="https://blog.csdn.net/qq_42557115/article/details/128228201?spm=1001.2014.3001.5506">破解方法</a>，对于梅森旋转算法之前<a href="https://sch01ar.github.io/2022/10/16/2021ByteCTF-easyxor/">博客</a>也详细推导过。这里针对题目分析一下，首先 ban 掉了 32 位的预测方法，通过了解到，<code>randcrack</code>库实际上是通过收取特定位数来实现预测，例如 32 位数，就需要 624 个，那么如果使用 64 位数，应该就需要 312 个。后续只要对收取的数字进行一下处理，转成 624 个 32 位数即可。<br>这里还有一个疑问就是，最大的 64 位数是$2<sup>{64}-1$，但是如果传$name=2</sup>{64}-1$就无法预测，而改成其余略小一点的 64 位数即可。</p><h4 id="exp"><a class="header-anchor" href="#exp">¶</a>exp</h4><p>&lt;!–code￼0–&gt;</p><h3 id="shamir"><a class="header-anchor" href="#shamir">¶</a>shamir</h3><p>直接找脚本跑，具体如何恢复 a0 系数就不细说了。之前 hitcon 有个也是 shamir 的题，也挺有意思的。<a href="https://sch01ar.github.io/2022/11/28/hitcon2022-BabySSS/">babysss</a></p><p>&lt;!–code￼1–&gt;</p><h3 id="ECC1"><a class="header-anchor" href="#ECC1">¶</a>ECC1</h3><p>发现是 ECDSA 类型，于是现学。。。下面写一下 ECDSA 的签名与验证过程。</p><h4 id="场景"><a class="header-anchor" href="#场景">¶</a>场景</h4><p>Alice 想要使用她的私钥$d_A$来签名，Bob 想用 Alice 的公钥 $H_A$要验证签名$H_A=d_AG$。<br>只有 Alice 才能提供正确的签名，而每个人都可以验证签名。</p><h4 id="签名"><a class="header-anchor" href="#签名">¶</a>签名</h4><p>1.选定一条椭圆曲线$E_p(a,b)$。</p><p>2.选取一个随机数$k,1&lt;k&lt;n-1$，$n$为椭圆曲线的阶。</p><p>3.选取椭圆曲线的基点$G(a,b)$,计算 $K=k * G(a,b)$，令$r=K[0]\mod n$，即 r 是 K 点的横坐标（若 r 为 0，重新选 k 进行计算）。</p><p>4.计算明文 M 的哈希，令$e=hash(M)$，计算$s=k^{-1}(z+rd_A)\mod n$。</p><p>5.给出签名$(r,s)$</p><h4 id="验证"><a class="header-anchor" href="#验证">¶</a>验证</h4><p>1.计算 $u_1=s^{-1}z\mod n$</p><p>2.计算 $u_2=s^{-1}r\mod n$</p><p>3.计算点$P=u_1G+u_2H_A$</p><p>当$r=x_P\mod n$时，签名验证成功。</p><h4 id="解题过程"><a class="header-anchor" href="#解题过程">¶</a>解题过程</h4><p>通过对题目的初步阅读，发现关键是求出私钥<code>d=privkey</code>，而想要求出$d$就要求出$k$，虽然$k$ 是以随机数的形式出现，但发现本题中每次签名过程的 k 并不是完全随机，而是线性伪随机$k = (a * k + b)\mod n$。这里我很想把$k$求出来，然后再去求私钥$d$。所以有没有一种可能，不用求$k$，如果把$k$消掉，方程里只剩一个未知数$d$，即可。细心一点进行数学推导，就会发现答案。<br>$$k_1s_1=e+r_1d\mod n$$<br>$$k_2s_2=e+r_2d\mod n$$<br>$$k_2=ak_1+b\mod n$$<br>$$k_2=ak_1+b+xn$$<br>$$s_1s_2k_2=s_1s_2ak_1+s_1s_2b+s_1s_2xn$$<br>$$s_1(e+r_2d)=s_2a(e+r_1d)+s_1s_2b \mod n$$<br>$$d=(s_1r_2-s_2ar_1)^{-1}(s_2ae-s_1e+s_1s_2b)\mod n$$</p><p>这里两次的使用的$e$一样，是因为传的明文一样，$n$对应的是题目里给的$order$。这里还想说一下自己因为不细致走过的弯路，题目里通过$p$定义的曲线，所以误以为$curve.order$是$p$，这样就会导致前两个式子和第三个算式的模数不同。有趣的是，找到了一篇论文和文章进行了实现。<br><a href="https://cseweb.ucsd.edu/~mihir/papers/dss-lcg.pdf">论文</a><br>但其实$curve.order=order$所以上述所有都是在模$order的条件下$，所以进行一下推导就出了。</p><h4 id="exp-v2"><a class="header-anchor" href="#exp-v2">¶</a>exp</h4><p>&lt;!–code￼2–&gt;</p><h3 id="ECC2"><a class="header-anchor" href="#ECC2">¶</a>ECC2</h3><p>hint:二元 copper<br>看到 hint 瞬间知道怎么做了，前段时间刚学了一下多元 copper，感慨一下还是运用不熟练，没有一眼发现。</p><h4 id="解题思路"><a class="header-anchor" href="#解题思路">¶</a>解题思路</h4><p>同样是 ECDSA，相比于上题来说，k 是随机的，但是每次签名的时候会泄露 k 的高位。此题另外一个关键是，$r$是由私钥$d$生成的，所以不管传什么明文，所得到的$r$是一样的，利用这一点，我们可以构造一个二元方程。<br>$$s_1k_1=z_1+dr \mod n$$<br>$$s_2k_2=z_2+dr \mod n$$<br>$$k=kh+kl$$<br>$$s_1(k_1h+k_1l)-z_1=s_2(k_2h+k_2l)-z_2 \mod n$$<br>$$f(k_1l,k_2l)=s_1(k_1h+k_1l)-z_1-s_2(k_2h+k_2l)+z_2$$<br>随后使用多元 copper 进行求解。具体可看上篇博客。</p><p>&lt;!–code￼3–&gt;</p><h3 id="ez-RSA"><a class="header-anchor" href="#ez-RSA">¶</a>ez_RSA</h3><p>hint 1:<a href="https://www.ijcsi.org/papers/IJCSI-9-2-1-311-314.pdf">论文</a></p><p>hint 2:</p><p>&lt;!–code￼4–&gt;</p><h4 id="解题思路-v2"><a class="header-anchor" href="#解题思路-v2">¶</a>解题思路</h4><p>通过论文，前半部分白给，按照论文造格，即可规约出$_P$。<br>接下来的问题就是如何求$_E$<br>$$c=rh+m \mod p$$<br>$$h=f^{-1}g \mod p$$<br>将一式带入二式<br>$$c=r(f^{-1}g)+m \mod p$$<br>$$cf=rg+mf \mod p$$<br>因为 r 是 1024 位，g 是 768 位，f 是 1024 位，m 是 128 位，p 是 2048 位，所以<br>$$rg+mf \mod p=rg+mf$$<br>$$cf \mod p=rg+mf$$<br>两边同时对$g$取模，即可消去未知数$r$，得到<br>$$m=(f*c \mod p)*f^{-1} \mod g$$</p><h4 id="exp-v3"><a class="header-anchor" href="#exp-v3">¶</a>exp</h4><p>&lt;!–code￼5–&gt;</p><h2 id="misc"><a class="header-anchor" href="#misc">¶</a>misc</h2><h3 id="签到"><a class="header-anchor" href="#签到">¶</a>*签到</h3><p>b 站 21 级 pwn 例会评论区</p><h3 id="我在哪"><a class="header-anchor" href="#我在哪">¶</a>我在哪</h3><p>放大图片看到十八中，搜索临江十八中，发现是重庆十八中，地图上搜一下附近地铁站，挨着桥的就是，曾家岩。</p><h3 id="不要更新"><a class="header-anchor" href="#不要更新">¶</a>不要更新</h3><p>流量分析题，wireshark 里过滤一下 http，找到 github 网页<br><img src="/img/web.png" alt=""><br>根据 hint 查看历史提交记录，发现假 flag，对于密码手来说一眼凯撒，移位 13。<br><img src="/img/kaisa.png" alt=""></p><h2 id="web"><a class="header-anchor" href="#web">¶</a>web</h2><h3 id="Trenja"><a class="header-anchor" href="#Trenja">¶</a>*Trenja</h3><p>F12 打开开发者工具，搜索 flag 字段即可。</p><h2 id="pwn"><a class="header-anchor" href="#pwn">¶</a>pwn</h2><h3 id="中间人"><a class="header-anchor" href="#中间人">¶</a>*中间人</h3><p>太好玩了，原理是汽车滚动码。bob 来开车门，截断，开门失败。bob 再开车门，截断，发送第一次截断信号，bob 开门成功。bob 离开，我们发送第二次截断的信号，打开车门！</p><h2 id="reverse"><a class="header-anchor" href="#reverse">¶</a>reverse</h2><h3 id="贪吃蛇"><a class="header-anchor" href="#贪吃蛇">¶</a>*贪吃蛇</h3><p>拖入 IDA，alt+t 搜索 DUT 即可</p><h3 id="GAME"><a class="header-anchor" href="#GAME">¶</a>*GAME</h3><p>下棋赢了就出了</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Coppersmith相关攻击</title>
    <link href="/2023/03/07/Coppersmith%E6%94%BB%E5%87%BB/"/>
    <url>/2023/03/07/Coppersmith%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1>原理</h1><p>Coppersmith 定理是在一个 e 阶模 n 的多项式$f(x)$中，若有根小于$n^{\frac{1}{e}}$，则可以用 O(log n)的算法求出根。</p><p>直接求解$f(x)$的根可能比较困难，在此利用<code>LLL</code>算法求得多项式$g(x)$，求得的多项式与$f(x)$具有相同的根$x_0$，$g(x)$具有更小的系数，且定义域为整数域。</p><p>本质思想就是把有限域上的方程转化到整数域。</p><h1>理论基础</h1><p>$$f(x,y) = \sum_{i=0}<sup>{d}\sum_{j=0}</sup>{e} a_{i,j}x<sup>iy</sup>j$$</p><h2 id="Howgrave-Graham"><a class="header-anchor" href="#Howgrave-Graham">¶</a>Howgrave-Graham</h2><p><img src="/img/Howgrave.png" alt=""><br>需要构造一个系数更小的多项式，$||g(x)||$代表范数，即最大的系数。构造方法如下<br><img src="/img/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt=""></p><h2 id="LLL-算法"><a class="header-anchor" href="#LLL-算法">¶</a>LLL 算法</h2><p>格基约化算法，通过对构造出的格，从而约化产生符合约束的多项式。<br><img src="/img/LLL.png" alt=""></p><h2 id="p-高位攻击"><a class="header-anchor" href="#p-高位攻击">¶</a>p 高位攻击</h2><p>&lt;!–code￼0–&gt;</p><h3 id="exp"><a class="header-anchor" href="#exp">¶</a>exp</h3><p>&lt;!–code￼1–&gt;</p><h2 id="p-高位部分泄露"><a class="header-anchor" href="#p-高位部分泄露">¶</a>p 高位部分泄露</h2><p>&lt;!–code￼2–&gt;</p><h2 id="q-低位和-p-高位"><a class="header-anchor" href="#q-低位和-p-高位">¶</a>q 低位和 p 高位</h2><p>&lt;!–code￼3–&gt;</p><h2 id="dp-高位攻击"><a class="header-anchor" href="#dp-高位攻击">¶</a>dp 高位攻击</h2><p>给定$e,n,c,dp_0,k,;dp_0=dp&gt;&gt;k$</p><p>$$<br>edp\equiv ed\equiv 1;mod;(p-1)\<br>edp=k(p-1)+1\<br>edp+k-1=kp\<br>edp+k-1 \equiv 0; mod; p\<br>\because dp&lt; p-1\<br>\because edp=k(p-1)+1\<br>\therefore e&gt;k\<br>\therefore e(dp_0 &lt;&lt; k+x)+k-1 \equiv 0;mod;p<br>$$</p><p>&lt;!–code￼4–&gt;</p><h3 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h3><p>&lt;!–code￼5–&gt;</p><h2 id="多元-coppersmith"><a class="header-anchor" href="#多元-coppersmith">¶</a>多元 coppersmith</h2><p><a href="https://lordriot.live/2021/01/06/Way-to-CopperSmith/">原理学习</a><br><a href="https://www.researchgate.net/publication221010552_New_attacks_on_RSA_with_small_secret_CRT-exponents">论文学习 1</a>、<br><a href="https://eprint.iacr.org/2010/146.pdf">论文学习 2</a><br><a href="https://phot0n.com/2022/04/30/MRCTF2022/">脚本来源</a></p><p>&lt;!–code￼6–&gt;</p><p>具体参数说明，例如</p><p>&lt;!–code￼7–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DLP中常用算法</title>
    <link href="/2023/02/24/DLP%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <url>/2023/02/24/DLP%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1>Pohlig-Hellman 算法（光滑阶）</h1><p>给定 a,b,p，p 是素数，求 x，$a^x \equiv b (mod;p)$<br>在模 p 下，设该群的生成元为 g，则有</p><p>$$<br>a \equiv g^{a1} (mod;p) \newline<br>b \equiv g^{b1} (mod;p)<br>$$</p><p>联立条件有</p><p>$$<br>g^{a1x} \equiv g^{b1} (mod;p)<br>$$</p><p>由欧拉定理得$\phi§;=;p-1$，则有$a1x;=b1;(mod;(p-1))$</p><p>1.将 p-1 分解，即 $p-1=p_1<sup>{k_1}p_2</sup>{k_2}\cdots p_m^{k_m}$</p><p>2.将 x 表示成$p_i$ 进制,<br>列出方程<br>$$x;=p_i^0a_0 + p_i<sup>1a_1+…+p_i</sup>{k_i-1}a*{k_i-1}$$</p><p>3.令 r=1，求$(a<sup>x)</sup>{\frac{p-1}{p_i^r}}; \equiv b<sup>{\frac{p-1}{p_i</sup>r}}(mod; p)$</p><p>4.将 2 中的公式代入到 3，展开得到<br>$$a^{a0*\frac{p-1}{p_i}}* a^{(p-1)a1} * a<sup>{(p-1)p_ia_2}…a</sup>{(p-1)p_i^{k_i-2}a_{k_i-1}} \equiv b^{\frac{p-1}{p_i}}(mod;p)$$</p><p>5.从第二项开始，后面每项都是 1，欧拉定理:$a^{(p-1)} \equiv 1(mod;p)$，化简得到的式子为<br>$$\newline a^{a0*\frac{p-1}{p_i}} \equiv b^{\frac{p-1}{p_i}}(mod ;p)\newline$$<br>因为该方程只有 a0 未知，所以可在[0,pi-1]范围内爆破出 a0</p><p>6.再令 r = 2,3,4…ki，重复步骤 3，即可求出所有的$a_2,a_3…a_{k_i-1}$，从而得到 m 个关于 x 的方程，最后使用 CRT 进行求解即可。</p><p>总结:将 p-1 的 m 个质因子，分别求出其方程内的所有系数 a，从而构造了 m 个关于 x 的方程，最终利用 CRT 求解。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2022DASCTF_NOV-lllcccggg-wp</title>
    <link href="/2022/11/30/2022DASCTF_NOV-lllcccgggwp/"/>
    <url>/2022/11/30/2022DASCTF_NOV-lllcccgggwp/</url>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p>如题目名字一样，有好多个lcg，<s>当时看晕了</s><br>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>1.<code>key</code>是一个背包问题，已知公钥<code>m</code>，和的话目前不知道。</p><p>2.以1中的和为<code>seed</code>，通过LCG产生了一组序列<code>output</code>。</p><p>至此，已经可以根据<code>output</code>来求出LCG中的a、b、n，从而求出<code>seed</code>，从而通过背包可求得key。</p><p>3.以<code>key</code>为seed，称作<code>state</code>，再进行LCG，<code>state = (a * state + b) % c</code>，并且a，b，c已知。</p><p>但是想要直接正向求解出最后的state，十分困难，for循环了10^10000次，这里涉及到了<strong>矩阵快速幂</strong>的使用。</p><p>通过构造矩阵<br>$$<br>\mathbf{A} =<br>\begin{bmatrix}<br>state &amp; 1<br>\end{bmatrix}<br>$$<br>$$<br>\mathbf{C} =<br>\begin{bmatrix}<br>a &amp; 0\<br>b &amp; 1\<br>\end{bmatrix}<br>$$<br>通过计算$A<em>C^{10</em>10000}$即可得到矩阵B，B = [ state, 1]</p><p>4.求出state后进行异或解密即可。</p><h1>EXP</h1><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包加密算法</title>
    <link href="/2022/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/"/>
    <url>/2022/11/29/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>在一次CTF比赛中遇到了，写了10个for嵌套硬爆出来了，复现的时候发现是背包加密。</p><p><img src="/img/bag.png" alt=""></p><h2 id="Merkle–Hellman-公钥加密算法"><a class="header-anchor" href="#Merkle–Hellman-公钥加密算法">¶</a>Merkle–Hellman 公钥加密算法</h2><p>整体加密流程<br>&lt;!–code￼0–&gt;<br>可以发现，加密十分容易，但解密十分困难，这也是非对称加密的特点。</p><h3 id="加密"><a class="header-anchor" href="#加密">¶</a>加密</h3><h4 id="生成私钥"><a class="header-anchor" href="#生成私钥">¶</a>生成私钥</h4><p>超递增序列，也就是a中每一位元素需要大于其之前所有元素的和。<br>&lt;!–code￼1–&gt;</p><h4 id="生成公钥"><a class="header-anchor" href="#生成公钥">¶</a>生成公钥</h4><p>模数m要求：<code>m &gt; sum(a)</code><br>乘数w要求：<code>gcd(w,m) == 1</code><br>&lt;!–code￼2–&gt;<br>b和m作为公钥。<br>加密：<code>S = numpy.dot(x,b)</code></p><h3 id="解密"><a class="header-anchor" href="#解密">¶</a>解密</h3><p>拿到公钥$M=(m_1,m_2,\ldots,m_n)$，构造如下矩阵<br>$$<br>\begin{bmatrix}<br>2 &amp; 0 &amp; \ldots &amp; 0 &amp; m_1 \<br>0 &amp; 2 &amp; \ldots &amp; 0 &amp; m_2 \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \<br>0 &amp; 0 &amp; \ldots &amp; 2 &amp; m_n \<br>1 &amp; 1 &amp; \ldots &amp; 1 &amp; S \<br>\end{bmatrix}<br>$$<br>这个矩阵的所有行向量的线性组合构成了一个格，接下来将通过明文的特点和格上的特殊解法来进行解密。</p><h4 id="LLL"><a class="header-anchor" href="#LLL">¶</a>LLL</h4><p>对于明文$X=(x_1,x_2,\ldots,x_n)$这一组数来说，构造一个向量<br>$$<br>a=\sum_{i=1}^nx_iv_i-v_{n+1}=(2x_1-1,2x_2-1,\ldots,2x_n-1,0)<br>$$<br>显然，a向量在格L上。因为X中的所有x只能取值0或1，因此a向量的长度很小，约为$\sqrt{n}$，对于很大的格基来说，a向量无疑是格L上的最小向量，因此我们利用LLL算法即可求出a向量。</p><h4 id="例题"><a class="header-anchor" href="#例题">¶</a>例题</h4><p>&lt;!–code￼3–&gt;<br>这里注意一下，第一行向量中是有+1与-1，需要进行取反，即-1代表1，1代表0。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>非对称加密</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hitcon 2022-㊙️BabySSS</title>
    <link href="/2022/11/28/hitcon2022-BabySSS/"/>
    <url>/2022/11/28/hitcon2022-BabySSS/</url>
    
    <content type="html"><![CDATA[<p>I implemented a toy Shamir’s Secret Sharing for fun. Can you help me check is there any issues with this?</p><h1>Shamir’s Secret Sharing密钥分享算法</h1><p>$$f(x)=a_0 + a_1x + a_2x^2 + …… + a_{k-1} x^{k-1} mod p<br>$$</p><h1>题目源码</h1><p>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>题目给了8组x，y的值，可通过CRT模x求出a_0 ，通过模x^2 可求出a_1 ，同理可求出所有系数，恢复出polyeval函数，从而得到正确的secret。</p><h1>EXP</h1><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gauss格基约简算法</title>
    <link href="/2022/11/24/Gauss%E6%A0%BC%E5%9F%BA%E7%BA%A6%E7%AE%80%E7%AE%97%E6%B3%95/"/>
    <url>/2022/11/24/Gauss%E6%A0%BC%E5%9F%BA%E7%BA%A6%E7%AE%80%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>由Gauss提出的二维格基约化算法</p><h1>算法伪代码</h1><p>即对给定的两个基向量进行不断的相互约化，最终求得格上的最小向量</p><p>Loop</p><p>(a) If ||v2|| &lt; ||v1||, swap v1, v2</p><p>(b) Compute m = ⌊ v1∙v2 / v1∙v1 ⌉</p><p>© If m = 0, return v1, v2</p><p>(d) v2 = v2 - m*v1</p><p>Continue Loop</p><h1>代码实现</h1><p>&lt;!–code￼0–&gt;</p><h1>例题</h1><p>&lt;!–code￼1–&gt;</p><h2 id="思路"><a class="header-anchor" href="#思路">¶</a>思路</h2><p>给定公钥q、h，以及明文e</p><p>要求私钥f、g</p><p>他们之间有如下关系：</p><p>fh ≡ g mod q</p><p>即 kq + g =fh</p><p>g = fh -kq<br>根据这一特点即可构造格，也就是格密码中很经典的，遇到一个向量乘矩阵，即可进行构造</p><p>由于存在一组a、b，使得a（1，h）+ b（0，q）=（f，g）$a(1,h) + b(0,q) = (f,g)$</p><p>a = f，b = k</p><p>选取一组基底为（1，h）和（0，q），也就是上述高斯约简算法当中的v1与v2，求出v1与v2格上最小的向量，即为（f，g）</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼2–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lattice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树建立与遍历</title>
    <link href="/2022/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/"/>
    <url>/2022/11/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>网上很多算法通过直接将二叉树结点连接，从而构成二叉树，这里我构建了一个二叉树类，通过用户控制输入来建立二叉树。</p><p>有层序遍历，递归、非递归的前序遍历、中序遍历、后序遍历算法。</p><p>&lt;!–code￼0–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022祥云杯wp-crypto</title>
    <link href="/2022/10/30/2022-10-30-2022%E7%A5%A5%E4%BA%91%E6%9D%AFwp-crypto/"/>
    <url>/2022/10/30/2022-10-30-2022%E7%A5%A5%E4%BA%91%E6%9D%AFwp-crypto/</url>
    
    <content type="html"><![CDATA[<h1>little little fermat</h1><h2 id="题目源码"><a class="header-anchor" href="#题目源码">¶</a>题目源码</h2><p>&lt;!–code￼0–&gt;</p><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>根据题目名字来看，此题和费马小定理的使用有关，题目中有一个<code> obfuscate</code>函数，进行了对q的生成，<code>q=p+A</code>，这里可以看一下A的范围，是在2<sup>[18,319]</sup>之间，因此p、q接近，尝试一下yafu分解。</p><p><img src="/img/20221030.jpg" alt=""><br>题目对m先进行了处理，再进行RSA加密，因此我们需要知道x。<code>assert 114514 ** x % p == 1</code>运用费马小定理，若114514与p互素，则x=p-1，即可求解m。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p><h1>fill</h1><h2 id="题目源码-v2"><a class="header-anchor" href="#题目源码-v2">¶</a>题目源码</h2><p>&lt;!–code￼2–&gt;</p><h2 id="题目分析-v2"><a class="header-anchor" href="#题目分析-v2">¶</a>题目分析</h2><p>随机产生32位的数，sha256()加密后作为flag，并将其2进制的每一位存到了<code>f_list</code>数组中。</p><p>又 创建了一个<code>r_list</code>32位数组，里面存着随机数，先暂时不管。</p><p>双 对<code>r_list</code>数组中的随机数做了加密，产生了<code>M</code>数组。</p><p>对<code>f_list</code>和<code>M</code>数组进行了<code>numpy.dot</code>运算，即向量乘法，得到和为S。</p><p>叒 创建了一个<code>s</code>数组，这个很明显，用LCG线性同余算法进行了加密。</p><p>最后将<code>M</code>数组与<code>s</code>数组相加。</p><p>这就是这道题整体的流程，每一步并不难，只是步骤多，略显复杂。</p><h2 id="EXP-v2"><a class="header-anchor" href="#EXP-v2">¶</a>EXP</h2><h3 id="0x01"><a class="header-anchor" href="#0x01">¶</a>0x01</h3><p>可以先进行一下LCG的求解，把s数组求解出来，从而求出M数组。</p><p>&lt;!–code￼3–&gt;</p><h3 id="0x02"><a class="header-anchor" href="#0x02">¶</a>0x02</h3><p>按理来说，感觉应该根据求出来的<code>M</code>数组进行逆运算，求出<code>r_list</code>数组，但是求出来<code>r_list</code>有什么用呢，所以直接尝试求<code>f_list</code>。因为<code>f_list</code>中不是0就是1，与<code>M</code>做向量乘法，即为<code>M</code>数组中若干元素的和。根据题目给定和S，先大概看一下需要<code>M</code>中多少个元素累加。发现在M前21位和 &lt; S，前22位和 &gt; S，所以猜想应该是M当中，除10个左右元素之外的和。</p><p>这里就遍历了一下，复杂度实在太高了，也没想着能出，结果还真算出来了o.O</p><p>&lt;!–code￼4–&gt;</p><p>也就说明，<code>f_list</code>中下标为这些的，对应值是0，其余为1，即可得到msg的2进制数，转为十进制后进行<code>sha256()</code>加密即可。</p><p>&lt;!–code￼5–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022NewStarCTF-flip_flop</title>
    <link href="/2022/10/27/2022NewStarCTF-flip_flop/"/>
    <url>/2022/10/27/2022NewStarCTF-flip_flop/</url>
    
    <content type="html"><![CDATA[<h1>flip-flop</h1><p>AES-CBC加密模式</p><h2 id="题目"><a class="header-anchor" href="#题目">¶</a>题目</h2><p>源码如下：<br>&lt;!–code￼0–&gt;</p><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>此题是通过注册得到的用户账户的密文，然后输入管理员账户对应的密文，才能得到flag。</p><p>对用户账户和管理员账户的加密解密均采用AES-CBC模式，但是本题仅有一组明文，iv仅作为偏移量，也就是本题中的user_key。</p><p>这里先来说一下我最一开始的思路，由于user_key每次是随机产生的，但是一次程序的运行当中是不变的。由于密文由两部分组成，前半部分为user_key.hex()，后半部分为code.hex()，所以只要构造出admin对应的code即可，那么就需要AES加密当中的key，所以就需要构造一个key来产生出admin对应的code。查询了很多资料发现都难以实现。于是……</p><p>那为什么不换一下思路？不能构造code，能不能构造iv？</p><p>先来看一下加密方式：</p><p>C = encrypt(M ^ iv)</p><p>M = decrypt©^iv</p><p>对应一下本题当中的NewStarCTFer和admin：<br><code>b'NewStarCTFer____' = decrypt(code) ^ iv1</code></p><p><code>b'AdminAdmin______' = decrypt(code) ^ iv2</code></p><p>因此可求出admin对应的iv2，随后拼接上普通用户的后半段code即可。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUU刷题日记20221026</title>
    <link href="/2022/10/26/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221026/"/>
    <url>/2022/10/26/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221026/</url>
    
    <content type="html"><![CDATA[<h1>RSA5</h1><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>给定e=65537</p><p>给了很多组n、c</p><p>由于e过大，所以不考虑使用CRT，由于m是同一个，因此遍历一下，求出两个n的最大公约数，即为p，后续就简单了。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022 DASCTF 10月挑战赛wp</title>
    <link href="/2022/10/23/2022DASCTF10%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwp/"/>
    <url>/2022/10/23/2022DASCTF10%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9Bwp/</url>
    
    <content type="html"><![CDATA[<h1>RSA</h1><h2 id="题目如下"><a class="header-anchor" href="#题目如下">¶</a>题目如下</h2><p>&lt;!–code￼0–&gt;</p><h2 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h2><p>该题的加密顺序是：</p><p>1、加密flag，分为两部分m1、m2</p><p>2、加密m1</p><p>3、加密m2</p><p>同理我们解密的顺序应该也是</p><p>1、解出m1、m2</p><p>2、解出flag</p><h3 id="求m2"><a class="header-anchor" href="#求m2">¶</a>求m2</h3><p>先观察一下encrypt4函数</p><p>虽然说e_2=3，按理来说使用低加密指数攻击，但并不可行。</p><p>又因为m = m % k</p><p>可通过这点和<code>c_3 = pow(m, e_2, n_3)</code>做遍历求出m</p><p>最后发现m即为m2，m2 &lt; k</p><h3 id="求m1"><a class="header-anchor" href="#求m1">¶</a>求m1</h3><p>发现m1加密方式采用RSA，但是n_1未知</p><p>n_1又通过一次RSA加密，已知n_1对应的密文</p><p>利用低加密指数攻击解出n1</p><p>发现n1可分解为3个素数乘积</p><p>故phi可求，即求出m1</p><h3 id="求flag"><a class="header-anchor" href="#求flag">¶</a>求flag</h3><p>观察encryt1</p><p>m1是flag右移200位之后转为字节</p><p>m2是flag的20位之后转成字节</p><p>所以来说m2是没什么问题，主要找到flag的前20位，再把m2拼到后面即可。</p><p>由于m1是flag右移200位，因此flag的低位缺失，但高位还在，由于不知道flag总长度，抱着试一试的心态，猜测一下它的高位前20位没有缺失</p><p>我们将m1和m2转为字节发现</p><p>m1:b’0x666c61677b3230366538353964’</p><p>m2:b’383539643865383534633466363030636231323735376262663966357d’</p><p>发现m1和m2有重叠部分，即38353开始</p><p>可以证实m1前20位确实没有缺失</p><p>因此取m1前20位，加m2，即可解出flag</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUU刷题日记20221022</title>
    <link href="/2022/10/22/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221022/"/>
    <url>/2022/10/22/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221022/</url>
    
    <content type="html"><![CDATA[<h1>RSA4</h1><p>题目只给了三组n、c，采用中国剩余定理，具体推导如下</p><h2 id="推导过程"><a class="header-anchor" href="#推导过程">¶</a>推导过程</h2><p>m<sup>e</sup> ≡ c1 mod n1<br>m<sup>e</sup> ≡ c2 mod n2<br>m<sup>e</sup> ≡ c3 mod n3</p><h3 id="中国剩余定理（CRT）"><a class="header-anchor" href="#中国剩余定理（CRT）">¶</a>中国剩余定理（CRT）</h3><p>中国剩余定理的内容是：</p><p>针对上述方程组，若n1、n2、n3互质，对于任意的c1、c2、c3，方程组都有解，使用条件是m^e &lt; n1、n2、n3。通解形式如下：</p><p>令N = n1 * n2 * n3，N1 = N/n1，N2、N3同理</p><p>令t1 = N1<sup>(-1)</sup>，即其对应的模n1运算的逆元，t2，t3同理，可用<code>t1=gmpy2.invert(N1,n1)</code>表示。</p><p>有了Ni和ti的定义，我们就可以给出通解形式：</p><p>x = c1 * N1 * t1 ……</p><p>有了通解公式我们就可以求出m^e，对e进行一下遍历即可，m开方成功即可。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUU刷题日记20221021</title>
    <link href="/2022/10/21/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221021/"/>
    <url>/2022/10/21/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221021/</url>
    
    <content type="html"><![CDATA[<h1>RSA2</h1><p>题目给定n、e、dp、c</p><p>非预期解：直接分解n</p><p>下面考虑n不能分解的情况</p><h2 id="推导过程"><a class="header-anchor" href="#推导过程">¶</a>推导过程</h2><p>dp ≡ d mod (p-1)</p><p>ed ≡ 1 mod (p-1) * (q-1)</p><p>ed = 1 + k2(p-1)(q-1)</p><p>对1式两端同乘e，得</p><p>e * dp ≡ ed mod (p-1)</p><p>e * dp = k1(p-1) + ed</p><p>代入ed得</p><p>e * dp = k1(p-1) + 1 + k2(p-1)(q-1)</p><p>由于两个未知数略显麻烦，发现公因子(p-1)，等式两边同时取余p-1，即可消掉n</p><p>e * dp ≡ 1 mod (p-1)</p><p>e * dp =k(p-1) + 1</p><p>得到这个式子后，其实真正意义上的未知数只有我们要求的p，但是还存在一个k。</p><p>针对k，我们判断一下他的范围，看看能否采用爆破的方式。</p><p>k = (e * dp - 1)/(p-1)</p><p>因为dp &lt; p-1</p><p>所以k &lt; e</p><p>通过遍历k然后找到(e * dp - 1)可以整除k的情况即可。</p><p>(跑了一下发现限制条件还不够)</p><p>因此再加一个n能否整除p即可。</p><h2 id="EXP"><a class="header-anchor" href="#EXP">¶</a>EXP</h2><p>&lt;!–code￼0–&gt;</p><h1>RSA3</h1><p>给定n、e1、c1、e2、c2。</p><p>m ≡ c1^e1 mod n</p><p>m ≡ c2^e2 mod n</p><p>这里采用共模攻击，详细原理如下：</p><p>扩展欧几里得算法：给定两个整数a、b，必定存在x、y，使得gcd(a,b)=ax+by</p><p>对应到本题当中，由于e1、e2互为素数，因此gcd(e1,e2)=1，从而存在s1、s2使得:</p><p>s1 * e1 + s2 * e2 = 1</p><h2 id="推导过程-v2"><a class="header-anchor" href="#推导过程-v2">¶</a>推导过程</h2><p>m = m % n</p><p>m = m^(s1 * e1 + s2 * e2)^ % n</p><p>m = m^(e1 * s1)^ * m^(e2 * s2)^ % n</p><p>m = (m^(e1 * s1)^ % n) * (m^(e2 * s2)^ % n) % n</p><p>m = (c1<sup>s1</sup> % n) * (c2<sup>s2</sup> % n) % n</p><h2 id="EXP-v2"><a class="header-anchor" href="#EXP-v2">¶</a>EXP</h2><p>&lt;!–code￼1–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUU刷题日记20221020</title>
    <link href="/2022/10/20/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221020/"/>
    <url>/2022/10/20/BUU%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B020221020/</url>
    
    <content type="html"><![CDATA[<h1>RSA1</h1><p>给定dp、dq类型</p><p>dp ≡ d mod (p-1)</p><p>dq ≡ d mod (q-1)</p><p>m ≡ c<sup>d</sup> mod n</p><p>m = c<sup>d</sup> + k * n</p><p>m = c<sup>d</sup> +k * p * q</p><p>对上式两端同时对p、q分别取余，得：（中国剩余定理）</p><p>m1 ≡ c<sup>d</sup> mod p</p><p>m2 ≡ c<sup>d</sup> mod q</p><p>同理，可得到<br>c<sup>d</sup> = m1 +k * p</p><p>代入到 m2 ≡ c<sup>d</sup> mod q 中：</p><p>m2 ≡ (m1 + k * p)mod q ，两端减去m1得</p><p>m2 - m1 ≡ k * p mod q ，两端乘p的逆元得</p><p>(m2 - m1)p<sup>-1</sup> ≡ k mod q</p><p>将k代入到 c<sup>d</sup> = m1 +k * p 中得：</p><p>c<sup>d</sup> = m1 + ((m2 - m1)p<sup>-1</sup> mod q) * p</p><p>m=c<sup>d</sup> mod n</p><p>得到</p><p>m ≡ (((m2 - m1) * p<sup>-1</sup> mod q) * p + m1) mod n</p><p>接下来就是求解m1，m2</p><p>m1 ≡ c<sup>dp+k(p-1)</sup> mod p</p><p>m2 ≡ c<sup>dq+k(q-1)</sup> mod q</p><p>根据费马小定理</p><p>若p是素数，则a<sup>(p-1)</sup> ≡ 1 mod p</p><p>因此 m1 ≡ c<sup>dp</sup> mod p，m2 ≡ c<sup>dq</sup> mod q</p><p>最终可求得m</p><h2 id="exp"><a class="header-anchor" href="#exp">¶</a>exp</h2><p>&lt;!–code￼0–&gt;</p><h1>RSAROLL</h1><p>&lt;!–code￼1–&gt;<br>给了一个data.txt文件，打开盲猜一下第一行是n，e，后面是c<br>&lt;!–code￼2–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021ByteCTF-easyxor</title>
    <link href="/2022/10/16/2021ByteCTF-easyxor/"/>
    <url>/2022/10/16/2021ByteCTF-easyxor/</url>
    
    <content type="html"><![CDATA[<h1>题目源码如下</h1><p>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>将flag分为两段，前半段采用OFB加密，后半段采用CBC加密</p><h2 id="OFB解密"><a class="header-anchor" href="#OFB解密">¶</a>OFB解密</h2><p>将前半段flag又进行切分，将其8位分为一组，存到group数组中。<br>&lt;!–code￼1–&gt;<br>针对一个随机生成的64位的last，与keys进行convert加密，再与group中的数进行异或。<br>keys是四个-32～32的数，可爆破。<br>对于OFB解密十分简单，因为我们已知第一组明文，恰好是8位的’ByteCTF{'，由于分组密码的性质，所以后面的也就迎刃而解，通过group[ 0]^cipher[ 0] 即可得到cur_c，从而求得下一次的cur_c，以此类推。</p><h3 id="expOFB"><a class="header-anchor" href="#expOFB">¶</a>expOFB</h3><p>&lt;!–code￼2–&gt;</p><h2 id="CBC解密"><a class="header-anchor" href="#CBC解密">¶</a>CBC解密</h2><p>针对后半部分，我们需要逆向解出convert函数，因此就是对shift函数中的加密运算进行解密。<br>之前上网搜的wp都一笔带过，没解释unshift逆函数怎么写的。“难道有什么定理？？”<br>这里简单写一下我的理解。</p><h3 id="分析shift"><a class="header-anchor" href="#分析shift">¶</a>分析shift</h3><p>&lt;!–code￼3–&gt;</p><h4 id="推理过程"><a class="header-anchor" href="#推理过程">¶</a>推理过程</h4><p>这里我们举例k&gt;0时的情况。（k&lt;0同理）</p><p>m和c都是64位,k是-32～32的10进制数。</p><p>1、m &lt;&lt; k相当于在m后补k位0，得到的新数我们称为a，a=m &lt;&lt; k。</p><p>2、令b = a &amp; c，由于a是64+k位，c是64位，所以b是64位，并且b的后k位都是0。</p><p>3、令x = m ^ b，x则是shift加密之后的值，x也是64位，并且x的后k位是与m的后k位相同的，与0异或得本身。</p><p>我们走完了一遍shift加密，得到的结论是，密文的位数同样是64，并且密文的后k位与明文相同。</p><h3 id="分析unshift"><a class="header-anchor" href="#分析unshift">¶</a>分析unshift</h3><p>&lt;!–code￼4–&gt;</p><h4 id="推理过程-v2"><a class="header-anchor" href="#推理过程-v2">¶</a>推理过程</h4><p>同样我们举例k&gt;0的情况。</p><p>之前我们得到的密文x，相当于tmp。</p><p>1、a’=tmp &lt;&lt; k，tmp后k位为0，tmp后2k～k位等于m的后k位。</p><p>2、b’=a’ &amp; c，b’后k位为0，后2k～k位为m&amp;c。</p><p>3、y=x ^ b’，y的后k位，等于x的后k位，也就是m的后k位。</p><p>4、y的后2k～k位，在shift加密当中，a &amp; c的后2k～k位等于m的后k位&amp;c，记作m1 &amp; c。</p><p>shift中的x，也就是m ^ b，m ^(m1 &amp; c)，在unshift最后的一步操作中，y= m ^(m1 &amp; c) ^ b’。</p><p>这时我们只考虑y的后2k～k位，y=m ^(m1 &amp; c)^(m1 &amp; c) = m</p><p>所以这时y的2k～k位也等于m了。</p><h4 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h4><p>因此，我们发现每经过unshift一次，就有k位被还原，何时才能被完全还原？即循环bits//k次。</p><p>此推理正确，可以在unshift函数运行时输出每次的tmp观察即可。</p><p>ps：自我感觉这种位运算应该是属于一种性质或者定理，网上大佬们都是说“简单写个逆”。。。</p><h3 id="expCBC"><a class="header-anchor" href="#expCBC">¶</a>expCBC</h3><p>&lt;!–code￼5–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022BUUCTF新生赛-RSA</title>
    <link href="/2022/10/16/2022BUUCTF%E6%96%B0%E7%94%9F%E8%B5%9B-RSA/"/>
    <url>/2022/10/16/2022BUUCTF%E6%96%B0%E7%94%9F%E8%B5%9B-RSA/</url>
    
    <content type="html"><![CDATA[<h1>题目源码</h1><p>&lt;!–code￼0–&gt;</p><h1>题目分析</h1><p>发现n和phin都不常规，没入手点，发现hint，hint=pow(d,e,n)，有趣，用d做明文，尝试推理一下：<br>d = pow(hint,d,n)<br>d = pow((d ** e % n),d,n)<br>d = (d ** e % n) ** d % n<br>d = d ** (e*d) % n<br>d = pow(d ** e,d,n)<br>把d ** e再次看做密文，可得<br>d ** e = pow(d,e,n)<br>因为hint = pow(d,e,n)<br>可得hint = d ** e<br>d ** e * e ** e-&gt;(ed) ** e-&gt;(ed) ** e == 1 mod phin<br>因此根据e和hint即可求得phin<br>从而得到phin和n的最大公约数p<br>脚本如下<br>&lt;!–code￼1–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>梦开始的地方</title>
    <link href="/2022/10/15/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
    <url>/2022/10/15/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="Mac下利用Hexo和github-pages搭建个人博客"><a class="header-anchor" href="#Mac下利用Hexo和github-pages搭建个人博客">¶</a>Mac下利用Hexo和github pages搭建个人博客</h2><h3 id="环境配置"><a class="header-anchor" href="#环境配置">¶</a>环境配置</h3><h4 id="1-Node-js安装"><a class="header-anchor" href="#1-Node-js安装">¶</a>1.Node.js安装</h4><p>下载地址：<a href="https://nodejs.org/en/">Node.js</a></p><h4 id="2-淘宝镜像安装"><a class="header-anchor" href="#2-淘宝镜像安装">¶</a>2.淘宝镜像安装</h4><p>&lt;!–code￼0–&gt;</p><h4 id="3-安装Hexo"><a class="header-anchor" href="#3-安装Hexo">¶</a>3.安装Hexo</h4><p>&lt;!–code￼1–&gt;</p><h3 id="初始化Hexo-Blog"><a class="header-anchor" href="#初始化Hexo-Blog">¶</a>初始化Hexo Blog</h3><h4 id="1-初始化Hexo"><a class="header-anchor" href="#1-初始化Hexo">¶</a>1.初始化Hexo</h4><p>新建一个文件夹并进入，例如blog<br>&lt;!–code￼2–&gt;</p><h4 id="2-本地启动Hexo"><a class="header-anchor" href="#2-本地启动Hexo">¶</a>2.本地启动Hexo</h4><p>&lt;!–code￼3–&gt;<br>浏览器打开网站，即可看到本地博客</p><h3 id="创建博客文章"><a class="header-anchor" href="#创建博客文章">¶</a>创建博客文章</h3><h4 id="1-创建文章"><a class="header-anchor" href="#1-创建文章">¶</a>1.创建文章</h4><p>&lt;!–code￼4–&gt;<br>在blog文件夹中的_post里即可看到新建的md文件</p><h4 id="2-清理缓存项目"><a class="header-anchor" href="#2-清理缓存项目">¶</a>2.清理缓存项目</h4><p>在新建博客或修改博客时，需要进行该操作<br>&lt;!–code￼5–&gt;</p><h4 id="3-重新生成博客"><a class="header-anchor" href="#3-重新生成博客">¶</a>3.重新生成博客</h4><p>&lt;!–code￼6–&gt;</p><h4 id="4-启动博客"><a class="header-anchor" href="#4-启动博客">¶</a>4.启动博客</h4><p>&lt;!–code￼7–&gt;</p>]]></content>
    
    
    <categories>
      
      <category>建站</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/15/hello-world/"/>
    <url>/2022/10/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3><p>&lt;!–code￼0–&gt;</p><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3><p>&lt;!–code￼1–&gt;</p><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3><p>&lt;!–code￼2–&gt;</p><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><p>&lt;!–code￼3–&gt;</p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
